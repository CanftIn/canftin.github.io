"use strict";Rectangle.prototype.collisionTest=function(t,o){return"Circle"===t.mType?this.collidedRectCirc(t,o):this.collidedRectRect(this,t,o)};var SupportStruct=function(){this.mSupportPoint=null,this.mSupportPointDist=0},tmpSupport=new SupportStruct;Rectangle.prototype.findSupportPoint=function(t,o){var i;tmpSupport.mSupportPointDist=-9999999,tmpSupport.mSupportPoint=null;for(var e=0;e<this.mVertex.length;e++)0<(i=this.mVertex[e].subtract(o).dot(t))&&i>tmpSupport.mSupportPointDist&&(tmpSupport.mSupportPoint=this.mVertex[e],tmpSupport.mSupportPointDist=i)},Rectangle.prototype.findAxisLeastPenetration=function(t,o){for(var i,e=999999,n=null,r=!0,s=0;r&&s<this.mFaceNormal.length;){var l=this.mFaceNormal[s].scale(-1),a=this.mVertex[s];t.findSupportPoint(l,a),(r=null!==tmpSupport.mSupportPoint)&&tmpSupport.mSupportPointDist<e&&(e=tmpSupport.mSupportPointDist,n=s,i=tmpSupport.mSupportPoint),s+=1}if(r){var p=this.mFaceNormal[n].scale(e);o.setInfo(e,this.mFaceNormal[n],i.add(p))}return r};var collisionInfoR1=new CollisionInfo,collisionInfoR2=new CollisionInfo;Rectangle.prototype.collidedRectRect=function(t,o,i){var e,n=!1;if((e=t.findAxisLeastPenetration(o,collisionInfoR1))&&(n=o.findAxisLeastPenetration(t,collisionInfoR2)))if(collisionInfoR1.getDepth()<collisionInfoR2.getDepth()){var r=collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());i.setInfo(collisionInfoR1.getDepth(),collisionInfoR1.getNormal(),collisionInfoR1.mStart.subtract(r))}else i.setInfo(collisionInfoR2.getDepth(),collisionInfoR2.getNormal().scale(-1),collisionInfoR2.mStart);return e&&n},Rectangle.prototype.collidedRectCirc=function(t,o){var i,e,n,r,s,l,a=!0,p=-99999,c=0;for(i=0;i<4;i++){if(0<(n=(e=t.mCenter).subtract(this.mVertex[i]).dot(this.mFaceNormal[i]))){p=n,c=i,a=!1;break}p<n&&(p=n,c=i)}if(a)l=this.mFaceNormal[c].scale(t.mRadius),o.setInfo(t.mRadius-p,this.mFaceNormal[c],e.subtract(l));else{var m=e.subtract(this.mVertex[c]),u=this.mVertex[(c+1)%4].subtract(this.mVertex[c]),f=m.dot(u);if(f<0){if((r=m.length())>t.mRadius)return!1;l=(s=m.normalize()).scale(-t.mRadius),o.setInfo(t.mRadius-r,s,e.add(l))}else if(m=e.subtract(this.mVertex[(c+1)%4]),u=u.scale(-1),(f=m.dot(u))<0){if((r=m.length())>t.mRadius)return!1;l=(s=m.normalize()).scale(-t.mRadius),o.setInfo(t.mRadius-r,s,e.add(l))}else{if(!(p<t.mRadius))return!1;l=this.mFaceNormal[c].scale(t.mRadius),o.setInfo(t.mRadius-p,this.mFaceNormal[c],e.subtract(l))}}return!0};