<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>矩木</title>
  
  <subtitle>Matrix Wood</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://canftin.com/"/>
  <updated>2018-06-28T16:49:37.506Z</updated>
  <id>http://canftin.com/</id>
  
  <author>
    <name>CanftIn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>车牌识别项目接手--使用opencv手动实现算法</title>
    <link href="http://canftin.com/2018/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB%E9%A1%B9%E7%9B%AE%E6%8E%A5%E6%89%8B_%E4%BD%BF%E7%94%A8opencv%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95/"/>
    <id>http://canftin.com/2018/车牌识别项目接手_使用opencv手动实现算法/</id>
    <published>2018-06-28T15:41:18.000Z</published>
    <updated>2018-06-28T16:49:37.506Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手了一个毕业生学长的项目，一个车牌识别的项目。项目还有点问题，前不久跟学长交流过。</p><p>写篇文章记录一下学长的实现思路以及我后续需要做的内容。</p><p>感觉基本图像处理部分是手动实现完了，并没有用深度学习调模型这样先进的方式，完全手动实现算法处理的貌似。学长做了一个服务端和客户端，服务端做图像接收，客户端做图像处理。有趣的一个点是刚开始我以为服务端就是放在摄像头上然后捕捉视频流一帧一帧发个客户端处理，但是他做出来的是客户端放在摄像头上，直接在摄像头上处理完了把得到的数据发给服务端。</p><p>实际做出来的东西基本能识别图像了（按照截取出来的车牌进行识别基本上没问题，但是复杂场景的切图还是不太成功），代码其实并不算太复杂，只是有的地方在我看来太具有c的味道了，明明是用的c++但是全是c语言的写法…部分代码，呃…只是说代码部分，写的并不优雅，学长也说了是时间不够的原因，毕竟他之前一直做内核移植花了大量的时间。</p><p>代码内部通过构建了几个数组，将车牌的地域名和ascii码等这些车牌基本数据构建成库，然后实现了一个链表对库做操作。整个图像识别系统在linux环境下，并使用opencv3.0以上版本做图像处理的库（后来我在我自己的环境安装opencv后编译未成功，highgui缺失…目前也还没搞定，没时间…），主要做法是先切图，先各种把车牌挖出来（我接手的时候就是这里有问题…），挖完之后要去铆钉，因为车牌上都会有铆钉造成整个图像识别产生噪声，去掉铆钉之后，对图像做细化，细化后再切成大小一致的图，之后再和之前建的库比对就好了。</p><p>基本就是这样，我要做的如果偷懒的话，那么就是把剩下的切图的部分完成，代码再重构一下。<br>要再多研究研究，就是去做一下深度学习的方式，这个恐怕会花很多时间了…我也没什么时间现在:(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近接手了一个毕业生学长的项目，一个车牌识别的项目。项目还有点问题，前不久跟学长交流过。&lt;/p&gt;
&lt;p&gt;写篇文章记录一下学长的实现思路以及我后续需要做的内容。&lt;/p&gt;
&lt;p&gt;感觉基本图像处理部分是手动实现完了，并没有用深度学习调模型这样先进的方式，完全手动实现算法处理的貌似
      
    
    </summary>
    
      <category term="车牌识别" scheme="http://canftin.com/categories/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/"/>
    
      <category term="opencv" scheme="http://canftin.com/categories/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/opencv/"/>
    
    
      <category term="车牌识别" scheme="http://canftin.com/tags/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/"/>
    
      <category term="opencv" scheme="http://canftin.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记系列（零）：基础知识整理</title>
    <link href="http://canftin.com/2018/c++%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97_%E9%9B%B6_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://canftin.com/2018/c++笔记系列_零_基础知识整理/</id>
    <published>2018-06-28T08:54:34.000Z</published>
    <updated>2018-06-28T16:09:58.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列<strong>c++笔记系列</strong>文章主要记录一些我碰到的c++的问题以及需要注意的内容。<br>本文作为开篇，收纳c++的部分基础知识的小tips。<br>可能对读者阅读不友好…因为暂时是我自己的一些小整理，本文内容大部分整理自侯捷老师的课程。<br>曾经写过一些cpp的tricks： <a href="https://www.canftin.com/2017/some-tricks-of-cpp/" target="_blank" rel="noopener">some tricks of cpp</a></p></blockquote><h2 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h2><ul><li>相同类的各个objects互为友元。</li><li>数据一定要放在private里。</li><li>参数尽可能以reference处理（const看状况）</li><li>返回值尽可能以reference处理（为什么：传递者无需知道接受者是以reference接收）<br>  如果返回内容是函数内部新创建的对象（即local object），返回不能by reference而要by value。</li><li>该加const一定要加</li><li>构造函数尽量用initialize_list作参数</li></ul><h2 id="关于操作符重载"><a href="#关于操作符重载" class="headerlink" title="关于操作符重载"></a>关于操作符重载</h2><p>以下为复数的实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>)</span><br><span class="line">        : re(r), im(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">complex</span>&amp; <span class="keyword">operator</span>+= (<span class="keyword">const</span> <span class="keyword">complex</span>&amp; x);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">complex</span>&amp; __doapl(<span class="keyword">complex</span>* ths, <span class="keyword">const</span> <span class="keyword">complex</span>&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>&amp; <span class="keyword">complex</span>::<span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>&amp; __doapl(<span class="keyword">complex</span>* ths, <span class="keyword">const</span> <span class="keyword">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    ths-&gt;re += x.re;</span><br><span class="line">    ths-&gt;im += x.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码<code>complex&amp; operator+= (this, const complex&amp; r){ ... }</code>中一个参数<code>const complex&amp; r</code>，这里可以传值也可以传指针。使用时<code>c2 += c1</code>，这里c2就是this，所有的成员函数都含有一个隐含参数this，这里写不写这个参数都行，c1则是<code>const complex&amp; r</code>。返回为<code>complex&amp;</code>，如果返回用reference接收，那么速度会快，用value接收，则要再复制一次，产生出一个临时对象，速度慢。<br>这里返回类型若为void的话，<code>c2 += c1</code>可以通过编译，<code>c3 += c2 += c1</code>这样的连串赋值无法通过编译。</p><p><strong>另一个有特点的操作符重载</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> <span class="keyword">complex</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">'('</span> &lt;&lt; real(x) &lt;&lt; <span class="string">','</span> &lt;&lt; imag(x) &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1 &lt;&lt; c1;   <span class="comment">// 返回值不能为void，而是ostream&amp;，cout作为os这参数传入函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p><strong>什么时候需要拷贝构造？</strong><br>以上的complex实现里就没有写类似 <code>complex(const complex&amp; x);</code>这样的拷贝构造函数，原因是编译器内部给了一个拷贝构造，而这个默认的拷贝构造功能则是按位copy，即<strong>浅拷贝</strong>。</p><p>而编译器给的这一套在类内部有指针数据的情况下则不够用，比如有一个对象有一个指针指向一个地方，当需要拷贝的时候，新对象的指针还是指向这个地方，那么这个拷贝是内部默认拷贝构造的能力范围内，某些情况下不满足我们实际的需要，有时候我们实际上就是需要完完全全的两个内容，而不是两个指针指向一块相同的内容，这个时候我们就需要<strong>深拷贝</strong>。</p><p>以下为字符串内的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    String(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; str);</span><br><span class="line">    ~String() &#123; <span class="keyword">delete</span>[] m_data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列&lt;strong&gt;c++笔记系列&lt;/strong&gt;文章主要记录一些我碰到的c++的问题以及需要注意的内容。&lt;br&gt;本文作为开篇，收纳c++的部分基础知识的小tips。&lt;br&gt;可能对读者阅读不友好…因为暂时是我自己的一些小整理，本文内容大部分整理
      
    
    </summary>
    
      <category term="c++" scheme="http://canftin.com/categories/c/"/>
    
      <category term="c++笔记系列" scheme="http://canftin.com/categories/c/c-%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="c++" scheme="http://canftin.com/tags/c/"/>
    
      <category term="c++笔记系列" scheme="http://canftin.com/tags/c-%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>我在配置zsh时碰到的问题</title>
    <link href="http://canftin.com/2018/%E6%88%91%E5%9C%A8%E9%85%8D%E7%BD%AEzsh%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://canftin.com/2018/我在配置zsh时碰到的问题/</id>
    <published>2018-06-12T15:55:17.000Z</published>
    <updated>2018-06-12T15:56:33.238Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章提到了如何在VSCode中配置bash环境，这篇文章则记录我在配置zsh时的问题。</p><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>虽然bash虽然比windows上的一堆shell好看了许多，但是zsh搭载oh-my-zsh会更好看，使用agnoster主题配上emacs写lisp和scheme会非常舒服。<br>一个好看的terminal界面会增加操作的可读性。</p><h1 id="配置zsh-amp-amp-oh-my-zsh"><a href="#配置zsh-amp-amp-oh-my-zsh" class="headerlink" title="配置zsh &amp;&amp; oh-my-zsh"></a>配置zsh &amp;&amp; oh-my-zsh</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install zsh</span><br></pre></td></tr></table></figure><p>在oh-my-zsh的官方github上给出安装oh-my-zsh的方法</p><p>via curl</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>via wget</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>未完…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章提到了如何在VSCode中配置bash环境，这篇文章则记录我在配置zsh时的问题。&lt;/p&gt;
&lt;h1 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h1&gt;&lt;p&gt;虽然bash虽然比windows
      
    
    </summary>
    
      <category term="未分类" scheme="http://canftin.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="问题" scheme="http://canftin.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>VSCode在WSL下的c/c++环境配置</title>
    <link href="http://canftin.com/2018/VSCode%E5%9C%A8WSL%E4%B8%8B%E7%9A%84c-c-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://canftin.com/2018/VSCode在WSL下的c-c-环境配置/</id>
    <published>2018-06-10T08:50:32.000Z</published>
    <updated>2018-06-10T09:56:23.017Z</updated>
    
    <content type="html"><![CDATA[<p>我在windows上使用wsl（Windows Subsystem for Linux）做为VScode的内置终端，借以使用gcc的工具链和linux的环境，但是实际上配置还是有一些问题，我把这些问题的解决办法写在这篇文章中。</p><h1 id="配置VSCode的terminal为bash"><a href="#配置VSCode的terminal为bash" class="headerlink" title="配置VSCode的terminal为bash"></a>配置VSCode的terminal为bash</h1><p>首先在windows的文件管理器下可以找到<code>C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs</code>这样一个目录，这个目录貌似是windows版本更新之后有所变动，我目前的系统发布版本是windows10 1803 Version 10.0.17134.48，该目录中<code>&lt;user&gt;</code>为你的用户名，<code>&lt;...&gt;</code>为根据安装得到的一串随机字符串。</p><p>找到这个路径之后，可先在VSCode的setting中配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"terminal.integrated.shell.windows"</span>: <span class="string">"bash.exe"</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.shellArgs.windows"</span>: [</span><br><span class="line">        <span class="string">"-i"</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中”-i”命令是集成bash到VSCode自带终端环境中。</p><h1 id="在WSL中安装gcc，g"><a href="#在WSL中安装gcc，g" class="headerlink" title="在WSL中安装gcc，g++"></a>在WSL中安装gcc，g++</h1><p>打开terminal，可以先更新wsl的镜像源到阿里云，因为Ubuntu自带的源很慢，而且软件包不一定最新。至于怎么配源这里不做介绍。</p><p>由于WSL中没有任何开发环境（如果你是刚刚装上WSL的话），镜像源配好后安装gcc-7</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ sudo apt-get install gcc-7</span><br><span class="line">$ sudo apt-get install g++-7</span><br></pre></td></tr></table></figure><h1 id="检查标准包含目录"><a href="#检查标准包含目录" class="headerlink" title="检查标准包含目录"></a>检查标准包含目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -xc++ -E -v -</span><br><span class="line">...</span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/include/c++/7</span><br><span class="line"> /usr/include/x86_64-linux-gnu/c++/7</span><br><span class="line"> /usr/include/c++/7/backward</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include</span><br><span class="line"> /usr/<span class="built_in">local</span>/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure><p>然后设置配置文件<code>.vscode/c_cpp_properties.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Win32"</span>,</span><br><span class="line">      <span class="attr">"includePath"</span>: [</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/include/c++/7"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/include/x86_64-linux-gnu/c++/7"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/include/c++/7/backward"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/lib/gcc/x86_64-linux-gnu/7/include"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/local/include"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/include/x86_64-linux-gnu"</span>,</span><br><span class="line">        <span class="string">"C:/Users/&lt;user&gt;/AppData/Local/Packages/CanonicalGroupLimited.UbuntuonWindows_&lt;...&gt;/LocalState/rootfs/usr/include"</span>,</span><br><span class="line">        <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"defines"</span>: [<span class="string">"__x86_64__"</span>],</span><br><span class="line">      <span class="attr">"intelliSenseMode"</span>: <span class="string">"clang-x64"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试一段c代码，文件在和.vscode同级的目录下，文件名test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_PARAM_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk_param</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; MIN_PARAM_NUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chk_param(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VSCode的terminal中测试，这是后环境应该为bash了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c test.c -o test.exe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在windows上使用wsl（Windows Subsystem for Linux）做为VScode的内置终端，借以使用gcc的工具链和linux的环境，但是实际上配置还是有一些问题，我把这些问题的解决办法写在这篇文章中。&lt;/p&gt;
&lt;h1 id=&quot;配置VSCode的te
      
    
    </summary>
    
      <category term="vscode" scheme="http://canftin.com/categories/vscode/"/>
    
      <category term="c++" scheme="http://canftin.com/categories/vscode/c/"/>
    
    
      <category term="vscode" scheme="http://canftin.com/tags/vscode/"/>
    
      <category term="c++" scheme="http://canftin.com/tags/c/"/>
    
      <category term="c" scheme="http://canftin.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>解决了个大问题</title>
    <link href="http://canftin.com/2017/%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%AA%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://canftin.com/2017/解决了个大问题/</id>
    <published>2018-04-12T09:24:26.000Z</published>
    <updated>2018-06-10T09:57:38.331Z</updated>
    
    <content type="html"><![CDATA[<p>git的多用户问题。</p><p>关于ssh，我的配置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> Directory of D:\linux_home\.ssh</span><br><span class="line"></span><br><span class="line">04/12/2018  03:12 PM    &lt;DIR&gt;          .</span><br><span class="line">04/12/2018  03:12 PM    &lt;DIR&gt;          ..</span><br><span class="line">04/12/2018  03:39 PM               212 config</span><br><span class="line">02/22/2018  01:56 PM             1,675 id_rsa</span><br><span class="line">02/22/2018  01:56 PM               405 id_rsa.pub</span><br><span class="line">04/12/2018  03:09 PM             1,675 id_rsa_vcanccc</span><br><span class="line">04/12/2018  03:09 PM               397 id_rsa_vcanccc.pub</span><br><span class="line">02/22/2018  01:57 PM             1,197 known_hosts</span><br><span class="line">               6 File(s)          5,561 bytes</span><br><span class="line">               2 Dir(s)  47,690,989,568 bytes free</span><br></pre></td></tr></table></figure></p><p>其中id_rsa当然是CanftIn的私钥了，id_rsa_vcanccc则是Vcanccc这个我的早期账号的。<br>config文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host github_vcanccc</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile /d/linux_home/.ssh/id_rsa_vcanccc</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile /d/linux_home/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p><p>紧接着我就犯傻了，而且还犯了很久(约乎几十分钟吧…)，不过最终还是解决了。</p><p>遇到的问题是，我用Vcanccc这账号将hexo的站部署到github过程中出现了这么个事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to Vcanccc/Vcanccc.github.io.git denied to CanftIn.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><p>这错误很明显，就是没有权限，而且我应该是Vcanccc的操作，这里变成是CanftIn，由于是我之前都是用CanftIn提交到CanftIn的github上。</p><p>所以这里需要在hexo博客源码目录下的_config.yml文件里加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Vcanccc/Vcanccc.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后再执行命令 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>这个时候就是犯傻的地方了，也是报错的地方，仔细再看一看之后，我们可以发现我在config文件中设置的一个Host名是github_vcanccc，而不是github.com:Vcanccc，只有默认的用户还是CanftIn。所以自然会报错了，于是我们将_config.yml文件里添加的内容改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: github_vcanccc:Vcanccc/Vcanccc.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>再执行上述命令，才会成功。</p><p>唉…原本是打算花一点时间搞完了做题目的，没想到浪费了这么多时间。:&lt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git的多用户问题。&lt;/p&gt;
&lt;p&gt;关于ssh，我的配置：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="git" scheme="http://canftin.com/categories/git/"/>
    
    
      <category term="ssh" scheme="http://canftin.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>How to install SLIME+SBCL+Quicklisp into Emacs</title>
    <link href="http://canftin.com/2017/How-to-install-SLIME-SBCL-Quicklisp-into-Emacs/"/>
    <id>http://canftin.com/2017/How-to-install-SLIME-SBCL-Quicklisp-into-Emacs/</id>
    <published>2018-02-10T16:00:00.000Z</published>
    <updated>2018-06-01T14:53:09.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-install-SLIME-SBCL-Quicklisp-into-Emacs"><a href="#How-to-install-SLIME-SBCL-Quicklisp-into-Emacs" class="headerlink" title="How to install SLIME+SBCL+Quicklisp into Emacs"></a>How to install SLIME+SBCL+Quicklisp into Emacs</h1><p>SLIME – SLIME is a Emacs mode for Common Lisp development. Inspired by existing systems such Emacs Lisp and ILISP, we are working to create an environment for hacking Common Lisp in. (<a href="https://common-lisp.net/project/slime/" target="_blank" rel="noopener">https://common-lisp.net/project/slime/</a>)</p><p>SBCL – Steel Bank Common Lisp (SBCL) is a high performance Common Lisp compiler. It is open source / free software, with a permissive license. In addition to the compiler and runtime system for ANSI Common Lisp, it provides an interactive environment including a debugger, a statistical profiler, a code coverage tool, and many other extensions. (<a href="http://www.sbcl.org/" target="_blank" rel="noopener">http://www.sbcl.org/</a>)</p><p>Quicklisp – Quicklisp is a library manager for Common Lisp. It works with your existing Common Lisp implementation to download, install, and load any of over 1,200 libraries with a few simple commands. (<a href="https://www.quicklisp.org/beta/" target="_blank" rel="noopener">https://www.quicklisp.org/beta/</a>)</p><p>This article is a simple instruction for installing SLIME, SBCL and Quicklisp into Emacs, which is the environment I recommend for learning Common Lisp.</p><h2 id="Step-1-–-Install-SLIME"><a href="#Step-1-–-Install-SLIME" class="headerlink" title="Step 1 – Install SLIME"></a>Step 1 – Install SLIME</h2><p>Firstly, you need to install the SLIME by MELPA or Git. Basically, the package in MELPA is always stable, while the files in official Git repository are newest.</p><p>If you choose to install it by MELPA, add lines below into your .emacs file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(require &apos;package)</span><br><span class="line">(add-to-list &apos;package-archives</span><br><span class="line">&apos;(&quot;melpa&quot;     . &quot;http://melpa.milkbox.net/packages/&quot;))</span><br><span class="line">(package-initialize)</span><br></pre></td></tr></table></figure><p>After that, you should be able to install SLIME by M-x package-install RET slime RET. If you found that there is no package named “slime” in the list, running M-x package-refresh-contents will fix it.</p><p>By using Git, you need to run these commands in your terminal.</p><p>cd path/where/you/want/slime/installed<br>git clone <a href="https://github.com/slime/slime.git" target="_blank" rel="noopener">https://github.com/slime/slime.git</a></p><p>Then add lines below into your .emacs file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(add-to-list &apos;load-path &quot;path/of/slime&quot;)</span><br><span class="line">(require &apos;slime-autoloads)</span><br></pre></td></tr></table></figure><h2 id="Step-2-–-Install-SBCL"><a href="#Step-2-–-Install-SBCL" class="headerlink" title="Step 2 – Install SBCL"></a>Step 2 – Install SBCL</h2><p>Download the source archive in official site and unzip it. Run commands below in your terminal after doing that.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path/where/files/unzipped</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><p>SBCL should be installed right now, to make sure, run sbcl in your terminal, there should be a banner produced like this.</p><p>This is SBCL 1.2.14, an implementation of ANSI Common Lisp.<br>More information about SBCL is available at &lt;<a href="http://www.sbcl.org/&gt;" target="_blank" rel="noopener">http://www.sbcl.org/&gt;</a>.</p><p>SBCL is free software, provided as is, with absolutely no warranty.<br>It is mostly in the public domain; some portions are provided under<br>BSD-style licenses. See the CREDITS and COPYING files in the<br>distribution for more information.<br>*</p><p>And you can install it by cloning the git repository (git://git.code.sf.net/p/sbcl/sbcl) as well.</p><p>After the steps above are done, add the line below into your .emacs file.</p><p>(setq inferior-lisp-program “path/of/sbcl”)</p><p>The path of sbcl can be known by running command “which sbcl” in your terminal.</p><h2 id="Step-3-–-Install-Quicklisp"><a href="#Step-3-–-Install-Quicklisp" class="headerlink" title="Step 3 – Install Quicklisp"></a>Step 3 – Install Quicklisp</h2><p>Download the file for installation. (<a href="https://beta.quicklisp.org/quicklisp.lisp" target="_blank" rel="noopener">https://beta.quicklisp.org/quicklisp.lisp</a>)</p><p>Then run sbcl with that file loaded by this command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbcl --load path/of/quicklisp.lisp</span><br></pre></td></tr></table></figure><p>After sbcl launched, type in the command below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(quicklisp-quickstart:install)</span><br></pre></td></tr></table></figure><p>At this moment, Quicklisp has already been installed. If you want to load Quicklisp every time you start Lisp (which is recommended), type in command below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ql:add-to-init-file)</span><br></pre></td></tr></table></figure><p>Then, type in the command which will create a file you can load in Emacs that configures the right load-path for loading Quicklisp’s installation of SLIME.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ql:quickload &quot;quicklisp-slime-helper&quot;)</span><br></pre></td></tr></table></figure><p>Now, you should be able to see a message looks like this.</p><p>To use, add this to your ~/.emacs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(load (expand-file-name &quot;~/quicklisp/slime-helper.el&quot;))</span><br><span class="line">;; Replace &quot;sbcl&quot; with the path to your implementation</span><br><span class="line">(setq inferior-lisp-program &quot;sbcl&quot;)</span><br></pre></td></tr></table></figure><p>As we have already set for sbcl, you just need to copy the first line into your .emacs file.</p><h2 id="Step-4-–-Enjoy-Common-Lisp"><a href="#Step-4-–-Enjoy-Common-Lisp" class="headerlink" title="Step 4 – Enjoy Common Lisp"></a>Step 4 – Enjoy Common Lisp</h2><p>The basic installation has already been done. You can enjoy that by running M-x slime in your Emacs.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;How-to-install-SLIME-SBCL-Quicklisp-into-Emacs&quot;&gt;&lt;a href=&quot;#How-to-install-SLIME-SBCL-Quicklisp-into-Emacs&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="c++" scheme="http://canftin.com/categories/c/"/>
    
    
      <category term="lisp" scheme="http://canftin.com/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>内存中常见异常值的解释</title>
    <link href="http://canftin.com/2017/%E5%86%85%E5%AD%98%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E5%80%BC%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>http://canftin.com/2017/内存中常见异常值的解释/</id>
    <published>2018-01-30T16:00:00.000Z</published>
    <updated>2018-06-01T14:51:41.459Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>0xcccccccc : Used by Microsoft’s C++ debugging runtime library to mark uninitialised stack memory</p></li><li><p>0xcdcdcdcd : Used by Microsoft’s C++ debugging runtime library to mark uninitialised heap memory</p></li><li><p>0xfeeefeee : Used by Microsoft’s HeapFree() to mark freed heap memory</p></li><li><p>0xabababab : Used by Microsoft’s HeapAlloc() to mark “no man’s land” guard bytes after allocated heap memory</p></li><li><p>0xabadcafe : A startup to this value to initialize all free memory to catch errant pointers</p></li><li><p>0xbaadf00d : Used by Microsoft’s LocalAlloc(LMEM_FIXED) to mark uninitialised allocated heap memory</p></li><li><p>0xbadcab1e : Error Code returned to the Microsoft eVC debugger when connection is severed to the debugger</p></li><li><p>0xbeefcace : Used by Microsoft .NET as a magic number in resource files</p><pre><code>平时我们只需要了解上面常见的三种就可以了：0xcccccccc、0xcdcdcdcd和 0xfeeefeee ，以帮我们迅速地发现问题并分析问题。对于0xcccccccc和0xcdcdcdcd，在 Debug 模式下，VC 会把未初始化的栈内存上的指针全部填成 0xcccccccc ，当字符串看就是 “烫烫烫烫……”；会把未初始化的堆内存上的指针全部填成 0xcdcdcdcd，当字符串看就是 “屯屯屯屯……”。那么调试器为什么要这么做呢？VC的DEBUG版会把未初始化的指针自动初始化为0xcccccccc或0xcdcdcdcd，而不是就让取随机值，那是为了方便我们调试程序，如果野指针的初值不确定，那么每次调试同一个程序就可能出现不一样的结果，比如这次程序崩掉，下次却能正常运行，这样显然对我们解bug是非常不利的，所以自动初始化的目的是为了让我们一眼就能确定我们使用了未初始化的野指针了。对于0xfeeefeee，是用来标记堆上已经释放掉的内存。注意，如果指针指向的内存被释放了，变量变量本身的地址如未做改动，还是之前指向的内存的地址。如果该指针是一个类的指针，并且类中包含有指针变量，则内存被释放后（对于C++类，通常是执行delete操作），类中的指针变量就会被赋值为0xfeeefeee。如果早调试代码过程中，发现有值为0xfeeefeee的指针，就说明对应的内存被释放掉了，我们的代码已经出问题了。</code></pre><p>关于VC 中 debug和Release模式下的变量初始化问题</p></li></ul><p>大家都知道，debug跟release在初始化变量时所做的操作是不同的，debug是将每个字节位都赋成0xcc，而release的赋值近似于随机(我想是直接从内存中分配的，没有初始化过)。这样就明确了，如果你的程序中的某个变量没被初始化就被引用，就很有可能出现异常：用作控制变量将导致流程导向不一致；用作数组下标将会使程序崩溃；更加可能是造成其他变量的不准确而引起其他的错误。所以在声明变量后马上对其初始化一个默认的值是最简单有效的办法，否则项目大了你找都没地方找。代码存在错误在debug方式下可能会忽略而不被察觉到，如debug方式下数组越界也大多不会出错，在 release中就暴露出来了，这个找起来就比较难了（参考：<a href="http://bbs.csdn.net/topics/350212712）" target="_blank" rel="noopener">http://bbs.csdn.net/topics/350212712）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;0xcccccccc : Used by Microsoft’s C++ debugging runtime library to mark uninitialised stack memory&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;0xcdcdcdcd : 
      
    
    </summary>
    
      <category term="内存" scheme="http://canftin.com/categories/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="杂" scheme="http://canftin.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>some tricks of cpp</title>
    <link href="http://canftin.com/2017/some-tricks-of-cpp/"/>
    <id>http://canftin.com/2017/some-tricks-of-cpp/</id>
    <published>2017-11-29T16:00:00.000Z</published>
    <updated>2018-06-28T15:06:14.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Some-Tricks-Of-C-Plus-Plus"><a href="#Some-Tricks-Of-C-Plus-Plus" class="headerlink" title="Some Tricks Of C Plus Plus"></a>Some Tricks Of C Plus Plus</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FXXK</span><br><span class="line">&#123;</span><br><span class="line">    string shit_;</span><br><span class="line">public:</span><br><span class="line">    FXXK(string shit) : shit_(shit) &#123; cout &lt;&lt; &quot;FXXK-shit is created: &quot; &lt;&lt; shit &lt;&lt; endl; &#125;</span><br><span class="line">    FXXK() &#123; cout &lt;&lt; &quot;Smelly FXXK created. &quot; &lt;&lt; endl; shit_ = &quot;Smelly&quot;; &#125;</span><br><span class="line">    ~FXXK() &#123; cout &lt;&lt; &quot;FXXK is destroyed: &quot; &lt;&lt; shit_ &lt;&lt; endl; &#125;</span><br><span class="line">    void shit() &#123; cout &lt;&lt; &quot;FXXK &quot; &lt;&lt; shit_ &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>case:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FXXK* fxxk = new FXXK(&quot;shit&quot;);</span><br><span class="line">fxxk-&gt;shit(); //fxxk is a dangling pointer, the memory will be leaked.</span><br></pre></td></tr></table></figure><p>so we need to:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;FXXK&gt; fxxk(new FXXK(&quot;Shit&quot;));    //count = 1</span><br><span class="line">    cout &lt;&lt; fxxk.use_count() &lt;&lt; endl;   //count = 1</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;FXXK&gt; fxxk2 = fxxk;          //count = 2</span><br><span class="line">        cout &lt;&lt; fxxk.use_count() &lt;&lt; endl;//count = 2</span><br><span class="line">        cout &lt;&lt; fxxk2.use_count() &lt;&lt; endl;//count = 2</span><br><span class="line">        fxxk2-&gt;shit();                          //FXXK Shit....</span><br><span class="line">        cout &lt;&lt; fxxk.use_count() &lt;&lt; endl;//count = 2</span><br><span class="line">        cout &lt;&lt; fxxk2.use_count() &lt;&lt; endl;//count = 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fxxk.use_count() &lt;&lt; endl;        //count = 1</span><br><span class="line">    //count = 1</span><br><span class="line">    fxxk-&gt;shit();//FXXK Shit....</span><br><span class="line">    cout &lt;&lt; fxxk.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;   //count = 0 &amp;&amp; FXXK is destroyed : Shit</span><br></pre></td></tr></table></figure><p>but something like that:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//an object should be assigned to a smart pointer as soon as it&apos;s created. Raw pointer should not be used again.</span><br><span class="line">FXXK* fxxk = new FXXK(&quot;shit&quot;);</span><br><span class="line">shared_ptr&lt;FXXK&gt; fxxk_sp(fxxk);</span><br><span class="line">shared_ptr&lt;FXXK&gt; fxxk_sp2(fxxk);    //error, there is no object to be released.</span><br></pre></td></tr></table></figure></p><p>and we still have the method:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FXXK* fxxk = new FXXK(&quot;shit&quot;);</span><br><span class="line">shared_ptr&lt;FXXK&gt; fxxk_sp = make_shared&lt;FXXK&gt;(&quot;shit&quot;);</span><br></pre></td></tr></table></figure></p><p>make_shared is faster. It includes two operations: creating an object named “shit” and giving this to fxxk_sp. In addtion it is safer, because if memory allocation failure happened, it means “shit” is maked successfully but fxxk_sp is not.If we make shared_ptr object first and then make assignment, memory will be leaked.But When we use <strong>“make_shared”</strong>, these thing will not happen.</p><p><strong>btw:</strong> shared_ptr can be used by raw pointer.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*fxxk_sp).shit();  //FXXK shit....    so it works.</span><br></pre></td></tr></table></figure></p><hr><h2 id="Exception-in-Destructor"><a href="#Exception-in-Destructor" class="headerlink" title="Exception in Destructor"></a>Exception in Destructor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FXXK</span><br><span class="line">&#123;</span><br><span class="line">    string shit_;</span><br><span class="line">public:</span><br><span class="line">    FXXK(string shit) : shit_(shit) &#123; cout &lt;&lt; &quot;FXXK-shit is created: &quot; &lt;&lt; shit &lt;&lt; endl; &#125;</span><br><span class="line">    FXXK() &#123; cout &lt;&lt; &quot;Smelly FXXK created. &quot; &lt;&lt; endl; shit_ = &quot;Smelly&quot;; &#125;</span><br><span class="line">    ~FXXK() &#123; cout &lt;&lt; &quot;FXXK is destroyed: &quot; &lt;&lt; shit_ &lt;&lt; endl; &#125;</span><br><span class="line">    void shit() &#123; cout &lt;&lt; &quot;FXXK &quot; &lt;&lt; shit_ &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>case:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    FXXK fxxk1(&quot;shit1&quot;);</span><br><span class="line">    FXXK fxxk2(&quot;shit2&quot;);</span><br><span class="line">    throw 20;</span><br><span class="line">    fxxk1.shit();</span><br><span class="line">    fxxk2.shit();</span><br><span class="line">&#125;</span><br><span class="line">catch (int e)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; e &lt;&lt; &quot; is caught&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//FXXK-shit is created: shit1</span><br><span class="line">//FXXK-shit is created: shit2</span><br><span class="line">//FXXK shit1....</span><br><span class="line">//FXXK shit2....</span><br><span class="line">//FXXK is destroyed: shit2</span><br><span class="line">//FXXK is destroyed: shit1</span><br><span class="line">//20 is caught</span><br></pre></td></tr></table></figure></p><p>the object created first and it will distroyed first. Because the object are stored on stack.<br>If you put <strong><em>throw</em> 20;</strong> into <strong><em>~FXXK()</em></strong> like that:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~FXXK() &#123; cout &lt;&lt; &quot;FXXK is destroyed: &quot; &lt;&lt; shit_ &lt;&lt; endl; throw 20;&#125;</span><br></pre></td></tr></table></figure></p><p>It will abort in just running. This is why we should not throw exception out of a destructor.<br>So there are some solutions:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//first one solution: Destructor swallow the exception.</span><br><span class="line">~FXXK()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //Enclose all the exception prone code here.</span><br><span class="line">    &#125; catch (Exception&amp; e) &#123;</span><br><span class="line">        //catch exceptino</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        //others</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Second solution: Move the exception prone code to a different function.</span><br></pre></td></tr></table></figure><hr><h2 id="Virtual-Function-in-Constructor-or-Destructor"><a href="#Virtual-Function-in-Constructor-or-Destructor" class="headerlink" title="Virtual Function in Constructor or Destructor"></a>Virtual Function in Constructor or Destructor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class FXXK</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    FXXK() &#123; cout &lt;&lt; &quot;FXXK created. &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    ~FXXK() &#123; cout &lt;&lt; &quot;FXXK is destroyed &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void hehe() &#123; cout &lt;&lt; &quot;FXXK hehe &quot; &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void findShit() &#123; hehe(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shit : public FXXK</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shit() &#123; cout &lt;&lt; &quot;Shit created. &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void hehe() &#123; cout &lt;&lt; &quot;Shit hehe &quot; &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>case:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shit s;</span><br><span class="line">s.findShit();</span><br><span class="line">//FXXK created.</span><br><span class="line">//Shit created.</span><br><span class="line">//FXXK hehe ....</span><br><span class="line">//FXXK is destroyed</span><br></pre></td></tr></table></figure><p>case:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class FXXK</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    FXXK() &#123; cout &lt;&lt; &quot;FXXK created. &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    ~FXXK() &#123; cout &lt;&lt; &quot;FXXK is destroyed &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void hehe() &#123; cout &lt;&lt; &quot;FXXK hehe &quot; &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void findShit() &#123; hehe(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shit : public FXXK</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shit() &#123; cout &lt;&lt; &quot;Shit created. &quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void hehe() &#123; cout &lt;&lt; &quot;Shit hehe &quot; &lt;&lt; &quot;....&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shit s;</span><br><span class="line">s.findShit();</span><br><span class="line">//FXXK created.</span><br><span class="line">//Shit created.</span><br><span class="line">//Shit hehe ....</span><br><span class="line">//FXXK is destroye</span><br></pre></td></tr></table></figure><hr><h2 id="Logic-Constness-and-Bitwise-Constness"><a href="#Logic-Constness-and-Bitwise-Constness" class="headerlink" title="Logic Constness and Bitwise Constness"></a>Logic Constness and Bitwise Constness</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fxxk</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    int shitCounter;</span><br><span class="line">public:</span><br><span class="line">    int getItem(int index) const </span><br><span class="line">    &#123;</span><br><span class="line">        shitCounter++;  //error, if it work, make shitCounter to be mutable type</span><br><span class="line">        //or const_cast&lt;Fxxk*&gt;(this)-&gt;shitCounter++;</span><br><span class="line">        return v[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="Assignment-to-Self-in-Assignment-Operator"><a href="#Assignment-to-Self-in-Assignment-Operator" class="headerlink" title="Assignment to Self in Assignment Operator"></a>Assignment to Self in Assignment Operator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Shit</span><br><span class="line">&#123;</span><br><span class="line">    Shit() = delete;</span><br><span class="line">    Shit(Shit* shit) = delete;</span><br><span class="line">&#125;;</span><br><span class="line">class Fxxk</span><br><span class="line">&#123;</span><br><span class="line">    Shit* shit;</span><br><span class="line">    Fxxk&amp; operator=(const Fxxk&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this == &amp;rhs)</span><br><span class="line">            return *this;</span><br><span class="line"></span><br><span class="line">        //unsafe:</span><br><span class="line">        //delete shit;</span><br><span class="line">        //shit = new Shit(*rhs.shit);</span><br><span class="line">        Shit* pOrigShit = shit;</span><br><span class="line">        shit = new Shit(*rhs.shit);</span><br><span class="line">        delete pOrigShit;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void func(auto a = 1);  //error:auto不能用于函数参数</span><br><span class="line"></span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">auto var1_ = 0;  //error:auto不能用于非静态成员变量</span><br><span class="line">static const auto var2_ = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct Bar &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int arr[10] = &#123;0&#125;;</span><br><span class="line">auto aa = arr;  //OK: aa -&gt; int *</span><br><span class="line">auto rr[10] = arr;  //error:auto无法定义数组</span><br><span class="line">Bar&lt;int&gt; bar;</span><br><span class="line">Bar&lt;auto&gt; bb = bar;  //error:auto无法推导出模板参数</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>This paper is Copyrighted @2017 by CanftIn(Wancan Wang), you can contact him by</em></strong> <a href="http://www.canftin.com" target="_blank" rel="noopener">www.canftin.com</a> <strong><em>or</em></strong> <a href="https://weibo.com/u/5632002270" target="_blank" rel="noopener">weibo</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Some-Tricks-Of-C-Plus-Plus&quot;&gt;&lt;a href=&quot;#Some-Tricks-Of-C-Plus-Plus&quot; class=&quot;headerlink&quot; title=&quot;Some Tricks Of C Plus Plus&quot;&gt;&lt;/a&gt;Some Tri
      
    
    </summary>
    
      <category term="c++" scheme="http://canftin.com/categories/c/"/>
    
      <category term="c++笔记系列" scheme="http://canftin.com/categories/c/c-%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="c++" scheme="http://canftin.com/tags/c/"/>
    
      <category term="c++笔记系列" scheme="http://canftin.com/tags/c-%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>OSGI知识点</title>
    <link href="http://canftin.com/2017/OSGI%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://canftin.com/2017/OSGI知识点/</id>
    <published>2017-10-24T16:00:00.000Z</published>
    <updated>2018-06-01T14:53:38.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用OSGI优缺点"><a href="#使用OSGI优缺点" class="headerlink" title="使用OSGI优缺点"></a>使用OSGI优缺点</h1><p>使用OSGI构建Java应用优点比较明显，主要体现在以下几个方面：</p><p>1、基于OSGI的应用程序可动态更改运行状态和行为。在OSGI框架中，每一个Bundle实际上都是可热插拔的，因此，对一个特定的Bundle进行修改不会影响到容器中的所有应用，运行的大部分应用还是可以照常工作。当你将修改后的Bundle再部署上去的时候，容器从来没有重新启过。这种可动态更改状态的特性在一些及时性很强的系统中比较重要，尤其是在Java Web项目中，无需重启应用服务器就可以做到应用的更新。</p><p>2、OSGI是一个微核的系统，所谓微核是指其核心只有为数不多的几个jar包。基于OSGI框架的系统可分可合，其结构的优势性导致具体的Bundle不至于影响到全局，不会因为局部的错误导致全局系统的崩溃。例如Java EE项目中可能会因为某个Bean的定义或注入有问题，而导致整个应用跑不起来，而使用OSGI则不会有这种问题，顶多相关的几个Bundle无法启动。</p><p>3、可复用性强，OSGI框架本身可复用性极强，很容易构建真正面向接口的程序架构，每一个Bundle 都是一个独立可复用的单元。</p><p>使用OSGI的缺点如下：<br>1、每个Bundle都由单独的类加载器加载，与一些Java EE项目中使用比较多的框架整合比较困难。</p><p>2、目前OSGI框架提供的管理端不够强大，现在的管理端中仅提供了基本的Bundle状态管理、日志查看等功能，像动态修改系统级别的配置(config.ini)、动态修改Bundle的配置(Manifest.mf)、启动级别等功能都尚未提供，而这些在实际的项目或产品中都是非常有必要的。</p><p>3、采用OSGI作为规范的模块开发、部署方式自然给现有开发人员提出了新的要求，需要学习新的基于OSGI的开发方式。</p><h1 id="OSGI具体实现"><a href="#OSGI具体实现" class="headerlink" title="OSGI具体实现"></a>OSGI具体实现</h1><p>OSGI是OSGi Alliance组织制定的Java模块化规范，但是该组织并没有给出OSGI容器的实现，具体实现由第三方厂商完成，目前使用较多的OSGI容器有 Apache Felix和Equinox。<br><a href="http://m.blog.csdn.net/Rongbo_J/article/details/53711964" target="_blank" rel="noopener">osgi企业应用开发</a></p><h1 id="OSGi基本概念"><a href="#OSGi基本概念" class="headerlink" title="OSGi基本概念"></a>OSGi基本概念</h1><h3 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1.    Bundle"></a><strong>1.    Bundle</strong></h3><blockquote><p>   Bundle是OSGi中的模块，其生命周期被OSGi所管理，可以被动态的安装、启动、停止和卸载。通过OSGi框架将多个Bundle组织在一起就形成了系统。每一个Bundle有独立于其他Bundle的ClassLoader，所以每个Bundle的内部实现都是隔离的。</p></blockquote><p><strong>状态转换关系如下:</strong></p><p><img src="C:\Users\CanftIn\Desktop\osgithinking\osgi.png" alt=""></p><p>在toast项目中，开始先常规建立Gps，Airbag，emergency等类，全部放在Toast项目下Toast包中，再加入Main类作为启动项。</p><p>然后将Toast项目划分为各个Bundle，将其模块化为下图：</p><h3 id="bundle依赖"><a href="#bundle依赖" class="headerlink" title="bundle依赖"></a>bundle依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[紧急情况监视器] --&gt; B[安全气囊]</span><br><span class="line">    A[紧急情况监视器] --&gt; C[GPS]</span><br></pre></td></tr></table></figure><p>将原项目中的类全部映射到各个Bundle中去，在Gps、Airbag中导出所包供emergency使用。</p><p>在Bundle中服务的注册是在Activator中的start和stop里使用org.osgi.framework.ServiceRegistration包，调用registerService()和unregister()。</p><h3 id="2-Service"><a href="#2-Service" class="headerlink" title="2.    Service"></a><strong>2.    Service</strong></h3><blockquote><p>OSGi服务就是注册到OSGi框架当中的Java对象。在注册时可以设置这个Service的属性。在获取Service是可以根据属性进行过滤。Bundle可以根据Bundle的上下文去注册Service或查询Service。</p></blockquote><h3 id="交互过程："><a href="#交互过程：" class="headerlink" title="交互过程："></a>交互过程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">    A[Bundle Service Consumer] --&gt; |getService|B[OSGi FrameWork] </span><br><span class="line">    C[Bundle Service Provider] --&gt; |register|B[OSGi FrameWork]</span><br><span class="line">    A[Bundle Service Consumer] --&gt; |invoke|C[Bundle Service Provider]</span><br></pre></td></tr></table></figure><h3 id="3-SOCM"><a href="#3-SOCM" class="headerlink" title="3.    SOCM"></a><strong>3.    SOCM</strong></h3><h3 id="4-DS"><a href="#4-DS" class="headerlink" title="4.    DS"></a><strong>4.    DS</strong></h3><blockquote><p>三种处理服务动态特性的机制：OSGi服务追踪器（Service Tracker），服务激活器工具包（Service Activator Toolkit， SAT）的第三方处理机制，以及OSGi的声明式服务（Declaration Services，DS)即这里说的DS。</p></blockquote><ul><li><p>服务追踪器（Service Tracker）</p><blockquote></blockquote><p>  private ServiceTrackerCustomizer createAirbagCustomizer() {</p><pre><code>return new ServiceTrackerCustomizer() {    @Override    public Object addingService(ServiceReference reference) {        Object service = context.getService(reference);        synchronized(Activator.this) {            if(Activator.this.airbag == null) {                Activator.this.airbag = (IAirbag)service;                Activator.this.bind();            }        }        return service;    }    @Override    public void modifiedService(ServiceReference reference, Object service) {    }    @Override    public void removedService(ServiceReference reference, Object service) {        synchronized(Activator.this) {            if(service != Activator.this.airbag)                return;            Activator.this.unbind();            Activator.this.bind();        }    }};</code></pre><p>  }</p><p>  private ServiceTrackerCustomizer createGpsCustomizer() {</p><pre><code>return new ServiceTrackerCustomizer() {    public Object addingService(ServiceReference reference) {        Object service = context.getService(reference);        synchronized(Activator.this) {            if(Activator.this.gps == null) {                Activator.this.gps = (IGps)service;                Activator.this.bind();            }        }        return service;    }    @Override    public void modifiedService(ServiceReference reference, Object service) {    }    @Override    public void removedService(ServiceReference reference, Object service) {        synchronized(Activator.this) {            if(service != Activator.this.airbag)                return;            Activator.this.unbind();            Activator.this.bind();        }                    }};</code></pre><p>  }</p></li><li><p>SAT </p><blockquote><p>   略</p></blockquote></li><li><p>DS</p><blockquote><p>   声明式服务不需要加载Bundle的代码来判断Bundle所需要的条件是否满足。DS以组件的方式进行工作，一个组件以两个部分构成，一个是xml文件(一般component.xml)，一个是类(用于实现组件所提供的服务并接收所引用的服务)。</p></blockquote></li></ul><blockquote><p>在DS中定义了另外一套模型：Service Component模型，每个提供服务的对象被称为一个服务组件（Service Component），所有的组件均受服务组件运行时SCR（Service Component Runtime）的管理。</p></blockquote><h1 id="OSGi通信方式"><a href="#OSGi通信方式" class="headerlink" title="OSGi通信方式"></a>OSGi通信方式</h1><p><strong>osgi中每个Bundle都有自己独立于其他Bundle的classloader，因此各个Bundle内部的类是隔离的。</strong></p><p><strong>而一个Bundle用到另外的Bundle的类，Bundle之间交互通信的实现方式有两种：</strong></p><p><strong>1、通过Package的导入和导出来实现，即提供类的Bundle对外暴露自己的一个或者多个Package，而使用方需要导入这些package</strong></p><p><strong>2、通过Service的方式。一个Bundle作为Service的提供方，对外提供Service，使用者查询到提供的Service并使用。而Service又有两种方式：</strong></p><ul><li><strong>经典做法，通过BundleContext上下文进行提供和获取</strong></li><li><strong>另一种是使用Declaration Service</strong></li></ul><h1 id="OSGi规范"><a href="#OSGi规范" class="headerlink" title="OSGi规范"></a>OSGi规范</h1><ul><li>执行环境</li><li>安全层</li><li>模块层<br>模块层主要做的就是导包。<br>动态模块化实现的是模块间的引用与隔离和模块的动态启动与停用。<br>关键在于类加载架构。<br>osgi中类加载器分为三类:<br>父类加载器:</li><li>生命周期层<br>在生命周期层的停止过程中，osgi会自动调用Activator的stop方法，执行完stop方法后，其他的bundle就不能再使用该bundle的上下文状态，即bundlecontext对象。<br>而即使bundle已经停止，它导出的package仍然是可以使用的，其他的bundle仍然可以执行停止的bundle中的代码。<br>只是开始bundle安装和解析的过程一定要加入所有所需bundle（未确定）</li><li>服务层<br>服务层包括:<br>1、service<br>服务不能孤立存在，每个服务从属并运行于提供服务的bundle上。<br>首先要把服务注册到所有bundle共享的服务注册表（service registry）中。其他bundle使用服务只需从注册表里查找所需服务而不与提供服务的bundle进行交互<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A[bundle1] --&gt; B[服务注册表]</span><br><span class="line">  C[bundle2] --&gt; B[服务注册表]</span><br></pre></td></tr></table></figure></li></ul><p>2、service registry<br>  服务注册表<br>3、service reference<br>4、service registration<br>5、service event<br>6、service listener</p><ul><li>框架API</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用OSGI优缺点&quot;&gt;&lt;a href=&quot;#使用OSGI优缺点&quot; class=&quot;headerlink&quot; title=&quot;使用OSGI优缺点&quot;&gt;&lt;/a&gt;使用OSGI优缺点&lt;/h1&gt;&lt;p&gt;使用OSGI构建Java应用优点比较明显，主要体现在以下几个方面：&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
      <category term="Java" scheme="http://canftin.com/categories/Java/"/>
    
    
      <category term="OSGI" scheme="http://canftin.com/tags/OSGI/"/>
    
  </entry>
  
</feed>
