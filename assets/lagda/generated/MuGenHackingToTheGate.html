---
layout: page
permalink: /lagda/MuGenHackingToTheGate.html
inline_latex: true
agda: true
---
<body>
{% raw %}<h1 id="抽刀断水水更流状态转移是解构">抽刀断水水更流，状态转移是解构</h1>
<p>这篇文章是写给对 Agda 有一定基础的人看的，所以我会使用一定程度的 Unicode（会尽量避免）。 当然，有基本的 Haskell 基础也能看。 本文会介绍如何使用 Agda 表达无限大的类型，并证明对它的有限使用是停机的。</p>
<p>这些特性 Idris <strong>都没有</strong>。</p>
<p><strong>（编辑于 2019 年 4 月：由于 HoTT-Agda 和标准库依赖冲突，现已改为对一个我自己写的基础库的使用）。</strong></p>
<pre class="Agda"><a id="229" class="Symbol">{-#</a> <a id="233" class="Keyword">OPTIONS</a> <a id="241" class="Pragma">--no-unicode</a>  <a id="255" class="Symbol">#-}</a>
<a id="259" class="Symbol">{-#</a> <a id="263" class="Keyword">OPTIONS</a> <a id="271" class="Pragma">--without-K</a>   <a id="285" class="Symbol">#-}</a>
<a id="289" class="Symbol">{-#</a> <a id="293" class="Keyword">OPTIONS</a> <a id="301" class="Pragma">--cubical</a>     <a id="315" class="Symbol">#-}</a>
<a id="319" class="Symbol">{-#</a> <a id="323" class="Keyword">OPTIONS</a> <a id="331" class="Pragma">--copattern</a>   <a id="345" class="Symbol">#-}</a>
<a id="349" class="Symbol">{-#</a> <a id="353" class="Keyword">OPTIONS</a> <a id="361" class="Pragma">--guardedness</a> <a id="375" class="Symbol">#-}</a>
<a id="379" class="Symbol">{-#</a> <a id="383" class="Keyword">OPTIONS</a> <a id="391" class="Pragma">--sized-types</a> <a id="405" class="Symbol">#-}</a>

<a id="410" class="Keyword">module</a> <a id="417" href="MuGenHackingToTheGate.html" class="Module">MuGenHackingToTheGate</a> <a id="439" class="Keyword">where</a>

<a id="446" class="Keyword">open</a> <a id="451" class="Keyword">import</a> <a id="458" href="HoTT-Agda.html" class="Module">HoTT-Agda</a>
<a id="468" class="Keyword">variable</a> <a id="477" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a> <a id="479" class="Symbol">:</a> <a id="481" href="Agda.Primitive.html#408" class="Postulate">Level</a>
</pre>
<p>后两个 pragma 是默认打开的，我写出来是为了让它更明显。</p>
<h2 id="停机性的重要性">停机性的重要性</h2>
<pre class="Agda"><a id="545" class="Keyword">module</a> <a id="PleaseGoDieIfNotTerminate"></a><a id="552" href="MuGenHackingToTheGate.html#552" class="Module">PleaseGoDieIfNotTerminate</a> <a id="578" class="Keyword">where</a>
</pre>
<p>如果我们可以写出不停机的函数，会怎么样？</p>
<p>在类型系统较弱的编程语言（Haskell，Rust）中，我们没有禁止死循环。 这很常规，谁不想写点无限运行的程序呢对吧。</p>
<p>在形式验证中，所有函数必须停机。否则，比如，我们可以用一个命题本身作为它自己的证明， 这样任意假命题都得证了：</p>
<pre class="Agda">  <a id="740" class="Symbol">{-#</a> <a id="744" class="Keyword">NON_TERMINATING</a> <a id="760" class="Symbol">#-}</a>
  <a id="PleaseGoDieIfNotTerminate.test2"></a><a id="766" href="MuGenHackingToTheGate.html#766" class="Function">test2</a> <a id="772" class="Symbol">:</a> <a id="774" class="Number">1</a> <a id="776" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="778" class="Number">1</a> <a id="780" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="783" class="Number">3</a>
  <a id="787" href="MuGenHackingToTheGate.html#766" class="Function">test2</a> <a id="793" class="Keyword">rewrite</a> <a id="801" href="MuGenHackingToTheGate.html#766" class="Function">test2</a> <a id="807" class="Symbol">=</a> <a id="809" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a>
</pre>
<p>很明显这是不科学的。 这也是为什么明明 Coq 和 Agda 有着强大的多的类型系统，却『图灵不完备』的原因。</p>
<p>于是，我们需要保证两件事：</p>
<ol start="0" type="1">
<li>保证我们的函数停机</li>
<li>说服编译器，让它认为我们的函数停机</li>
</ol>
<p>第二件事可不太容易，因为编译器判断停机性的方法很迷，请听下文分解。</p>
<h2 id="传统定义">传统定义</h2>
<p>无穷大，在一般的编程语言中是没有办法表示的。 在拥有惰性求值的语言中，我们可以使用逆归纳（Coinductive）数据类型表示。 比如，Haskell 语言。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">O</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">mugen ::</span> <span class="dt">Nat</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>mugen <span class="ot">=</span> <span class="dt">S</span> mugen</span></code></pre></div>
<p>它的意义在于，考虑到自然数的减法和比较运算：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">minus ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>minus <span class="dt">O</span> _ <span class="ot">=</span> <span class="dt">O</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>minus a <span class="dt">O</span> <span class="ot">=</span> a</span>
<span id="cb2-4"><a href="#cb2-4"></a>minus (<span class="dt">S</span> a) (<span class="dt">S</span> b) <span class="ot">=</span> minus a b</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ot">lessThan ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>lessThan _ <span class="dt">O</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>lessThan <span class="dt">O</span> _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>lessThan (<span class="dt">S</span> a) (<span class="dt">S</span> b) <span class="ot">=</span> lessThan a b</span></code></pre></div>
<p>我们发现，给定任意一个非无限大的自然数（假设它叫 <code>a</code>），我们都有：</p>
<ul>
<li><code>lessThan a mugen</code> 返回 <code>True</code></li>
<li><code>lessThan mugen a</code> 返回 <code>False</code></li>
<li><code>minus mugen a</code> 返回的东西还是 <code>mugen</code></li>
<li><code>minus a mugen</code> 返回 <code>O</code></li>
</ul>
<p>这正是我们想要的无限大的性质，不是吗？</p>
<p>有个小问题，我们不能对 <code>mugen</code> 求值，或者比较两个 <code>mugen</code>。 这正好也符合无限大的数学意义，因为我们是不能比较这玩意的（我记得应该是可以说无限大等于无限大的， 但这没法用 Haskell 表达出来）。</p>
<p>Agda 是一个编译期 call-by-name，运行时 call-by-need 的语言。 所以我们很明显可以定义出无限大的自然数。</p>
<pre class="Agda"><a id="1739" class="Keyword">module</a> <a id="TranditionalNatMuGen"></a><a id="1746" href="MuGenHackingToTheGate.html#1746" class="Module">TranditionalNatMuGen</a> <a id="1767" class="Keyword">where</a>
  <a id="1775" class="Symbol">{-#</a> <a id="1779" class="Keyword">NON_TERMINATING</a> <a id="1795" class="Symbol">#-}</a>
  <a id="TranditionalNatMuGen.mugen"></a><a id="1801" href="MuGenHackingToTheGate.html#1801" class="Function">mugen</a> <a id="1807" class="Symbol">:</a> <a id="1809" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
  <a id="1815" href="MuGenHackingToTheGate.html#1801" class="Function">mugen</a> <a id="1821" class="Symbol">=</a> <a id="1823" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="1825" href="MuGenHackingToTheGate.html#1801" class="Function">mugen</a>
</pre>
<p>但是，这个函数的定义本身就是个无限循环， 我们必须要把这样的函数定义成 <code>NON_TERMINATING</code> 的，不然 Agda 会报错，说：</p>
<pre class="text"><code>Termination checking failed for the following functions:
  TranditionalNatMuGen.mugen
Problematic calls:
  mugen</code></pre>
<p>然后，如果我们试图对这个 <code>mugen</code> 进行一些基本的使用：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  testNeq <span class="op">:</span> mugen ≠ <span class="dv">0</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  testNeq ()</span></code></pre></div>
<p>会报错，因为 Agda 对 <code>NON_TERMINATING</code> 的定义根本不会产生编译期计算：</p>
<pre class="text"><code>Failed to solve the following constraints:
  Is empty: mugen == FromNat.read ℕ-reader 0</code></pre>
<p>这很不好！我们知道这个函数不停机，但我们对它的使用却是有限的！ 如何让编译器知道我们对它的使用是有限的呢？</p>
<p>Agda 有个旧方法可以实现 Coindutive 数据类型，HoTT-Agda 还封装了它：</p>
<pre class="Agda"><a id="2380" class="Keyword">import</a> <a id="2387" href="Agda.Builtin.Coinduction.html" class="Module">Agda.Builtin.Coinduction</a> <a id="2412" class="Symbol">as</a> <a id="2415" class="Module">OldWayCoinduction</a> <a id="2433" class="Keyword">using</a> <a id="2439" class="Symbol">()</a>
</pre>
<p>我上古时期还写过<a href="/2018/05/30/CoinductiveTypesInAgda/">博客</a>介绍它， 但是现在我已经不会再用这个库了——首先它是不安全的，借助它可以证明假命题。 其次，我们有更好的替代品。</p>
<h2 id="次时代逆归纳数据结构">次时代逆归纳数据结构</h2>
<pre class="Agda"><a id="2577" class="Keyword">module</a> <a id="NextGenerationCoinductiveDataTypes"></a><a id="2584" href="MuGenHackingToTheGate.html#2584" class="Module">NextGenerationCoinductiveDataTypes</a> <a id="2619" class="Keyword">where</a>
</pre>
<p>首先，这种逆归纳数据结构是需要『记录（Record）』的， 也就是只有一个数据构造器的数据类型。为了满足 <code>Nat</code> 有两个数据构造器的需求， 我们需要 <code>Maybe</code>。</p>
<pre class="Agda">  <a id="NextGenerationCoinductiveDataTypes.Maybe"></a><a id="2727" href="MuGenHackingToTheGate.html#2727" class="Function">Maybe</a> <a id="2733" class="Symbol">:</a> <a id="2735" class="Symbol">(</a><a id="2736" href="MuGenHackingToTheGate.html#2736" class="Bound">A</a> <a id="2738" class="Symbol">:</a> <a id="2740" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2745" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a><a id="2746" class="Symbol">)</a> <a id="2748" class="Symbol">-&gt;</a> <a id="2751" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2756" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a>
  <a id="2760" href="MuGenHackingToTheGate.html#2727" class="Function">Maybe</a> <a id="2766" href="MuGenHackingToTheGate.html#2766" class="Bound">A</a> <a id="2768" class="Symbol">=</a> <a id="2770" href="Agda.Builtin.Unit.html#137" class="Record">Unit</a> <a id="2775" href="Cubical.Data.Sum.Base.html#170" class="Datatype Operator">⊎</a> <a id="2777" href="MuGenHackingToTheGate.html#2766" class="Bound">A</a>
</pre>
<p>在介绍逆归纳的 <code>Conat</code> 前，我们先写一个我们熟悉的归纳版本的、使用记录实现的 <code>Conat'</code>，作为一个过渡：</p>
<pre class="Agda">  <a id="2855" class="Keyword">module</a> <a id="InductiveConat"></a><a id="2862" href="MuGenHackingToTheGate.html#2862" class="Module">InductiveConat</a> <a id="2877" class="Keyword">where</a>
    <a id="2887" class="Keyword">record</a> <a id="NextGenerationCoinductiveDataTypes.InductiveConat.Conat&#39;"></a><a id="2894" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a> <a id="2901" class="Symbol">:</a> <a id="2903" href="Cubical.Core.Primitives.html#1008" class="Function">Type₀</a> <a id="2909" class="Keyword">where</a>
      <a id="2921" class="Keyword">inductive</a>
      <a id="2937" class="Keyword">constructor</a> <a id="NextGenerationCoinductiveDataTypes.InductiveConat.nat"></a><a id="2949" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a>
      <a id="2959" class="Keyword">field</a>
        <a id="NextGenerationCoinductiveDataTypes.InductiveConat.Conat&#39;.pred"></a><a id="2973" href="MuGenHackingToTheGate.html#2973" class="Field">pred</a> <a id="2978" class="Symbol">:</a> <a id="2980" href="MuGenHackingToTheGate.html#2727" class="Function">Maybe</a> <a id="2986" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a>
    <a id="2997" class="Keyword">open</a> <a id="3002" href="MuGenHackingToTheGate.html#2894" class="Module">Conat&#39;</a>
</pre>
<p>我们可以做配套的转换器：</p>
<pre class="Agda">    <a id="NextGenerationCoinductiveDataTypes.InductiveConat.toNat&#39;"></a><a id="3040" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3047" class="Symbol">:</a> <a id="3049" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a> <a id="3056" class="Symbol">-&gt;</a> <a id="3059" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
    <a id="3067" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3074" class="Symbol">(</a><a id="3075" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3079" class="Symbol">(</a><a id="3080" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3084" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3088" class="Symbol">))</a> <a id="3091" class="Symbol">=</a> <a id="3093" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a>
    <a id="3099" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3106" class="Symbol">(</a><a id="3107" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3111" class="Symbol">(</a><a id="3112" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3116" href="MuGenHackingToTheGate.html#3116" class="Bound">x</a><a id="3117" class="Symbol">))</a> <a id="3120" class="Symbol">=</a> <a id="3122" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="3124" class="Symbol">(</a><a id="3125" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3132" href="MuGenHackingToTheGate.html#3116" class="Bound">x</a><a id="3133" class="Symbol">)</a>

    <a id="NextGenerationCoinductiveDataTypes.InductiveConat.fromNat&#39;"></a><a id="3140" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3149" class="Symbol">:</a> <a id="3151" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a> <a id="3155" class="Symbol">-&gt;</a> <a id="3158" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a>
    <a id="3169" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3178" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="3180" class="Symbol">=</a> <a id="3182" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3186" class="Symbol">(</a><a id="3187" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3191" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3195" class="Symbol">)</a>
    <a id="3201" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3210" class="Symbol">(</a><a id="3211" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="3213" href="MuGenHackingToTheGate.html#3213" class="Bound">n</a><a id="3214" class="Symbol">)</a> <a id="3216" class="Symbol">=</a> <a id="3218" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3222" class="Symbol">(</a><a id="3223" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3227" class="Symbol">(</a><a id="3228" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3237" href="MuGenHackingToTheGate.html#3213" class="Bound">n</a><a id="3238" class="Symbol">))</a>
</pre>
<p>然后随手写一个函数，比如除以二：</p>
<pre class="Agda">    <a id="3276" class="Comment">-- 除以二</a>
    <a id="NextGenerationCoinductiveDataTypes.InductiveConat._/2"></a><a id="3287" href="MuGenHackingToTheGate.html#3287" class="Function Operator">_/2</a> <a id="3291" class="Symbol">:</a> <a id="3293" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a> <a id="3300" class="Symbol">-&gt;</a> <a id="3303" href="MuGenHackingToTheGate.html#2894" class="Record">Conat&#39;</a>
    <a id="3314" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3318" class="Symbol">(</a><a id="3319" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3323" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3327" class="Symbol">)</a> <a id="3329" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a> <a id="3332" class="Symbol">=</a> <a id="3334" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3338" class="Symbol">(</a><a id="3339" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3343" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3347" class="Symbol">)</a>
    <a id="3353" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3357" class="Symbol">(</a><a id="3358" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3362" class="Symbol">(</a><a id="3363" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3367" class="Symbol">(</a><a id="3368" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3372" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3376" class="Symbol">)))</a> <a id="3380" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a> <a id="3383" class="Symbol">=</a> <a id="3385" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3389" class="Symbol">(</a><a id="3390" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="3394" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="3398" class="Symbol">)</a>
    <a id="3404" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3408" class="Symbol">(</a><a id="3409" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3413" class="Symbol">(</a><a id="3414" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3418" class="Symbol">(</a><a id="3419" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3423" href="MuGenHackingToTheGate.html#3423" class="Bound">x</a><a id="3424" class="Symbol">)))</a> <a id="3428" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a> <a id="3431" class="Symbol">=</a> <a id="3433" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="3437" class="Symbol">(</a><a id="3438" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="3442" class="Symbol">(</a><a id="3443" href="MuGenHackingToTheGate.html#3423" class="Bound">x</a> <a id="3445" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3447" class="Symbol">))</a>
</pre>
<p>然后证明一下这个除以二的正确性：</p>
<pre class="Agda">    <a id="3485" href="MuGenHackingToTheGate.html#3485" class="Function">_</a> <a id="3487" class="Symbol">=</a> <a id="3489" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3493" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3496" class="Symbol">(</a><a id="3497" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3504" class="Symbol">(</a><a id="3505" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3514" class="Number">10</a> <a id="3517" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3519" class="Symbol">)</a> <a id="3521" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3524" class="Number">5</a><a id="3525" class="Symbol">)</a>
    <a id="3531" href="MuGenHackingToTheGate.html#3531" class="Function">_</a> <a id="3533" class="Symbol">=</a> <a id="3535" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3539" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3542" class="Symbol">(</a><a id="3543" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3550" class="Symbol">(</a><a id="3551" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3560" class="Number">11</a> <a id="3563" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3565" class="Symbol">)</a> <a id="3567" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3570" class="Number">5</a><a id="3571" class="Symbol">)</a>
    <a id="3577" href="MuGenHackingToTheGate.html#3577" class="Function">_</a> <a id="3579" class="Symbol">=</a> <a id="3581" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3585" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3588" class="Symbol">(</a><a id="3589" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3596" class="Symbol">(</a><a id="3597" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3606" class="Number">9</a> <a id="3608" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3610" class="Symbol">)</a> <a id="3612" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3615" class="Number">4</a><a id="3616" class="Symbol">)</a>
    <a id="3622" href="MuGenHackingToTheGate.html#3622" class="Function">_</a> <a id="3624" class="Symbol">=</a> <a id="3626" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3630" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3633" class="Symbol">(</a><a id="3634" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3641" class="Symbol">(</a><a id="3642" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3651" class="Number">0</a> <a id="3653" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3655" class="Symbol">)</a> <a id="3657" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3660" class="Number">0</a><a id="3661" class="Symbol">)</a>
    <a id="3667" href="MuGenHackingToTheGate.html#3667" class="Function">_</a> <a id="3669" class="Symbol">=</a> <a id="3671" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3675" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3678" class="Symbol">(</a><a id="3679" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3686" class="Symbol">(</a><a id="3687" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3696" class="Number">1</a> <a id="3698" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3700" class="Symbol">)</a> <a id="3702" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3705" class="Number">0</a><a id="3706" class="Symbol">)</a>
    <a id="3712" href="MuGenHackingToTheGate.html#3712" class="Function">_</a> <a id="3714" class="Symbol">=</a> <a id="3716" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3720" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3723" class="Symbol">(</a><a id="3724" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3731" class="Symbol">(</a><a id="3732" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3741" class="Number">2</a> <a id="3743" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3745" class="Symbol">)</a> <a id="3747" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3750" class="Number">1</a><a id="3751" class="Symbol">)</a>
    <a id="3757" href="MuGenHackingToTheGate.html#3757" class="Function">_</a> <a id="3759" class="Symbol">=</a> <a id="3761" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="3765" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3768" class="Symbol">(</a><a id="3769" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3776" class="Symbol">(</a><a id="3777" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3786" class="Number">3</a> <a id="3788" href="MuGenHackingToTheGate.html#3287" class="Function Operator">/2</a><a id="3790" class="Symbol">)</a> <a id="3792" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3795" class="Number">1</a><a id="3796" class="Symbol">)</a>
</pre>
<p>哦，顺便证明一下这个 <code>fromNat'</code> 和 <code>toNat'</code> 的正确性吧：</p>
<pre class="Agda">    <a id="NextGenerationCoinductiveDataTypes.InductiveConat.proofNat&#39;"></a><a id="3856" href="MuGenHackingToTheGate.html#3856" class="Function">proofNat&#39;</a> <a id="3866" class="Symbol">:</a> <a id="3868" class="Symbol">forall</a> <a id="3875" href="MuGenHackingToTheGate.html#3875" class="Bound">n</a> <a id="3877" class="Symbol">-&gt;</a> <a id="3880" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="3887" class="Symbol">(</a><a id="3888" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="3897" href="MuGenHackingToTheGate.html#3875" class="Bound">n</a><a id="3898" class="Symbol">)</a> <a id="3900" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="3903" href="MuGenHackingToTheGate.html#3875" class="Bound">n</a>
    <a id="3909" href="MuGenHackingToTheGate.html#3856" class="Function">proofNat&#39;</a> <a id="3919" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="3921" class="Symbol">=</a> <a id="3923" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a>
    <a id="3931" href="MuGenHackingToTheGate.html#3856" class="Function">proofNat&#39;</a> <a id="3941" class="Symbol">(</a><a id="3942" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="3944" href="MuGenHackingToTheGate.html#3944" class="Bound">n</a><a id="3945" class="Symbol">)</a> <a id="3947" class="Symbol">=</a> <a id="3949" href="HoTT-Agda.html#1880" class="Function">ap</a> <a id="3952" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="3954" class="Symbol">(</a><a id="3955" href="MuGenHackingToTheGate.html#3856" class="Function">proofNat&#39;</a> <a id="3965" href="MuGenHackingToTheGate.html#3944" class="Bound">n</a><a id="3966" class="Symbol">)</a>

    <a id="NextGenerationCoinductiveDataTypes.InductiveConat.proofNat&#39;&#39;"></a><a id="3973" href="MuGenHackingToTheGate.html#3973" class="Function">proofNat&#39;&#39;</a> <a id="3984" class="Symbol">:</a> <a id="3986" class="Symbol">forall</a> <a id="3993" href="MuGenHackingToTheGate.html#3993" class="Bound">n</a> <a id="3995" class="Symbol">-&gt;</a> <a id="3998" href="MuGenHackingToTheGate.html#3140" class="Function">fromNat&#39;</a> <a id="4007" class="Symbol">(</a><a id="4008" href="MuGenHackingToTheGate.html#3040" class="Function">toNat&#39;</a> <a id="4015" href="MuGenHackingToTheGate.html#3993" class="Bound">n</a><a id="4016" class="Symbol">)</a> <a id="4018" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="4021" href="MuGenHackingToTheGate.html#3993" class="Bound">n</a>
    <a id="4027" href="MuGenHackingToTheGate.html#3973" class="Function">proofNat&#39;&#39;</a> <a id="4038" class="Symbol">(</a><a id="4039" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="4043" class="Symbol">(</a><a id="4044" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="4048" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="4052" class="Symbol">))</a> <a id="4055" class="Symbol">=</a> <a id="4057" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a>
    <a id="4065" href="MuGenHackingToTheGate.html#3973" class="Function">proofNat&#39;&#39;</a> <a id="4076" class="Symbol">(</a><a id="4077" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="4081" class="Symbol">(</a><a id="4082" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="4086" href="MuGenHackingToTheGate.html#4086" class="Bound">x</a><a id="4087" class="Symbol">))</a> <a id="4090" class="Symbol">=</a> <a id="4092" href="HoTT-Agda.html#1880" class="Function">ap</a> <a id="4095" class="Symbol">(</a><a id="4096" href="MuGenHackingToTheGate.html#2949" class="InductiveConstructor">nat</a> <a id="4100" href="HoTT-Agda.html#1579" class="Function Operator">∘</a> <a id="4102" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a><a id="4105" class="Symbol">)</a> <a id="4107" class="Symbol">(</a><a id="4108" href="MuGenHackingToTheGate.html#3973" class="Function">proofNat&#39;&#39;</a> <a id="4119" href="MuGenHackingToTheGate.html#4086" class="Bound">x</a><a id="4120" class="Symbol">)</a>
</pre>
<!---
哦，再顺便玩玩 Univalence Axiom 吧，这可是难得的证明了一下同构关系啊：

<pre class="Agda"><a id="4187" class="Comment">{-
    open import Cubical.Foundations.Isomorphism using (Iso; iso)
    postulate isoToPath : ∀ {ℓ} {A B : Type ℓ} → (Iso A B) → A == B
    conat-is-nat : Conat&#39; == Nat
    conat-is-nat = isoToPath $
      iso toNat&#39; fromNat&#39; proofNat&#39; proofNat&#39;&#39;
-}</a>
</pre>
停止玩耍！回到正题。
--->
<p>逆归纳的 <code>Conat</code> 就是把 <code>inductive</code> 修饰符换成 <code>coinductive</code>。 定义这个数据结构：</p>
<pre class="Agda">  <a id="4530" class="Keyword">record</a> <a id="NextGenerationCoinductiveDataTypes.Conat"></a><a id="4537" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a> <a id="4543" class="Symbol">:</a> <a id="4545" href="Cubical.Core.Primitives.html#1008" class="Function">Type₀</a> <a id="4551" class="Keyword">where</a>
    <a id="4561" class="Keyword">coinductive</a>
    <a id="4577" class="Keyword">constructor</a> <a id="NextGenerationCoinductiveDataTypes.nat"></a><a id="4589" href="MuGenHackingToTheGate.html#4589" class="CoinductiveConstructor">nat</a>
    <a id="4597" class="Keyword">field</a>
      <a id="NextGenerationCoinductiveDataTypes.Conat.pred"></a><a id="4609" href="MuGenHackingToTheGate.html#4609" class="Field">pred</a> <a id="4614" class="Symbol">:</a> <a id="4616" href="MuGenHackingToTheGate.html#2727" class="Function">Maybe</a> <a id="4622" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a>
  <a id="4630" class="Keyword">open</a> <a id="4635" href="MuGenHackingToTheGate.html#4537" class="Module">Conat</a>
</pre>
<p>随手定义一个转换函数：</p>
<pre class="Agda">  <a id="NextGenerationCoinductiveDataTypes.fromNat"></a><a id="4669" href="MuGenHackingToTheGate.html#4669" class="Function">fromNat</a> <a id="4677" class="Symbol">:</a> <a id="4679" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a> <a id="4683" class="Symbol">-&gt;</a> <a id="4686" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a>
  <a id="4694" href="MuGenHackingToTheGate.html#4669" class="Function">fromNat</a> <a id="4702" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="4704" class="Symbol">=</a> <a id="4706" href="MuGenHackingToTheGate.html#4589" class="CoinductiveConstructor">nat</a> <a id="4710" class="Symbol">(</a><a id="4711" href="Cubical.Data.Sum.Base.html#228" class="InductiveConstructor">inl</a> <a id="4715" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a><a id="4719" class="Symbol">)</a>
  <a id="4723" href="MuGenHackingToTheGate.html#4669" class="Function">fromNat</a> <a id="4731" class="Symbol">(</a><a id="4732" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="4734" href="MuGenHackingToTheGate.html#4734" class="Bound">n</a><a id="4735" class="Symbol">)</a> <a id="4737" class="Symbol">=</a> <a id="4739" href="MuGenHackingToTheGate.html#4589" class="CoinductiveConstructor">nat</a> <a id="4743" class="Symbol">(</a><a id="4744" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="4748" class="Symbol">(</a><a id="4749" href="MuGenHackingToTheGate.html#4669" class="Function">fromNat</a> <a id="4757" href="MuGenHackingToTheGate.html#4734" class="Bound">n</a><a id="4758" class="Symbol">))</a>

  <a id="4764" class="Comment">-- toNat 暂时定义不了</a>
</pre>
<p>很常规，无非就是把 <code>Nat</code> 从 GADT 形式的 union 变成基于 <code>Maybe</code> 的 union 了， 这有什么厉害的？</p>
<p>之前那个无限大定义，不还是得带上 <code>NON_TERMINATING</code> 才能过？</p>
<pre class="Agda">  <a id="4903" class="Symbol">{-#</a> <a id="4907" class="Keyword">NON_TERMINATING</a> <a id="4923" class="Symbol">#-}</a>
  <a id="NextGenerationCoinductiveDataTypes.mugen-bad"></a><a id="4929" href="MuGenHackingToTheGate.html#4929" class="Function">mugen-bad</a> <a id="4939" class="Symbol">:</a> <a id="4941" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a>
  <a id="4949" href="MuGenHackingToTheGate.html#4929" class="Function">mugen-bad</a> <a id="4959" class="Symbol">=</a> <a id="4961" href="MuGenHackingToTheGate.html#4589" class="CoinductiveConstructor">nat</a> <a id="4965" class="Symbol">(</a><a id="4966" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="4970" href="MuGenHackingToTheGate.html#4929" class="Function">mugen-bad</a><a id="4979" class="Symbol">)</a>
</pre>
<p>这个 <code>mugen-bad</code> 可以通过 <code>pred</code> 函数解构出里面的 <code>Maybe Conat</code>， 然后无限解构，因为它是无穷大嘛。</p>
<p>有穷的数据的话，用 <code>nat (inl unit)</code> 表示 0 ， <code>nat ∘ pred</code> 表示后继操作就好了。 这也是 <code>fromNat</code> 的根据：</p>
<pre class="Agda">  <a id="5143" href="MuGenHackingToTheGate.html#5143" class="Function">_</a> <a id="5145" class="Symbol">=</a> <a id="5147" href="MuGenHackingToTheGate.html#4669" class="Function">fromNat</a> <a id="5155" class="Number">233</a> <a id="5159" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="5162" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a>
</pre>
<p>我们这个 <code>Conat</code> 用了 <code>coinductive</code> 修饰符，因此不能被模式匹配。 为什么我们需要禁止模式匹配逆归纳数据结构呢？</p>
<p>我们仔细思考一下逆归纳数据结构的本质。 普通的归纳数据结构，我们对它的使用方法是：</p>
<ul>
<li>写代码，构造出这个数据结构（<strong>如何构造，这是我们关心的重点</strong>）</li>
<li>写代码，使用这个构造出来的数据结构</li>
</ul>
<p>对逆归纳数据结构，我们在 Haskell 中对它的使用方法是：</p>
<ul>
<li>写代码，构造出这个数据结构，由于惰性求值，我们可以构造无限的数据结构</li>
<li>写代码，对它无限的东西进行有限地解构并使用（<strong>如何解构，这是我们关心的重点</strong>）</li>
</ul>
<p>构造对应解构，归纳对应逆归纳（Inductive 和 Coinductive），妙不可言。</p>
<p>而正是因为 Haskell 依赖了运行时的惰性求值，才可以放心地构造无限的数据结构。 而正是因为 Haskell 让我们<strong>构造</strong>本应该<strong>只关心如何解构</strong>的数据结构，逆归纳数据结构才对初学者那么不直观。</p>
<p>我们，不如直接定义数据结构的解构方式？</p>
<p>我们调用 <code>mugen</code> 的时候，可以这样描述调用过程：</p>
<ul>
<li>通过 <code>pred mugen</code> 解构 <code>mugen</code></li>
<li>返回的还是一个 <code>mugen</code></li>
</ul>
<p>那么我们直接用这个解构的过程来描述这个 <code>mugen</code> 函数好了!</p>
<pre class="Agda">  <a id="NextGenerationCoinductiveDataTypes.mugen"></a><a id="5754" href="MuGenHackingToTheGate.html#5754" class="Function">mugen</a> <a id="5760" class="Symbol">:</a> <a id="5762" href="MuGenHackingToTheGate.html#4537" class="Record">Conat</a>
  <a id="5770" href="MuGenHackingToTheGate.html#4609" class="Field">pred</a> <a id="5775" href="MuGenHackingToTheGate.html#5754" class="Function">mugen</a> <a id="5781" class="Symbol">=</a> <a id="5783" href="Cubical.Data.Sum.Base.html#246" class="InductiveConstructor">inr</a> <a id="5787" href="MuGenHackingToTheGate.html#5754" class="Function">mugen</a>
</pre>
<p>我们就直接使用这种方式定义数据的解构规则，就不要模式匹配了！</p>
<p>这种语法，叫<strong>逆模式匹配</strong>（Copattern Matching），Idris 没有这个功能。要在 Idris 里使用无限的数据结构，请关掉停机检查（滑稽）。</p>
<p>当然，我们还是可以使用解构器（比如 <code>pred</code>）的。 这也是为什么我们使用『记录』来定义逆归纳数据结构，因为逆模式匹配只能针对一组解构器，不能多组。</p>
<p>这样，我们定义了『解构这个 <code>mugen</code> 的规则』。我们可以对 <code>mugen</code> 进行有限的解构， 然后编译器就可以很轻送地判断我们的函数是否停机了！</p>
<p>不过，自然数只是一个很平凡的例子。</p>
<h2 id="逆归纳列表">逆归纳列表</h2>
<p>还记得 Haskell 里的逆归纳列表——流（Stream）吗？</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> a <span class="op">:&gt;:</span> <span class="dt">Stream</span> a</span></code></pre></div>
<p>我们可以构建无限的列表：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">ones ::</span> <span class="dt">Stream</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>ones <span class="ot">=</span> <span class="dv">1</span> <span class="op">:&gt;:</span> ones</span></code></pre></div>
<p>我们可以实现 <code>zipWith</code>、<code>head</code>、<code>tail</code>、<code>take</code>：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> <span class="dt">Stream</span> c</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="fu">zipWith</span> f (a <span class="op">:&gt;:</span> as) (b <span class="op">:&gt;:</span> bs) <span class="ot">=</span> f a b <span class="op">:&gt;:</span> <span class="fu">zipWith</span> f as bs</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="fu">head</span><span class="ot"> ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="fu">head</span> (a <span class="op">:&gt;:</span> _) <span class="ot">=</span> a</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="fu">tail</span> (_ <span class="op">:&gt;:</span> as) <span class="ot">=</span> as</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="fu">take</span> <span class="dv">0</span> _ <span class="ot">=</span> []</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="fu">take</span> n (a <span class="op">:&gt;:</span> as) <span class="ot">=</span> a <span class="op">:</span> <span class="fu">take</span> (n<span class="op">-</span><span class="dv">1</span>) as</span></code></pre></div>
<p>我们可以对无限的列表进行有限地解构：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">5</span> ones</span>
<span id="cb9-2"><a href="#cb9-2"></a>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span></code></pre></div>
<p>我们可以实现 <code>fib</code>：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>fib <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fib (<span class="fu">tail</span> fib)</span></code></pre></div>
<p>是不是呀？</p>
<p>但是，很明显，<code>ones</code>、<code>zipWith</code>、<code>fib</code> 都是不停机的！我们可以试着使用 Agda 的逆模式匹配来看看能不能构造出无限的数据然后有限地解构。</p>
<h3 id="普通的逆归纳列表">普通的逆归纳列表</h3>
<pre class="Agda">  <a id="6849" class="Keyword">module</a> <a id="SimpleCoinductiveList"></a><a id="6856" href="MuGenHackingToTheGate.html#6856" class="Module">SimpleCoinductiveList</a> <a id="6878" class="Keyword">where</a>
</pre>
<p>先定义一个记录：</p>
<pre class="Agda">    <a id="6911" class="Keyword">record</a> <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.Colist"></a><a id="6918" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="6925" class="Symbol">{</a><a id="6926" href="MuGenHackingToTheGate.html#6926" class="Bound">i</a><a id="6927" class="Symbol">}</a> <a id="6929" class="Symbol">(</a><a id="6930" href="MuGenHackingToTheGate.html#6930" class="Bound">A</a> <a id="6932" class="Symbol">:</a> <a id="6934" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="6939" href="MuGenHackingToTheGate.html#6926" class="Bound">i</a><a id="6940" class="Symbol">)</a> <a id="6942" class="Symbol">:</a> <a id="6944" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="6949" href="MuGenHackingToTheGate.html#6926" class="Bound">i</a> <a id="6951" class="Keyword">where</a>
      <a id="6963" class="Keyword">coinductive</a>
      <a id="6981" class="Keyword">constructor</a> <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList._:&gt;:_"></a><a id="6993" href="MuGenHackingToTheGate.html#6993" class="CoinductiveConstructor Operator">_:&gt;:_</a>
      <a id="7005" class="Keyword">field</a>
        <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.Colist.cohead"></a><a id="7019" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="7026" class="Symbol">:</a> <a id="7028" href="MuGenHackingToTheGate.html#6930" class="Bound">A</a>
        <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.Colist.cotail"></a><a id="7038" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="7045" class="Symbol">:</a> <a id="7047" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="7054" href="MuGenHackingToTheGate.html#6930" class="Bound">A</a>
    <a id="7060" class="Keyword">open</a> <a id="7065" href="MuGenHackingToTheGate.html#6918" class="Module">Colist</a>
</pre>
<p>我们先试试那个 <code>ones</code>，使用逆模式匹配：</p>
<pre class="Agda">    <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.ones"></a><a id="7114" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7119" class="Symbol">:</a> <a id="7121" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="7128" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
    <a id="7136" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="7143" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7148" class="Symbol">=</a> <a id="7150" class="Number">1</a>
    <a id="7156" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="7163" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7168" class="Symbol">=</a> <a id="7170" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a>
</pre>
<p>因为这里有两个解构器，所以逆模式匹配也需要匹配两次。</p>
<p>显而易见地，对 <code>ones</code> 调用 <code>cohead</code> 会得到 1，调用 <code>cotail</code> 会返回一个无限的列表，里面还是都是 1。 逆模式匹配把这个过程非常直观地描述了！</p>
<p>实现 <code>cotake</code>：</p>
<pre class="Agda">    <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.cotake"></a><a id="7321" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7328" class="Symbol">:</a> <a id="7330" class="Symbol">{</a><a id="7331" href="MuGenHackingToTheGate.html#7331" class="Bound">A</a> <a id="7333" class="Symbol">:</a> <a id="7335" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7340" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a><a id="7341" class="Symbol">}</a> <a id="7343" class="Symbol">-&gt;</a> <a id="7346" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a> <a id="7350" class="Symbol">-&gt;</a> <a id="7353" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="7360" href="MuGenHackingToTheGate.html#7331" class="Bound">A</a> <a id="7362" class="Symbol">-&gt;</a> <a id="7365" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="7370" href="MuGenHackingToTheGate.html#7331" class="Bound">A</a>
    <a id="7376" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7383" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="7385" href="MuGenHackingToTheGate.html#7385" class="Bound">as</a> <a id="7388" class="Symbol">=</a> <a id="7390" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
    <a id="7398" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7405" class="Symbol">(</a><a id="7406" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="7408" href="MuGenHackingToTheGate.html#7408" class="Bound">n</a><a id="7409" class="Symbol">)</a> <a id="7411" href="MuGenHackingToTheGate.html#7411" class="Bound">as</a> <a id="7414" class="Symbol">=</a> <a id="7416" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="7423" href="MuGenHackingToTheGate.html#7411" class="Bound">as</a> <a id="7426" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7429" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7436" href="MuGenHackingToTheGate.html#7408" class="Bound">n</a> <a id="7438" class="Symbol">(</a><a id="7439" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="7446" href="MuGenHackingToTheGate.html#7411" class="Bound">as</a><a id="7448" class="Symbol">)</a>
</pre>
<p>试试调用：</p>
<pre class="Agda">    <a id="7474" href="MuGenHackingToTheGate.html#7474" class="Function">_</a> <a id="7476" class="Symbol">=</a> <a id="7478" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7482" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7485" class="Symbol">(</a><a id="7486" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7493" class="Number">1</a> <a id="7495" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7500" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7503" class="Number">1</a> <a id="7505" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7508" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7511" class="Symbol">)</a>
    <a id="7517" href="MuGenHackingToTheGate.html#7517" class="Function">_</a> <a id="7519" class="Symbol">=</a> <a id="7521" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7525" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7528" class="Symbol">(</a><a id="7529" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7536" class="Number">2</a> <a id="7538" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7543" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7546" class="Number">1</a> <a id="7548" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7551" class="Number">1</a> <a id="7553" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7556" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7559" class="Symbol">)</a>
    <a id="7565" href="MuGenHackingToTheGate.html#7565" class="Function">_</a> <a id="7567" class="Symbol">=</a> <a id="7569" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7573" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7576" class="Symbol">(</a><a id="7577" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7584" class="Number">3</a> <a id="7586" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7591" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7594" class="Number">1</a> <a id="7596" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7599" class="Number">1</a> <a id="7601" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7604" class="Number">1</a> <a id="7606" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7609" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7612" class="Symbol">)</a>
    <a id="7618" href="MuGenHackingToTheGate.html#7618" class="Function">_</a> <a id="7620" class="Symbol">=</a> <a id="7622" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7626" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7629" class="Symbol">(</a><a id="7630" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7637" class="Number">4</a> <a id="7639" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7644" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7647" class="Number">1</a> <a id="7649" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7652" class="Number">1</a> <a id="7654" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7657" class="Number">1</a> <a id="7659" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7662" class="Number">1</a> <a id="7664" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7667" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7670" class="Symbol">)</a>
    <a id="7676" href="MuGenHackingToTheGate.html#7676" class="Function">_</a> <a id="7678" class="Symbol">=</a> <a id="7680" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7684" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7687" class="Symbol">(</a><a id="7688" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7695" class="Number">5</a> <a id="7697" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7702" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7705" class="Number">1</a> <a id="7707" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7710" class="Number">1</a> <a id="7712" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7715" class="Number">1</a> <a id="7717" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7720" class="Number">1</a> <a id="7722" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7725" class="Number">1</a> <a id="7727" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7730" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7733" class="Symbol">)</a>
    <a id="7739" href="MuGenHackingToTheGate.html#7739" class="Function">_</a> <a id="7741" class="Symbol">=</a> <a id="7743" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7747" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7750" class="Symbol">(</a><a id="7751" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7758" class="Number">6</a> <a id="7760" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7765" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7768" class="Number">1</a> <a id="7770" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7773" class="Number">1</a> <a id="7775" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7778" class="Number">1</a> <a id="7780" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7783" class="Number">1</a> <a id="7785" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7788" class="Number">1</a> <a id="7790" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7793" class="Number">1</a> <a id="7795" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7798" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7801" class="Symbol">)</a>
    <a id="7807" href="MuGenHackingToTheGate.html#7807" class="Function">_</a> <a id="7809" class="Symbol">=</a> <a id="7811" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="7815" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="7818" class="Symbol">(</a><a id="7819" href="MuGenHackingToTheGate.html#7321" class="Function">cotake</a> <a id="7826" class="Number">7</a> <a id="7828" href="MuGenHackingToTheGate.html#7114" class="Function">ones</a> <a id="7833" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="7836" class="Number">1</a> <a id="7838" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7841" class="Number">1</a> <a id="7843" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7846" class="Number">1</a> <a id="7848" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7851" class="Number">1</a> <a id="7853" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7856" class="Number">1</a> <a id="7858" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7861" class="Number">1</a> <a id="7863" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7866" class="Number">1</a> <a id="7868" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="7871" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="7874" class="Symbol">)</a>
</pre>
<p>对头！我们这个函数是停机的！对无限的数据进行有限地使用，被编译器认可了！</p>
<p>蛤蛤蛤。</p>
<p>那么，我们试试实现个 <code>zipWith</code> ？</p>
<pre class="Agda">    <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.cozipWith"></a><a id="7961" href="MuGenHackingToTheGate.html#7961" class="Function">cozipWith</a> <a id="7971" class="Symbol">:</a> <a id="7973" class="Symbol">{</a><a id="7974" href="MuGenHackingToTheGate.html#7974" class="Bound">A</a> <a id="7976" href="MuGenHackingToTheGate.html#7976" class="Bound">B</a> <a id="7978" href="MuGenHackingToTheGate.html#7978" class="Bound">C</a> <a id="7980" class="Symbol">:</a> <a id="7982" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7987" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a><a id="7988" class="Symbol">}</a> <a id="7990" class="Symbol">-&gt;</a> <a id="7993" class="Symbol">(</a><a id="7994" href="MuGenHackingToTheGate.html#7974" class="Bound">A</a> <a id="7996" class="Symbol">-&gt;</a> <a id="7999" href="MuGenHackingToTheGate.html#7976" class="Bound">B</a> <a id="8001" class="Symbol">-&gt;</a> <a id="8004" href="MuGenHackingToTheGate.html#7978" class="Bound">C</a><a id="8005" class="Symbol">)</a>
              <a id="8021" class="Symbol">-&gt;</a> <a id="8024" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="8031" href="MuGenHackingToTheGate.html#7974" class="Bound">A</a> <a id="8033" class="Symbol">-&gt;</a> <a id="8036" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="8043" href="MuGenHackingToTheGate.html#7976" class="Bound">B</a> <a id="8045" class="Symbol">-&gt;</a> <a id="8048" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="8055" href="MuGenHackingToTheGate.html#7978" class="Bound">C</a>
    <a id="8061" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="8068" class="Symbol">(</a><a id="8069" href="MuGenHackingToTheGate.html#7961" class="Function">cozipWith</a> <a id="8079" href="MuGenHackingToTheGate.html#8079" class="Bound">f</a> <a id="8081" href="MuGenHackingToTheGate.html#8081" class="Bound">a</a> <a id="8083" href="MuGenHackingToTheGate.html#8083" class="Bound">b</a><a id="8084" class="Symbol">)</a> <a id="8086" class="Symbol">=</a> <a id="8088" href="MuGenHackingToTheGate.html#8079" class="Bound">f</a> <a id="8090" class="Symbol">(</a><a id="8091" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="8098" href="MuGenHackingToTheGate.html#8081" class="Bound">a</a><a id="8099" class="Symbol">)</a> <a id="8101" class="Symbol">(</a><a id="8102" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="8109" href="MuGenHackingToTheGate.html#8083" class="Bound">b</a><a id="8110" class="Symbol">)</a>
    <a id="8116" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8123" class="Symbol">(</a><a id="8124" href="MuGenHackingToTheGate.html#7961" class="Function">cozipWith</a> <a id="8134" href="MuGenHackingToTheGate.html#8134" class="Bound">f</a> <a id="8136" href="MuGenHackingToTheGate.html#8136" class="Bound">a</a> <a id="8138" href="MuGenHackingToTheGate.html#8138" class="Bound">b</a><a id="8139" class="Symbol">)</a> <a id="8141" class="Symbol">=</a> <a id="8143" href="MuGenHackingToTheGate.html#7961" class="Function">cozipWith</a> <a id="8153" href="MuGenHackingToTheGate.html#8134" class="Bound">f</a> <a id="8155" class="Symbol">(</a><a id="8156" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8163" href="MuGenHackingToTheGate.html#8136" class="Bound">a</a><a id="8164" class="Symbol">)</a> <a id="8166" class="Symbol">(</a><a id="8167" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8174" href="MuGenHackingToTheGate.html#8138" class="Bound">b</a><a id="8175" class="Symbol">)</a>
</pre>
<p>看着感觉问题不大……用它写个 <code>fib</code> 试试（逆模式是可以嵌套的）？</p>
<pre class="Agda">    <a id="8231" class="Symbol">{-#</a> <a id="8235" class="Keyword">TERMINATING</a> <a id="8247" class="Symbol">#-}</a>
    <a id="NextGenerationCoinductiveDataTypes.SimpleCoinductiveList.cofib"></a><a id="8255" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a> <a id="8261" class="Symbol">:</a> <a id="8263" href="MuGenHackingToTheGate.html#6918" class="Record">Colist</a> <a id="8270" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
    <a id="8278" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="8285" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a> <a id="8291" class="Symbol">=</a> <a id="8293" class="Number">0</a>
    <a id="8299" href="MuGenHackingToTheGate.html#7019" class="Field">cohead</a> <a id="8306" class="Symbol">(</a><a id="8307" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8314" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a><a id="8319" class="Symbol">)</a> <a id="8321" class="Symbol">=</a> <a id="8323" class="Number">1</a>
    <a id="8329" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8336" class="Symbol">(</a><a id="8337" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8344" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a><a id="8349" class="Symbol">)</a> <a id="8351" class="Symbol">=</a> <a id="8353" href="MuGenHackingToTheGate.html#7961" class="Function">cozipWith</a> <a id="8363" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a> <a id="8367" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a> <a id="8373" class="Symbol">(</a><a id="8374" href="MuGenHackingToTheGate.html#7038" class="Field">cotail</a> <a id="8381" href="MuGenHackingToTheGate.html#8255" class="Function">cofib</a><a id="8386" class="Symbol">)</a>
</pre>
<p>Ayayayayaya! 我们遇到了停机问题！ 编译器不知道 <code>cozipWith</code> 返回的 <code>Colist</code> 和传入的 <code>Colist</code> 的关系 （函数范围内的停机信息不会保留，这也是开头说的停机性判定迷的地方）， 导致了报错！</p>
<pre class="text"><code>Termination checking failed for the following functions:
  cofib
Problematic calls:
  cofib</code></pre>
<p>我们如何让编译器明确地知道， <code>cozipWith</code> 返回的 <code>Colist</code> 和参数 <code>Colist</code> 一样长呢？</p>
<p>我们需要一个工具来保留这个逆归纳时的长度信息。</p>
<h3 id="无限大的大小">无限大的大小</h3>
<p>这就是我写这篇文章的初衷了，因为某沙想看（捂脸）。</p>
<p>引入一个包（不要点进去看，命名瞎眼）：</p>
<pre class="Agda"><a id="8768" class="Keyword">open</a> <a id="8773" class="Keyword">import</a> <a id="8780" href="Agda.Builtin.Size.html" class="Module">Agda.Builtin.Size</a>
</pre>
<p>我们可以使用 <code>Size</code> 来保存逆归纳的数据的大小关系。 <code>Size</code> 具有以下特征：</p>
<ul>
<li>不能被模式匹配</li>
<li>它的类型是 <code>Size</code>，这个类型独立于 <code>Set</code> 的类型体系
<ul>
<li>考虑到 Girard Paradox，我们给定 <code>Size</code> 本身的类型是 <code>SizeU</code></li>
<li><code>SizeU</code> 也独立于 <code>Set</code> 的类型体系</li>
<li><code>SizeU</code> 需要 <code>--type-in-type</code> 这个 pragma</li>
</ul></li>
<li>它的构造类似自然数，不过一般的用法不一样</li>
</ul>
<p>一般的用法是：</p>
<ul>
<li><strong>函数</strong>拿一个隐式参数 <code>s</code>，类型是 <code>Size</code></li>
<li>我们可以把这个 <code>s</code> 填进其他参数的类型参数里</li>
<li>返回值如果和参数大小相同
<ul>
<li>就给他们配上同一个 <code>s</code></li>
<li>否则可以使用 <code>Size&lt;</code>、<code>↑</code> 等函数创造新的 <code>Size</code> 并描述和 <code>s</code> 的关系</li>
</ul></li>
<li><code>Size</code> 的默认值是无限大</li>
</ul>
<p>我们先给 <code>Colist</code> 加上 <code>Size</code>：</p>
<pre class="Agda"><a id="9243" class="Keyword">record</a> <a id="Colist"></a><a id="9250" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="9257" class="Symbol">{</a><a id="9258" href="MuGenHackingToTheGate.html#9258" class="Bound">i</a><a id="9259" class="Symbol">}</a> <a id="9261" class="Symbol">(</a><a id="9262" href="MuGenHackingToTheGate.html#9262" class="Bound">s</a> <a id="9264" class="Symbol">:</a> <a id="9266" href="Agda.Builtin.Size.html#179" class="Postulate">Size</a><a id="9270" class="Symbol">)</a> <a id="9272" class="Symbol">(</a><a id="9273" href="MuGenHackingToTheGate.html#9273" class="Bound">A</a> <a id="9275" class="Symbol">:</a> <a id="9277" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="9282" href="MuGenHackingToTheGate.html#9258" class="Bound">i</a><a id="9283" class="Symbol">)</a> <a id="9285" class="Symbol">:</a> <a id="9287" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="9292" href="MuGenHackingToTheGate.html#9258" class="Bound">i</a> <a id="9294" class="Keyword">where</a>
  <a id="9302" class="Keyword">coinductive</a>
  <a id="9316" class="Keyword">constructor</a> <a id="_:&gt;:_"></a><a id="9328" href="MuGenHackingToTheGate.html#9328" class="CoinductiveConstructor Operator">_:&gt;:_</a>
</pre>
<p>然后，<code>cohead</code> 常规：</p>
<pre class="Agda">  <a id="9366" class="Keyword">field</a>
    <a id="Colist.cohead"></a><a id="9376" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="9383" class="Symbol">:</a> <a id="9385" href="MuGenHackingToTheGate.html#9273" class="Bound">A</a>
</pre>
<p>但是 <code>cotail</code> 就不一样了——我们需要弄一个隐式参数，它的类型是『一个小于 <code>s</code> 的 <code>Size</code>』， 但值是多少就让 Agda 自己推：</p>
<pre class="Agda">    <a id="Colist.cotail"></a><a id="9480" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="9487" class="Symbol">:</a> <a id="9489" class="Symbol">{</a><a id="9490" href="MuGenHackingToTheGate.html#9490" class="Bound">ss</a> <a id="9493" class="Symbol">:</a> <a id="9495" href="Agda.Builtin.Size.html#211" class="Postulate Operator">Size&lt;</a> <a id="9501" href="MuGenHackingToTheGate.html#9262" class="Bound">s</a><a id="9502" class="Symbol">}</a> <a id="9504" class="Symbol">-&gt;</a> <a id="9507" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="9514" href="MuGenHackingToTheGate.html#9490" class="Bound">ss</a> <a id="9517" href="MuGenHackingToTheGate.html#9273" class="Bound">A</a>
</pre>
<p>暴露定义，泛化一个 <code>Size</code>：</p>
<pre class="Agda"><a id="9551" class="Keyword">open</a> <a id="9556" href="MuGenHackingToTheGate.html#9250" class="Module">Colist</a>
<a id="9563" class="Keyword">variable</a> <a id="9572" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="9574" class="Symbol">:</a> <a id="9576" href="Agda.Builtin.Size.html#179" class="Postulate">Size</a>
</pre>
<p><code>ones</code> 的定义将不受影响：</p>
<pre class="Agda"><a id="ones"></a><a id="9612" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="9617" class="Symbol">:</a> <a id="9619" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="9626" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="9628" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
<a id="9632" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="9639" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="9644" class="Symbol">=</a> <a id="9646" class="Number">1</a>
<a id="9648" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="9655" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="9660" class="Symbol">=</a> <a id="9662" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a>
</pre>
<p><code>cotake</code> 由于处理的对象的长度是无所谓的，所以我们不需要使用 <code>Size</code>，就直接使用无限大这个 <code>Size</code>：</p>
<pre class="Agda"><a id="cotake"></a><a id="9742" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9749" class="Symbol">:</a> <a id="9751" class="Symbol">{</a><a id="9752" href="MuGenHackingToTheGate.html#9752" class="Bound">A</a> <a id="9754" class="Symbol">:</a> <a id="9756" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="9761" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a><a id="9762" class="Symbol">}</a> <a id="9764" class="Symbol">-&gt;</a> <a id="9767" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a> <a id="9771" class="Symbol">-&gt;</a> <a id="9774" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="9781" href="Agda.Builtin.Size.html#275" class="Postulate">∞</a> <a id="9783" href="MuGenHackingToTheGate.html#9752" class="Bound">A</a> <a id="9785" class="Symbol">-&gt;</a> <a id="9788" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9793" href="MuGenHackingToTheGate.html#9752" class="Bound">A</a>
<a id="9795" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9802" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="9804" href="MuGenHackingToTheGate.html#9804" class="Bound">as</a> <a id="9807" class="Symbol">=</a> <a id="9809" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
<a id="9813" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9820" class="Symbol">(</a><a id="9821" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">S</a> <a id="9823" href="MuGenHackingToTheGate.html#9823" class="Bound">n</a><a id="9824" class="Symbol">)</a> <a id="9826" href="MuGenHackingToTheGate.html#9826" class="Bound">as</a> <a id="9829" class="Symbol">=</a> <a id="9831" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="9838" href="MuGenHackingToTheGate.html#9826" class="Bound">as</a> <a id="9841" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9844" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9851" href="MuGenHackingToTheGate.html#9823" class="Bound">n</a> <a id="9853" class="Symbol">(</a><a id="9854" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="9861" href="MuGenHackingToTheGate.html#9826" class="Bound">as</a><a id="9863" class="Symbol">)</a>
</pre>
<p>测试：</p>
<pre class="Agda"><a id="9883" href="MuGenHackingToTheGate.html#9883" class="Function">_</a> <a id="9885" class="Symbol">=</a> <a id="9887" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="9891" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="9894" class="Symbol">(</a><a id="9895" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9902" class="Number">1</a> <a id="9904" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="9909" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="9912" class="Number">1</a> <a id="9914" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9917" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="9920" class="Symbol">)</a>
<a id="9922" href="MuGenHackingToTheGate.html#9922" class="Function">_</a> <a id="9924" class="Symbol">=</a> <a id="9926" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="9930" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="9933" class="Symbol">(</a><a id="9934" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9941" class="Number">4</a> <a id="9943" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="9948" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="9951" class="Number">1</a> <a id="9953" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9956" class="Number">1</a> <a id="9958" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9961" class="Number">1</a> <a id="9963" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9966" class="Number">1</a> <a id="9968" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="9971" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="9974" class="Symbol">)</a>
<a id="9976" href="MuGenHackingToTheGate.html#9976" class="Function">_</a> <a id="9978" class="Symbol">=</a> <a id="9980" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="9984" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="9987" class="Symbol">(</a><a id="9988" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="9995" class="Number">7</a> <a id="9997" href="MuGenHackingToTheGate.html#9612" class="Function">ones</a> <a id="10002" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="10005" class="Number">1</a> <a id="10007" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10010" class="Number">1</a> <a id="10012" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10015" class="Number">1</a> <a id="10017" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10020" class="Number">1</a> <a id="10022" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10025" class="Number">1</a> <a id="10027" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10030" class="Number">1</a> <a id="10032" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10035" class="Number">1</a> <a id="10037" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10040" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="10043" class="Symbol">)</a>
</pre>
<p><code>cozipWith</code> 可以使用一个 <code>Size</code> 来保留『返回的 <code>Colist</code> 长度和参数一致』这一细节，通过手动指定他们的 <code>Size</code> 都是同一个变量：</p>
<pre class="Agda"><a id="cozipWith"></a><a id="10141" href="MuGenHackingToTheGate.html#10141" class="Function">cozipWith</a> <a id="10151" class="Symbol">:</a> <a id="10153" class="Symbol">{</a><a id="10154" href="MuGenHackingToTheGate.html#10154" class="Bound">A</a> <a id="10156" href="MuGenHackingToTheGate.html#10156" class="Bound">B</a> <a id="10158" href="MuGenHackingToTheGate.html#10158" class="Bound">C</a> <a id="10160" class="Symbol">:</a> <a id="10162" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="10167" href="MuGenHackingToTheGate.html#477" class="Generalizable">i</a><a id="10168" class="Symbol">}</a> <a id="10170" class="Symbol">-&gt;</a> <a id="10173" class="Symbol">(</a><a id="10174" href="MuGenHackingToTheGate.html#10154" class="Bound">A</a> <a id="10176" class="Symbol">-&gt;</a> <a id="10179" href="MuGenHackingToTheGate.html#10156" class="Bound">B</a> <a id="10181" class="Symbol">-&gt;</a> <a id="10184" href="MuGenHackingToTheGate.html#10158" class="Bound">C</a><a id="10185" class="Symbol">)</a>
          <a id="10197" class="Symbol">-&gt;</a> <a id="10200" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="10207" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="10209" href="MuGenHackingToTheGate.html#10154" class="Bound">A</a> <a id="10211" class="Symbol">-&gt;</a> <a id="10214" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="10221" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="10223" href="MuGenHackingToTheGate.html#10156" class="Bound">B</a> <a id="10225" class="Symbol">-&gt;</a> <a id="10228" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="10235" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="10237" href="MuGenHackingToTheGate.html#10158" class="Bound">C</a>
<a id="10239" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="10246" class="Symbol">(</a><a id="10247" href="MuGenHackingToTheGate.html#10141" class="Function">cozipWith</a> <a id="10257" href="MuGenHackingToTheGate.html#10257" class="Bound">f</a> <a id="10259" href="MuGenHackingToTheGate.html#10259" class="Bound">a</a> <a id="10261" href="MuGenHackingToTheGate.html#10261" class="Bound">b</a><a id="10262" class="Symbol">)</a> <a id="10264" class="Symbol">=</a> <a id="10266" href="MuGenHackingToTheGate.html#10257" class="Bound">f</a> <a id="10268" class="Symbol">(</a><a id="10269" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="10276" href="MuGenHackingToTheGate.html#10259" class="Bound">a</a><a id="10277" class="Symbol">)</a> <a id="10279" class="Symbol">(</a><a id="10280" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="10287" href="MuGenHackingToTheGate.html#10261" class="Bound">b</a><a id="10288" class="Symbol">)</a>
<a id="10290" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10297" class="Symbol">(</a><a id="10298" href="MuGenHackingToTheGate.html#10141" class="Function">cozipWith</a> <a id="10308" href="MuGenHackingToTheGate.html#10308" class="Bound">f</a> <a id="10310" href="MuGenHackingToTheGate.html#10310" class="Bound">a</a> <a id="10312" href="MuGenHackingToTheGate.html#10312" class="Bound">b</a><a id="10313" class="Symbol">)</a> <a id="10315" class="Symbol">=</a> <a id="10317" href="MuGenHackingToTheGate.html#10141" class="Function">cozipWith</a> <a id="10327" href="MuGenHackingToTheGate.html#10308" class="Bound">f</a> <a id="10329" class="Symbol">(</a><a id="10330" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10337" href="MuGenHackingToTheGate.html#10310" class="Bound">a</a><a id="10338" class="Symbol">)</a> <a id="10340" class="Symbol">(</a><a id="10341" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10348" href="MuGenHackingToTheGate.html#10312" class="Bound">b</a><a id="10349" class="Symbol">)</a>
</pre>
<p>于是，<code>cofib</code> 就安全了！</p>
<pre class="Agda"><a id="cofib"></a><a id="10382" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a> <a id="10388" class="Symbol">:</a> <a id="10390" href="MuGenHackingToTheGate.html#9250" class="Record">Colist</a> <a id="10397" href="MuGenHackingToTheGate.html#9572" class="Generalizable">s</a> <a id="10399" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
<a id="10403" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="10410" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a> <a id="10416" class="Symbol">=</a> <a id="10418" class="Number">0</a>
<a id="10420" href="MuGenHackingToTheGate.html#9376" class="Field">cohead</a> <a id="10427" class="Symbol">(</a><a id="10428" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10435" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10440" class="Symbol">)</a> <a id="10442" class="Symbol">=</a> <a id="10444" class="Number">1</a>
<a id="10446" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10453" class="Symbol">(</a><a id="10454" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10461" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10466" class="Symbol">)</a> <a id="10468" class="Symbol">=</a> <a id="10470" href="MuGenHackingToTheGate.html#10141" class="Function">cozipWith</a> <a id="10480" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a> <a id="10484" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a> <a id="10490" class="Symbol">(</a><a id="10491" href="MuGenHackingToTheGate.html#9480" class="Field">cotail</a> <a id="10498" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10503" class="Symbol">)</a>
</pre>
<p>测试！</p>
<pre class="Agda"><a id="10523" href="MuGenHackingToTheGate.html#10523" class="Function">_</a> <a id="10525" class="Symbol">=</a> <a id="10527" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="10531" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="10534" class="Symbol">((</a><a id="10536" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="10543" class="Number">1</a> <a id="10545" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10550" class="Symbol">)</a> <a id="10552" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="10555" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="10557" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10560" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="10563" class="Symbol">)</a>
<a id="10565" href="MuGenHackingToTheGate.html#10565" class="Function">_</a> <a id="10567" class="Symbol">=</a> <a id="10569" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="10573" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="10576" class="Symbol">((</a><a id="10578" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="10585" class="Number">5</a> <a id="10587" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10592" class="Symbol">)</a> <a id="10594" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="10597" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="10599" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10602" class="Number">1</a> <a id="10604" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10607" class="Number">1</a> <a id="10609" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10612" class="Number">2</a> <a id="10614" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10617" class="Number">3</a> <a id="10619" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10622" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="10625" class="Symbol">)</a>
</pre>
<p>试试更大的数据？</p>
<pre class="Agda"><a id="10650" href="MuGenHackingToTheGate.html#10650" class="Function">_</a> <a id="10652" class="Symbol">=</a> <a id="10654" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="10658" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="10661" class="Symbol">((</a><a id="10663" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="10670" class="Number">15</a> <a id="10673" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10678" class="Symbol">)</a> <a id="10680" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="10683" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="10685" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10688" class="Number">1</a> <a id="10690" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10693" class="Number">1</a> <a id="10695" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10698" class="Number">2</a> <a id="10700" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="10711" class="Number">3</a> <a id="10713" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10716" class="Number">5</a> <a id="10718" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10721" class="Number">8</a> <a id="10723" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10726" class="Number">13</a> <a id="10729" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10732" class="Number">21</a> <a id="10735" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10738" class="Number">34</a> <a id="10741" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10744" class="Number">55</a> <a id="10747" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10750" class="Number">89</a> <a id="10753" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="10764" class="Number">144</a> <a id="10768" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10771" class="Number">233</a> <a id="10775" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10778" class="Number">377</a> <a id="10782" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10785" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="10788" class="Symbol">)</a>
</pre>
<p>再大一点就没法自动推导啦，我们得手写，但检查已有的定义也是没有问题的：</p>
<pre class="Agda"><a id="10840" href="MuGenHackingToTheGate.html#10840" class="Function">_</a> <a id="10842" class="Symbol">=</a> <a id="10844" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">idp</a> <a id="10848" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="10851" class="Symbol">((</a><a id="10853" href="MuGenHackingToTheGate.html#9742" class="Function">cotake</a> <a id="10860" class="Number">28</a> <a id="10863" href="MuGenHackingToTheGate.html#10382" class="Function">cofib</a><a id="10868" class="Symbol">)</a> <a id="10870" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">==</a> <a id="10873" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">O</a> <a id="10875" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10878" class="Number">1</a> <a id="10880" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10883" class="Number">1</a> <a id="10885" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10888" class="Number">2</a> <a id="10890" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="10901" class="Number">3</a> <a id="10903" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10906" class="Number">5</a> <a id="10908" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10911" class="Number">8</a> <a id="10913" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10916" class="Number">13</a> <a id="10919" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10922" class="Number">21</a> <a id="10925" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10928" class="Number">34</a> <a id="10931" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10934" class="Number">55</a> <a id="10937" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10940" class="Number">89</a> <a id="10943" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="10954" class="Number">144</a> <a id="10958" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10961" class="Number">233</a> <a id="10965" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10968" class="Number">377</a> <a id="10972" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10975" class="Number">610</a> <a id="10979" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10982" class="Number">987</a> <a id="10986" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10989" class="Number">1597</a> <a id="10994" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="10997" class="Number">2584</a> <a id="11002" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="11013" class="Number">4181</a> <a id="11018" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11021" class="Number">6765</a> <a id="11026" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11029" class="Number">10946</a> <a id="11035" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11038" class="Number">17711</a> <a id="11044" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11047" class="Number">28657</a> <a id="11053" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11056" class="Number">46368</a> <a id="11062" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a>
        <a id="11073" class="Number">75025</a> <a id="11079" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11082" class="Number">121393</a> <a id="11089" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11092" class="Number">196418</a> <a id="11099" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="11102" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a><a id="11105" class="Symbol">)</a>
</pre>
<p>好啦，这差不多就是 Agda 对逆归纳数据结构的（几乎）全部的知识了。 是不是很强大呢？</p>
<p>不过像携带函数作用域的信息并到处传递，还是用 refinement type 爽一点， F⋆ 的这个就很好，它的 <code>Lemma</code> 就是 <code>x:unit{}</code> 的语法糖。 <br/> <br/> 谢谢阅读。</p>
<p>2019/3/8 修正：根据欧林猫的建议把【余归纳】和【余模式】翻译为【逆归纳】和【逆模式】。</p>{% endraw %}</body>
