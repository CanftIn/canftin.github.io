---
layout: page
permalink: /lagda/CopatternIsMoreThanCoinduction.html
inline_latex: true
agda: true
---
<body>
{% raw %}<h2 id="当面组合背面或模式匹配类型类">当面组合背面或，模式匹配类型类</h2>
<p>这篇文章放飞自我，会用一些英文术语了，因为有朋友反应中文看不懂。</p>
<pre class="Agda"><a id="63" class="Symbol">{-#</a> <a id="67" class="Keyword">OPTIONS</a> <a id="75" class="Pragma">--no-unicode</a> <a id="88" class="Symbol">#-}</a>
<a id="92" class="Symbol">{-#</a> <a id="96" class="Keyword">OPTIONS</a> <a id="104" class="Pragma">--without-K</a>  <a id="117" class="Symbol">#-}</a>
<a id="121" class="Symbol">{-#</a> <a id="125" class="Keyword">OPTIONS</a> <a id="133" class="Pragma">--cubical</a>    <a id="146" class="Symbol">#-}</a>
<a id="150" class="Symbol">{-#</a> <a id="154" class="Keyword">OPTIONS</a> <a id="162" class="Pragma">--copattern</a>  <a id="175" class="Symbol">#-}</a>
<a id="179" class="Keyword">module</a> <a id="186" href="CopatternIsMoreThanCoinduction.html" class="Module">CopatternIsMoreThanCoinduction</a> <a id="217" class="Keyword">where</a>

<a id="224" class="Keyword">open</a> <a id="229" class="Keyword">import</a> <a id="236" href="HoTT-Agda.html" class="Module">HoTT-Agda</a>

<a id="247" class="Keyword">variable</a> <a id="256" href="CopatternIsMoreThanCoinduction.html#256" class="Generalizable">a</a> <a id="258" href="CopatternIsMoreThanCoinduction.html#258" class="Generalizable">b</a> <a id="260" class="Symbol">:</a> <a id="262" href="Agda.Primitive.html#408" class="Postulate">Level</a>
<a id="268" class="Keyword">variable</a>
  <a id="279" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a> <a id="281" class="Symbol">:</a> <a id="283" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="288" href="CopatternIsMoreThanCoinduction.html#256" class="Generalizable">a</a>
  <a id="292" href="CopatternIsMoreThanCoinduction.html#292" class="Generalizable">B</a> <a id="294" class="Symbol">:</a> <a id="296" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="301" href="CopatternIsMoreThanCoinduction.html#258" class="Generalizable">b</a>
</pre>
<p>上次心血来潮写了篇文章：</p>
<pre class="Agda"><a id="330" class="Keyword">import</a> <a id="337" href="MuGenHackingToTheGate.html" class="Module">MuGenHackingToTheGate</a> <a id="359" class="Keyword">using</a> <a id="365" class="Symbol">()</a>
</pre>
<p>URL 玩了个命运石之门的梗，然而没有人吐槽我，这另我十分伤熏。 并且，有个 Haskell 微信群的朋友对我进行了这样的反问：</p>
<blockquote>
<p>如果 Haskell 支持全局模式匹配，也就是说 <code>Just bla = Just 233</code> 这样的代码可以通过编译，那是不是可以说 Haskell 也有余模式了？</p>
</blockquote>
<p>我理一下他的意思。实际上他是指：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">bla ::</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">Just</span> bla <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">233</span></span></code></pre></div>
<p>然后可以拿到 <code>bla</code> 的值是 233。</p>
<p>然而这 too simple，他产生这样的误会，很明显是我没说清楚（就是该强调的重点没有强调）。 我整节数学课都在反省自己，最后才理解了他到底是产生了什么误解， 以及怎么跟他解释他这个是错的。</p>
<p>首先，copattern 是通过定义函数的返回值被解构的行为来定义 coinductive 数据结构的语法， 这并不是一个简单的语法糖，因为它具有辅助 termination check 的作用， 前文给出的 <code>ones</code> 和 <code>cofib</code> 就已经非常说明问题了。</p>
<p>我们使用 copattern 定义函数时，函数体是每个 destructor 返回的东西。因此， 即使我们忽略那位读者的两个过于明显的错误（<code>Maybe</code> 有两个 constructor， 因此不能只使用『一组 destructor』定义它；以及用 copattern 定义的函数返回的都是一个 <code>record</code>， 。这个问题要是问得有诚意一点的话，应该使用 <code>Identity</code> 类型。算了，我们还是原谅他吧）， 我们假设他口中的 <code>Maybe</code> 只有 <code>Just</code> 这一个 constructor 和 destructor。</p>
<p>我们也应该这样定义这个函数：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">bla ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">Just</span> bla <span class="ot">=</span> <span class="dv">233</span></span></code></pre></div>
<p>首先，返回类型是应该『被 destruct』的对象—— <code>Maybe</code>，以及函数体是 destruct 后返回的东西——233。 写成 Agda，也是可以的。先定义这个很傻的 <code>Maybe</code>：</p>
<pre class="Agda"><a id="1284" class="Keyword">module</a> <a id="StupidDefinition"></a><a id="1291" href="CopatternIsMoreThanCoinduction.html#1291" class="Module">StupidDefinition</a> <a id="1308" class="Keyword">where</a>
  <a id="1316" class="Keyword">record</a> <a id="StupidDefinition.Maybe"></a><a id="1323" href="CopatternIsMoreThanCoinduction.html#1323" class="Record">Maybe</a> <a id="1329" class="Symbol">{</a><a id="1330" href="CopatternIsMoreThanCoinduction.html#1330" class="Bound">i</a><a id="1331" class="Symbol">}</a> <a id="1333" class="Symbol">(</a><a id="1334" href="CopatternIsMoreThanCoinduction.html#1334" class="Bound">A</a> <a id="1336" class="Symbol">:</a> <a id="1338" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1343" href="CopatternIsMoreThanCoinduction.html#1330" class="Bound">i</a><a id="1344" class="Symbol">)</a> <a id="1346" class="Symbol">:</a> <a id="1348" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1353" href="CopatternIsMoreThanCoinduction.html#1330" class="Bound">i</a> <a id="1355" class="Keyword">where</a>
    <a id="1365" class="Keyword">inductive</a>
    <a id="1379" class="Keyword">field</a> <a id="StupidDefinition.Maybe.Just"></a><a id="1385" href="CopatternIsMoreThanCoinduction.html#1385" class="Field">Just</a> <a id="1390" class="Symbol">:</a> <a id="1392" href="CopatternIsMoreThanCoinduction.html#1334" class="Bound">A</a>
  <a id="1396" class="Keyword">open</a> <a id="1401" href="CopatternIsMoreThanCoinduction.html#1323" class="Module">Maybe</a>
</pre>
<p>然后写出 <code>a</code>：</p>
<pre class="Agda">  <a id="StupidDefinition.bla"></a><a id="1433" href="CopatternIsMoreThanCoinduction.html#1433" class="Function">bla</a> <a id="1437" class="Symbol">:</a> <a id="1439" href="CopatternIsMoreThanCoinduction.html#1323" class="Record">Maybe</a> <a id="1445" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
  <a id="1451" href="CopatternIsMoreThanCoinduction.html#1385" class="Field">Just</a> <a id="1456" href="CopatternIsMoreThanCoinduction.html#1433" class="Function">bla</a> <a id="1460" class="Symbol">=</a> <a id="1462" class="Number">233</a>
</pre>
<p>LGTM!</p>
<h2 id="余模式定义-record">余模式定义 <code>record</code></h2>
<p>Agda 默认 <code>record</code> 构造语法不是一般的丑，因此我们有了 <code>constructor</code> 关键字来自定义构造函数的语法 （注意是自定义语法，不是自定义构造函数的名字，2333）。</p>
<p>有个 Dark♂ 问题，我们在定义带函数成员的 <code>record</code> 的时候，非常非常的痛苦。 要么写一个辅助函数填进去，要么使用 lambda，不能使用函数定义（就是对参数模式匹配什么的） 的语法来定义这种函数成员。</p>
<p>一个典型的例子：各种 typeclass。</p>
<p>关于 Agda 的 typeclass 的详细解释，请看这篇文章：</p>
<pre class="Agda"><a id="1767" class="Keyword">import</a> <a id="1774" href="Typeclassopedia.html" class="Module">Typeclassopedia</a> <a id="1790" class="Keyword">using</a> <a id="1796" class="Symbol">()</a>
</pre>
<p>Agda 拥有验证各种 Law 的能力，但这不是重点，我就定义个简单的。</p>
<pre class="Agda"><a id="1850" class="Keyword">module</a> <a id="CopatternWithRecord"></a><a id="1857" href="CopatternIsMoreThanCoinduction.html#1857" class="Module">CopatternWithRecord</a> <a id="1877" class="Keyword">where</a>

  <a id="1886" class="Keyword">record</a> <a id="CopatternWithRecord.Monoid"></a><a id="1893" href="CopatternIsMoreThanCoinduction.html#1893" class="Record">Monoid</a> <a id="1900" class="Symbol">{</a><a id="1901" href="CopatternIsMoreThanCoinduction.html#1901" class="Bound">i</a><a id="1902" class="Symbol">}</a> <a id="1904" class="Symbol">(</a><a id="1905" href="CopatternIsMoreThanCoinduction.html#1905" class="Bound">A</a> <a id="1907" class="Symbol">:</a> <a id="1909" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1914" href="CopatternIsMoreThanCoinduction.html#1901" class="Bound">i</a><a id="1915" class="Symbol">)</a> <a id="1917" class="Symbol">:</a> <a id="1919" href="Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1924" href="CopatternIsMoreThanCoinduction.html#1901" class="Bound">i</a> <a id="1926" class="Keyword">where</a>
    <a id="1936" class="Keyword">inductive</a>
    <a id="1950" class="Keyword">field</a>
      <a id="CopatternWithRecord.Monoid.mempty"></a><a id="1962" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="1969" class="Symbol">:</a> <a id="1971" href="CopatternIsMoreThanCoinduction.html#1905" class="Bound">A</a>
      <a id="CopatternWithRecord.Monoid._&lt;&gt;_"></a><a id="1979" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">_&lt;&gt;_</a>   <a id="1986" class="Symbol">:</a> <a id="1988" href="CopatternIsMoreThanCoinduction.html#1905" class="Bound">A</a> <a id="1990" class="Symbol">-&gt;</a> <a id="1993" href="CopatternIsMoreThanCoinduction.html#1905" class="Bound">A</a> <a id="1995" class="Symbol">-&gt;</a> <a id="1998" href="CopatternIsMoreThanCoinduction.html#1905" class="Bound">A</a>
</pre>
<p>我们如果使用平常的方法定义 <code>Monoid</code> 的类型实例，很猥琐：</p>
<pre class="Agda">  <a id="2050" class="Keyword">module</a> <a id="StupidMonoid"></a><a id="2057" href="CopatternIsMoreThanCoinduction.html#2057" class="Module">StupidMonoid</a> <a id="2070" class="Keyword">where</a>
    <a id="2080" class="Symbol">{-#</a> <a id="2084" class="Keyword">TERMINATING</a> <a id="2096" class="Symbol">#-}</a>
    <a id="2104" href="CopatternIsMoreThanCoinduction.html#2104" class="Function">_</a> <a id="2106" class="Symbol">=</a> <a id="2108" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">unit</a> <a id="2113" class="Keyword">where</a>
        <a id="2127" class="Keyword">open</a> <a id="2132" href="CopatternIsMoreThanCoinduction.html#1893" class="Module">Monoid</a> <a id="2139" class="Symbol">{{</a> <a id="2142" class="Symbol">...</a> <a id="2146" class="Symbol">}}</a>
        <a id="2157" class="Keyword">instance</a>
          <a id="2176" class="Symbol">{-#</a> <a id="2180" class="Keyword">TERMINATING</a> <a id="2192" class="Symbol">#-}</a>
          <a id="2206" href="CopatternIsMoreThanCoinduction.html#2206" class="Function">ListMonoid</a> <a id="2217" class="Symbol">:</a> <a id="2219" href="CopatternIsMoreThanCoinduction.html#1893" class="Record">Monoid</a> <a id="2226" class="Symbol">(</a><a id="2227" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2232" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a><a id="2233" class="Symbol">)</a>
          <a id="2245" href="CopatternIsMoreThanCoinduction.html#2206" class="Function">ListMonoid</a> <a id="2256" class="Symbol">=</a> <a id="2258" class="Keyword">record</a>
            <a id="2277" class="Symbol">{</a> <a id="2279" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="2286" class="Symbol">=</a> <a id="2288" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
            <a id="2304" class="Symbol">;</a> <a id="2306" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">_&lt;&gt;_</a> <a id="2311" class="Symbol">=</a> <a id="2313" class="Symbol">λ</a> <a id="2315" class="Keyword">where</a>
              <a id="2335" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a> <a id="2339" href="CopatternIsMoreThanCoinduction.html#2339" class="Bound">b</a> <a id="2341" class="Symbol">-&gt;</a> <a id="2344" href="CopatternIsMoreThanCoinduction.html#2339" class="Bound">b</a>
              <a id="2360" class="Symbol">(</a><a id="2361" href="CopatternIsMoreThanCoinduction.html#2361" class="Bound">a</a> <a id="2363" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="2366" href="CopatternIsMoreThanCoinduction.html#2366" class="Bound">as</a><a id="2368" class="Symbol">)</a> <a id="2370" href="CopatternIsMoreThanCoinduction.html#2370" class="Bound">b</a> <a id="2372" class="Symbol">-&gt;</a> <a id="2375" href="CopatternIsMoreThanCoinduction.html#2361" class="Bound">a</a> <a id="2377" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="2380" class="Symbol">(</a><a id="2381" href="CopatternIsMoreThanCoinduction.html#2366" class="Bound">as</a> <a id="2384" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">&lt;&gt;</a> <a id="2387" href="CopatternIsMoreThanCoinduction.html#2370" class="Bound">b</a><a id="2388" class="Symbol">)</a>
            <a id="2402" class="Symbol">}</a>
</pre>
<p>（Instance Argument 的查找似乎出了点问题，只能把这个定义藏在一个 <code>where</code> 里面。 但我相信这不影响阅读，毕竟只是在外面加了一层 <code>_ = unit</code>）</p>
<p>当然了，出现了跨函数定义，因为 <code>&lt;&gt;</code> 的定义和使用（也就是调用 <code>ListMonoid</code>）产生了递归。 这导致我们必须手动让 termination check 闭嘴。</p>
<p>我们可以使用辅助函数，which means 需要另外再给这个函数想一个名字：</p>
<pre class="Agda">  <a id="2638" class="Keyword">module</a> <a id="MonoidWithHelperFunction"></a><a id="2645" href="CopatternIsMoreThanCoinduction.html#2645" class="Module">MonoidWithHelperFunction</a> <a id="2670" class="Keyword">where</a>
      <a id="CopatternWithRecord.MonoidWithHelperFunction.ListMonoid"></a><a id="2682" href="CopatternIsMoreThanCoinduction.html#2682" class="Function">ListMonoid</a> <a id="2693" class="Symbol">:</a> <a id="2695" href="CopatternIsMoreThanCoinduction.html#1893" class="Record">Monoid</a> <a id="2702" class="Symbol">(</a><a id="2703" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2708" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a><a id="2709" class="Symbol">)</a>
      <a id="2717" href="CopatternIsMoreThanCoinduction.html#2682" class="Function">ListMonoid</a> <a id="2728" class="Symbol">=</a> <a id="2730" class="Keyword">record</a>
        <a id="2745" class="Symbol">{</a> <a id="2747" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="2754" class="Symbol">=</a> <a id="2756" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
        <a id="2768" class="Symbol">;</a> <a id="2770" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">_&lt;&gt;_</a> <a id="2775" class="Symbol">=</a> <a id="2777" href="CopatternIsMoreThanCoinduction.html#2828" class="Function">whoAmI?Dunno,LOL</a>
        <a id="2802" class="Symbol">}</a>
        <a id="2812" class="Keyword">where</a>
          <a id="2828" href="CopatternIsMoreThanCoinduction.html#2828" class="Function">whoAmI?Dunno,LOL</a> <a id="2845" class="Symbol">:</a> <a id="2847" class="Symbol">(</a><a id="2848" href="CopatternIsMoreThanCoinduction.html#2848" class="Bound">a</a> <a id="2850" href="CopatternIsMoreThanCoinduction.html#2850" class="Bound">b</a> <a id="2852" class="Symbol">:</a> <a id="2854" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2859" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a><a id="2860" class="Symbol">)</a> <a id="2862" class="Symbol">-&gt;</a> <a id="2865" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="2870" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a>
          <a id="2882" href="CopatternIsMoreThanCoinduction.html#2828" class="Function">whoAmI?Dunno,LOL</a> <a id="2899" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a> <a id="2903" href="CopatternIsMoreThanCoinduction.html#2903" class="Bound">b</a> <a id="2905" class="Symbol">=</a> <a id="2907" href="CopatternIsMoreThanCoinduction.html#2903" class="Bound">b</a>
          <a id="2919" href="CopatternIsMoreThanCoinduction.html#2828" class="Function">whoAmI?Dunno,LOL</a> <a id="2936" class="Symbol">(</a><a id="2937" href="CopatternIsMoreThanCoinduction.html#2937" class="Bound">a</a> <a id="2939" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="2942" href="CopatternIsMoreThanCoinduction.html#2942" class="Bound">as</a><a id="2944" class="Symbol">)</a> <a id="2946" href="CopatternIsMoreThanCoinduction.html#2946" class="Bound">b</a> <a id="2948" class="Symbol">=</a>
            <a id="2962" href="CopatternIsMoreThanCoinduction.html#2937" class="Bound">a</a> <a id="2964" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="2967" class="Symbol">(</a><a id="2968" href="CopatternIsMoreThanCoinduction.html#2828" class="Function">whoAmI?Dunno,LOL</a> <a id="2985" href="CopatternIsMoreThanCoinduction.html#2942" class="Bound">as</a> <a id="2988" href="CopatternIsMoreThanCoinduction.html#2946" class="Bound">b</a><a id="2989" class="Symbol">)</a>
</pre>
<p>这种时候，除了 copattern 还有什么别的语言特性能用吗？</p>
<pre class="Agda">  <a id="3040" class="Keyword">open</a> <a id="3045" href="CopatternIsMoreThanCoinduction.html#1893" class="Module">Monoid</a> <a id="3052" class="Symbol">{{</a> <a id="3055" class="Symbol">...</a> <a id="3059" class="Symbol">}}</a> <a id="3062" class="Keyword">public</a>

  <a id="3072" class="Keyword">instance</a>
    <a id="3085" class="Symbol">{-#</a> <a id="3089" class="Keyword">TERMINATING</a> <a id="3101" class="Symbol">#-}</a>
    <a id="CopatternWithRecord.ListMonoid"></a><a id="3109" href="CopatternIsMoreThanCoinduction.html#3109" class="Function">ListMonoid</a> <a id="3120" class="Symbol">:</a> <a id="3122" href="CopatternIsMoreThanCoinduction.html#1893" class="Record">Monoid</a> <a id="3129" class="Symbol">(</a><a id="3130" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="3135" href="CopatternIsMoreThanCoinduction.html#279" class="Generalizable">A</a><a id="3136" class="Symbol">)</a>
    <a id="3142" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">Monoid.mempty</a> <a id="3156" href="CopatternIsMoreThanCoinduction.html#3109" class="Function">ListMonoid</a> <a id="3167" class="Symbol">=</a> <a id="3169" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
    <a id="3177" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">Monoid._&lt;&gt;_</a>   <a id="3191" href="CopatternIsMoreThanCoinduction.html#3109" class="Function">ListMonoid</a> <a id="3202" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a> <a id="3206" href="CopatternIsMoreThanCoinduction.html#3206" class="Bound">b</a> <a id="3208" class="Symbol">=</a> <a id="3210" href="CopatternIsMoreThanCoinduction.html#3206" class="Bound">b</a>
    <a id="3216" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">Monoid._&lt;&gt;_</a>   <a id="3230" href="CopatternIsMoreThanCoinduction.html#3109" class="Function">ListMonoid</a> <a id="3241" class="Symbol">(</a><a id="3242" href="CopatternIsMoreThanCoinduction.html#3242" class="Bound">a</a> <a id="3244" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="3247" href="CopatternIsMoreThanCoinduction.html#3247" class="Bound">as</a><a id="3249" class="Symbol">)</a> <a id="3251" href="CopatternIsMoreThanCoinduction.html#3251" class="Bound">b</a> <a id="3253" class="Symbol">=</a> <a id="3255" href="CopatternIsMoreThanCoinduction.html#3242" class="Bound">a</a> <a id="3257" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">::</a> <a id="3260" class="Symbol">(</a><a id="3261" href="CopatternIsMoreThanCoinduction.html#3247" class="Bound">as</a> <a id="3264" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">&lt;&gt;</a> <a id="3267" href="CopatternIsMoreThanCoinduction.html#3251" class="Bound">b</a><a id="3268" class="Symbol">)</a>
</pre>
<p>至于这个的 termination 问题我就不管它了，有一万种方法说服编译器这个东西是停机的。</p>
<p>简单的使用：</p>
<pre class="Agda">  <a id="3342" href="CopatternIsMoreThanCoinduction.html#3342" class="Function">_</a> <a id="3344" class="Symbol">=</a> <a id="3346" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="3353" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">&lt;&gt;</a> <a id="3356" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="3363" href="HoTT-Agda.html#628" class="Function">:&gt;</a> <a id="3366" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="3371" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a>
</pre>
<p>Lambda 表达式也是可以用 copattern 的：</p>
<pre class="Agda">  <a id="CopatternWithRecord.implementation"></a><a id="3420" href="CopatternIsMoreThanCoinduction.html#3420" class="Function">implementation</a> <a id="3435" class="Symbol">:</a> <a id="3437" href="CopatternIsMoreThanCoinduction.html#1893" class="Record">Monoid</a> <a id="3444" class="Symbol">(</a><a id="3445" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="3450" href="Agda.Builtin.Nat.html#165" class="Datatype">Nat</a><a id="3453" class="Symbol">)</a>
  <a id="3457" href="CopatternIsMoreThanCoinduction.html#3420" class="Function">implementation</a> <a id="3472" class="Symbol">=</a> <a id="3474" class="Symbol">λ</a> <a id="3476" class="Keyword">where</a>
    <a id="3486" class="Symbol">.</a><a id="3487" href="CopatternIsMoreThanCoinduction.html#1962" class="Field">mempty</a> <a id="3494" class="Symbol">-&gt;</a> <a id="3497" href="Agda.Builtin.List.html#158" class="InductiveConstructor">nil</a>
    <a id="3505" class="Symbol">.</a><a id="3506" href="CopatternIsMoreThanCoinduction.html#1979" class="Field Operator">_&lt;&gt;_</a> <a id="3511" href="CopatternIsMoreThanCoinduction.html#3511" class="Bound">a</a> <a id="3513" href="CopatternIsMoreThanCoinduction.html#3513" class="Bound">b</a> <a id="3515" class="Symbol">-&gt;</a> <a id="3518" href="CopatternIsMoreThanCoinduction.html#3511" class="Bound">a</a> <a id="3520" href="HoTT-Agda.html#733" class="Function Operator">++</a> <a id="3523" href="CopatternIsMoreThanCoinduction.html#3513" class="Bound">b</a>
</pre>
<p>偷懒用库函数定义啦。</p>{% endraw %}</body>
