[{"content":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，预计2-3年内结束实验[2]。\nCarbon官方项目选择Bazel构建工具，一方面是因为Google内部工具链的高可用性，相比于Go语言早期构建方式，作为同样出自Google之手的Carbon语言，避免手搓Makefile的繁琐，选用更加现代的工具链作为构建工具，另一方面也由于Google在LLVM之上的积累和贡献[3]，LLVM目前仓库中Bazel构建方式由Google团队完成及合并（不过经过测试发现，存在年久失修的问题[4]）。\n本项目介绍及依赖安装 本项目基于Carbon，为深入剖析现代编译器前端实现以及LLVM工具链上层使用，一步一步实现名为Cocktail（鸡尾酒）的语言，代码协议遵从官方仓库Lisence[5]，项目按照LLVM仓库主流构建方式和代码结构组织，使用CMake、Google test、Google mock等工具完成。\n本项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试，需要安装的依赖环境参考如下命令：\nsudo apt-get install cmake g++ clang bison flex libgtest-dev libgmock-dev make valgrind libbenchmark-dev llvm-15-dev CMake项目结构 首先从0到1构建CMake项目结构，参照clang的项目结构，project_structure代码如下：\n. ├── CMakeLists.txt ├── include │ └── Cocktail │ └── Lexer │ └── Basic.h ├── lib │ └── Lexer │ └── Basic.cc └── unittests ├── CMakeLists.txt └── Lexer ├── Basic.t.cc └── CMakeLists.txt 其中include作为Cocktail的头文件目录，lib作为Cocktail的库文件目录，其中C++文件一律以.cc作为后缀，unittests作为Cocktail单元测试文件目录，并且其中单元测试一律以.t.cc作为后缀，单元测试依赖头文件以.t.h为后缀。\n可在该目录下执行如下命令完成构建（make），或自行选用Ninja build：\n\u0026gt; mkdir build \u0026gt; cd build \u0026gt; cmake .. \u0026gt; make -j$(nproc) \u0026gt; ctest -j$(nproc) cmake构建结果如下：\n-- The C compiler identification is GNU 11.3.0 -- The CXX compiler identification is GNU 11.3.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Project: \u0026#39;cocktail\u0026#39; -- Performing Test HAVE_FFI_CALL -- Performing Test HAVE_FFI_CALL - Success -- Found FFI: /usr/lib/x86_64-linux-gnu/libffi.so -- Performing Test Terminfo_LINKABLE -- Performing Test Terminfo_LINKABLE - Success -- Found Terminfo: /usr/lib/x86_64-linux-gnu/libtinfo.so -- Found ZLIB: /usr/lib/x86_64-linux-gnu/libz.so (found version \u0026#34;1.2.11\u0026#34;) -- Found LibXml2: /usr/lib/x86_64-linux-gnu/libxml2.so (found version \u0026#34;2.9.13\u0026#34;) -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- unittest files found: Basic.t.cc -- Configuring done -- Generating done -- Build files have been written to: /carbon-blog/code/project_structure/build make构建结果如下：\n[ 25%] Building CXX object CMakeFiles/cocktail.dir/lib/Lexer/Basic.cc.o [ 50%] Linking CXX static library libcocktail.a [ 50%] Built target cocktail [ 75%] Building CXX object unittests/Lexer/CMakeFiles/Basic.t.dir/Basic.t.cc.o [100%] Linking CXX executable Basic.t [100%] Built target Basic.t ctest构建结果如下：\nTest project /carbon-blog/code/project_structure/build Start 1: Basic.t 1/2 Test #1: Basic.t .......................... Passed 0.01 sec Start 2: Basic.t-memory-check 2/2 Test #2: Basic.t-memory-check ............. Passed 0.97 sec 100% tests passed, 0 tests failed out of 2 Total Test time (real) = 0.98 sec 介绍CMake构建文件 在主目录下CMakeList.txt文件中可以看到这条add_compile_options(-fno-rtti)编译选项，这里表明禁用C++的RTTI特性，由于LLVM实现了自己的一套RTTI机制，此处加入该选项禁用。\nset(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm)设置LLVM路径，由于上述使用apt包管理安装llvm-15-dev，LLVM默认CMake路径为/usr/lib/llvm-15/lib/cmake/llvm。\n同时需要加入如下条件使得项目完成LLVM的引入：\nfind_package(LLVM REQUIRED CONFIG) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) 关于内存泄漏检查，使用valgrind工具，将其加入ctest中，对编译出的二进制目标进行测试：\nfind_program(CMAKE_MEMORYCHECK_COMMAND valgrind) set(memcheck_command ${CMAKE_MEMORYCHECK_COMMAND} ${CMAKE_MEMORYCHECK_COMMAND_OPTIONS} --error-exitcode=1 --leak-check=full) add_test(${FILE_NAME}-memory-check ${memcheck_command} ./${FILE_NAME}) clang-format使用 clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format[6]配置。\nclang-tidy使用 clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy[7]配置。\n项目调试的前置知识 由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件[8]，得以直观显示LLVM数据结构。\n引用 [1] : “C++的后继语言”\n[2] : 实验\n[3] : 贡献\n[4] : 年久失修的问题\n[5] : 官方仓库Lisence\n[6] : .clang-format\n[7] : .clang-tidy\n[8] : lldbDataFormatters插件\n","permalink":"https://canftin.github.io/posts/tech/%E4%BB%8E%E9%9B%B6%E6%9E%84%E9%80%A0%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A80-%E5%BC%80%E5%A7%8B/","summary":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，","title":"从零构造现代语言编译器(0): 开始"},{"content":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然 这么多年我个人陆陆续续整理了一些资料和笔记，但只适合我自己查找回顾，导致思维脉络过于零散，不够系统。 我现在的工作专注于编译器开发，目前工作三年，前两年一直在做一些后端业务型的服务或工具的开发，近一年主要集中在底层语言编译器 以及ai编译器开发部分。重启这个博客，一方面想让自己开始保持一定的知识整理习惯，增强语言输出能力，另一方面也是总结归纳底层 系统知识。最近的一个愿景就是先成体系地输出关于现代语言编译器的构造系列文章，尝试去从源码分析的角度完整剖析语言编译器的构成， 希望从这里开始重新投入。\n","permalink":"https://canftin.github.io/posts/tech/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E5%90%AF/","summary":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然 这么多年","title":"博客的重启"},{"content":"我是矩木，目前专注于编译器开发，我的GitHub。\n","permalink":"https://canftin.github.io/about/","summary":"我是矩木，目前专注于编译器开发，我的GitHub。","title":"关于我"}]