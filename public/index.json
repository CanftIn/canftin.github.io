[{"content":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做对比分析。\n1. 流 引入工具基类Printable如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /// CRTP基类，用于打印类型，子类必须实现Print接口： /// - auto Print(llvm::raw_ostream\u0026amp; out) -\u0026gt; void; template \u0026lt;typename DerivedT\u0026gt; class Printable { /// 提供给debugger的简单接口， /// `LLVM_DUMP_METHOD` 宏确保只有在调试构建中才会包含这个方法。 LLVM_DUMP_METHOD void Dump() const { static_cast\u0026lt;const DerivedT*\u0026gt;(this)-\u0026gt;Print(llvm::errs()); } /// llvm::raw_ostream输出。 friend auto operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; llvm::raw_ostream\u0026amp; { obj.Print(out); return out; } /// std::ostream输出。 friend auto operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; std::ostream\u0026amp; { llvm::raw_os_ostream raw_os(out); obj.Print(raw_os); return out; } friend auto PrintTo(DerivedT* p, std::ostream* out) -\u0026gt; void { *out \u0026lt;\u0026lt; static_cast\u0026lt;const void*\u0026gt;(p); if (p) { *out \u0026lt;\u0026lt; \u0026#34; pointing to \u0026#34; \u0026lt;\u0026lt; *p; } } }; 这里的Printable类被设计为一个基类，用于实现可打印的对象，它期望子类实现一个Print接口。\n1.1 Printable类的用途和功能 类型打印: 通过Print接口，子类可以自定义如何将其内容打印到输出流。 多种输出流支持: 支持llvm::raw_ostream和std::ostream两种输出流。 调试支持: 提供了一个Dump方法，用于在调试时快速查看对象的状态。 假设有一个Person类，我们希望能够打印其信息：\n1 2 3 4 5 6 7 8 9 10 class Person : public Printable\u0026lt;Person\u0026gt; { public: Person(std::string name, int age) : name(name), age(age) {} void Print(llvm::raw_ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;Person { name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; }\u0026#34;; } private: std::string name; int age; } 现在，Person类就可以使用Printable提供的所有功能。\n1 2 3 Person p(\u0026#34;Alice\u0026#34;, 30); llvm::raw_ostream\u0026amp; os = llvm::outs(); os \u0026lt;\u0026lt; p; // 输出：Person { name: Alice, age: 30 } 1.2 介绍CRTP和Mixin CRTP是C++中一种常用的编程模式，全名为“Curiously Recurring Template Pattern”，中文可以翻译为“奇异递归模板模式”。这个模式主要用于实现编译时多态性，也就是在编译时解析多态行为，而不是运行时。\n编译时多态: 由于多态行为在编译时就被解析，因此运行时性能开销小。 代码复用: 可以在基类中实现通用逻辑，减少代码重复。 类型安全: 使用static_cast进行类型转换是安全的，因为基类知道派生类的确切类型。 不适用于运行时多态: CRTP无法实现运行时多态，因为它依赖于编译时类型信息。 代码可读性: 对于不熟悉CRTP的开发者来说，代码可能会显得有些复杂。 在CRTP中，一个模板基类会以其派生类作为模板参数。这样，基类就可以在编译时知道其派生类的类型，基类就可以调用派生类的方法或访问其成员，即使这些方法或成员在基类中并没有被声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实际的实现 } }; 在这个例子中，Base类有一个interface方法，它内部调用了implementation方法。这个implementation方法是在Derived类中定义的，但Base类可以通过static_cast安全地调用它。\nCRTP常用于以下几种场景：\n静态多态: 如上面的例子所示，可以用于实现编译时多态。 Mixin 类: 可以用CRTP实现mixin（混入）功能，即在一个类中混入另一个类的功能。 工具类: 如在问题中的Printable类，用于提供一组通用的接口或实现。 总体来说，CRTP是一种非常强大而灵活的编程模式，尤其适用于需要高性能和代码复用的场景。\nMixin 功能 在 C++ 中，Mixin 是一种编程模式，用于通过组合而非继承来向一个类添加额外的功能或行为。Mixin 类通常是一些小型、可复用的组件，它们定义了特定的行为或功能，但不应该单独使用。通过将多个 Mixin 类组合在一起，你可以创建出具有多种功能的复杂对象。\nMixin 通常与模板编程和多重继承一起使用，以实现更高的灵活性和代码复用。\n假设你有一个 LoggerMixin 类，它提供了日志功能。\n1 2 3 4 5 6 class LoggerMixin { public: void log(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;[LOG]: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; 再假设你有一个 TimerMixin 类，用于计算代码执行时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;chrono\u0026gt; class TimerMixin { public: void startTimer() { start = std::chrono::high_resolution_clock::now(); } void stopTimer() { auto stop = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(stop - start); std::cout \u0026lt;\u0026lt; \u0026#34;Time taken: \u0026#34; \u0026lt;\u0026lt; duration.count() \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; }; 现在，你可以创建一个新类，通过多重继承来组合这两个 Mixin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass : public LoggerMixin, public TimerMixin { public: void doSomething() { log(\u0026#34;Starting operation...\u0026#34;); startTimer(); // 执行一些操作 // ... stopTimer(); log(\u0026#34;Operation completed.\u0026#34;); } }; 使用：\n1 2 3 4 5 int main() { MyClass obj; obj.doSomething(); return 0; } 这样，MyClass 就继承了 LoggerMixin 和 TimerMixin 的所有功能，而你不需要在 MyClass 中重新实现这些功能。\n代码复用: 你可以在多个类中重用同一个 Mixin。 解耦: Mixin 使得功能模块与业务逻辑解耦，更易于维护和扩展。 灵活性: 你可以灵活地组合多个 Mixin，以创建具有所需功能的新类。 复杂性: 使用多重继承和模板可能会增加代码复杂性。 名称冲突: 如果两个 Mixin 有相同的成员，可能会导致名称冲突。 1.3 LLVM输出流重载 LLVM是一个编译器基础设施项目，提供了一系列模块化的编译器组件和工具链。它用于开发编译器前端和后端，以及其他代码转换和代码生成工具。其中llvm::raw_ostream是llvm上的原始输出流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace llvm { /// 注入一个 `operator\u0026lt;\u0026lt;` 重载到 llvm 命名空间， /// 将 LLVM 类型的 `raw_ostream` 重载映射到 `std::ostream` 重载。 template \u0026lt;typename StreamT, typename ClassT, typename = std::enable_if_t\u0026lt; std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;, typename = std::enable_if_t\u0026lt; !std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt;\u0026gt; auto operator\u0026lt;\u0026lt;(StreamT\u0026amp; standard_out, const ClassT\u0026amp; value) -\u0026gt; StreamT\u0026amp; { raw_os_ostream(standard_out) \u0026lt;\u0026lt; value; return standard_out; } } // namespace llvm 这段代码定义了一个模板函数 operator\u0026lt;\u0026lt;，该函数重载了流插入运算符 \u0026lt;\u0026lt;。这个重载函数位于 llvm 命名空间中，并且是为了将 LLVM 的 raw_ostream 类型的重载映射到 C++ 标准库的 std::ostream 类型。其中 StreamT 代表流类型，通常是 std::ostream 或其派生类，ClassT 代表要输出的类的类型。\nstd::enable_if_t\u0026lt;std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;: 这个条件使用SFINAE（替换失败不是错误）确保 StreamT 是 std::ostream 的基类或者就是 std::ostream 本身。\nstd::enable_if_t\u0026lt;!std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt; 这个条件确保 ClassT 不是 raw_ostream 类型。\nraw_os_ostream(standard_out) \u0026lt;\u0026lt; value; 这里创建了一个 raw_os_ostream 对象，该对象是 LLVM 提供的一个流类，用于将 std::ostream 包装成 raw_ostream。然后，使用 raw_ostream 的 \u0026lt;\u0026lt; 运算符将 value 输出到这个流中。\n这样做的目的是利用 LLVM 已经为 raw_ostream 定义的 \u0026lt;\u0026lt; 运算符重载。这样，任何能够通过 raw_ostream 输出的 ClassT 类型都可以通过这个新的 \u0026lt;\u0026lt; 运算符重载输出到 std::ostream。\nreturn standard_out; 最后，函数返回传入的 std::ostream 引用，以支持链式调用。\n假设 LLVM 已经为一个名为 MyLLVMClass 的类定义了如下的 \u0026lt;\u0026lt; 运算符重载：\n1 2 3 4 llvm::raw_ostream\u0026amp; operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const MyLLVMClass\u0026amp; obj) { // ... 输出逻辑 return out; } 现在，你可以这样使用新的 \u0026lt;\u0026lt; 运算符重载：\n1 std::cout \u0026lt;\u0026lt; MyLLVMClassInstance; // 这里会调用上面定义的 operator\u0026lt;\u0026lt; 这样，MyLLVMClassInstance 就会被正确地输出到 std::cout，而这一切都是通过 LLVM 的 raw_ostream 完成的。\n总结一下，这段代码的主要目的是为了提供一种机制，使得任何可以通过 LLVM 的 raw_ostream 输出的对象都可以直接通过 C++ 的 std::ostream 输出，从而实现两者之间的重载映射。这样做提高了代码的可复用性和一致性。\n2. EnumBase枚举模版类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// 用CRTP以及X-Macro来生成枚举类的模板类。 template \u0026lt;typename DerivedT, typename EnumT, const llvm::StringLiteral Names[]\u0026gt; class EnumBase : public Printable\u0026lt;DerivedT\u0026gt; { public: using RawEnumType = EnumT; // 用于定义原始的模版类型。 using EnumType = DerivedT; // 派生的枚举类型。 using UnderlyingType = std::underlying_type_t\u0026lt;RawEnumType\u0026gt;; // 原始枚举类型的底层类型。 /// 允许将枚举类转换为原始的枚举类型， constexpr operator RawEnumType() const { return value_; } explicit operator bool() const = delete; /// 返回枚举的名称。 [[nodiscard]] auto name() const -\u0026gt; llvm::StringRef { return Names[AsInt()]; } /// 打印名称，使用于Printable，必须实现。 auto Print(llvm::raw_ostream\u0026amp; out) const -\u0026gt; void { out \u0026lt;\u0026lt; name(); } protected: constexpr EnumBase() = default; /// 从原始枚举器创建类型。 static constexpr auto Create(RawEnumType value) -\u0026gt; EnumType { EnumType result; result.value_ = value; return result; } /// 转换为整数类型。 constexpr auto AsInt() const -\u0026gt; UnderlyingType { return static_cast\u0026lt;UnderlyingType\u0026gt;(value_); } /// 从底层整数类型转换为枚举类型。 static constexpr auto FromInt(UnderlyingType value) -\u0026gt; EnumType { return Create(static_cast\u0026lt;RawEnumType\u0026gt;(value)); } private: RawEnumType value_; }; 这段代码定义了一个用于生成枚举类的模板类 EnumBase，以及一系列用于辅助生成枚举类的宏。这个模板类和宏的组合提供了一种灵活、可复用的方式来创建和操作枚举类。它的设计目的：\n类型安全: 通过使用强类型的枚举（enum class），提供更好的类型安全。 可打印: 通过继承以上的 Printable，使得枚举值可以被打印。 名称获取: 提供了一个 name() 方法，用于获取枚举值的名称。 主要宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 创造原始枚举类（不涉及名称）。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) \\ namespace Internal { \\ enum class EnumClassName##RawEnum : UnderlyingType; \\ } \\ enum class Internal::EnumClassName##RawEnum : UnderlyingType // 创造原始枚举类。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS(EnumClassName, UnderlyingType) \\ namespace Internal { \\ extern const llvm::StringLiteral EnumClassName##Names[]; \\ } \\ COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) // 在原始枚举类的定义中生成每个枚举值。 #define COCKTAIL_RAW_ENUM_ENUMERATOR(Name) Name, #define COCKTAIL_ENUM_BASE(EnumClassName) \\ COCKTAIL_ENUM_BASE_CRTP(EnumClassName, EnumClassName, EnumClassName) #define COCKTAIL_ENUM_BASE_CRTP(EnumClassName, LocalTypeNameForEnumClass, \\ EnumClassNameForNames) \\ ::Cocktail::Internal::EnumBase\u0026lt;LocalTypeNameForEnumClass, \\ Internal::EnumClassName##RawEnum, \\ Internal::EnumClassNameForNames##Names\u0026gt; // 枚举类体内生成每个值的命名常量声明。 #define COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) static const EnumType Name; // 枚举类体外定义每个命名常量。 #define COCKTAIL_ENUM_CONSTANT_DEFINITION(EnumClassName, Name) \\ constexpr EnumClassName EnumClassName::Name = \\ EnumClassName::Create(RawEnumType::Name); #define COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION(Name) \\ static constexpr const typename Base::EnumType\u0026amp; Name = \\ Base::Create(Base::RawEnumType::Name); // 在 `.cc` 文件中为枚举类开始定义每个枚举器的常量名数组。 #define COCKTAIL_DEFINE_ENUM_CLASS_NAMES(EnumClassName) \\ constexpr llvm::StringLiteral Internal::EnumClassName##Names[] #define COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #Name, COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES: 定义一个没有名称数组的原始枚举类。 COCKTAIL_DEFINE_RAW_ENUM_CLASS: 定义一个有名称数组的原始枚举类。 COCKTAIL_RAW_ENUM_ENUMERATOR: 在原始枚举类定义中生成每个枚举值。 COCKTAIL_ENUM_BASE: 生成用于派生的 EnumBase 类型。 COCKTAIL_ENUM_CONSTANT_DECLARATION: 在枚举类体内生成每个值的命名常量声明。 COCKTAIL_ENUM_CONSTANT_DEFINITION: 在枚举类体外定义每个命名常量。 COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION: 用于内联定义每个命名常量。 COCKTAIL_DEFINE_ENUM_CLASS_NAMES: 在 .cc 文件中为枚举类开始定义每个枚举器的常量名数组。 COCKTAIL_ENUM_CLASS_NAME_STRING: 用于生成枚举值名称的字符串。 这个 EnumBase 类和相关的宏提供了一种高度可定制和可复用的方式来创建和操作枚举类。它们解决了类型安全、可打印性和名称获取等常见问题，同时也提供了一种简洁、一致的方式来定义和使用枚举类。这样的设计非常适用于大型项目中，特别是那些需要多次定义和使用不同枚举类的项目。\n什么是X-Macro X-Macro 是一种 C 和 C++ 预处理器技术，用于生成重复或模式化的代码。这种技术通过定义宏来实现，这些宏在不同的上下文中被多次展开，以生成不同的代码片段。X-Macro 主要用于减少代码重复，提高代码的可维护性。\n一个典型的 X-Macro 的使用方式是定义一个宏，该宏接受一个或多个参数，并在不同的上下文中多次展开。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define COLOR_XMACRO \\ X(Red) \\ X(Green) \\ X(Blue) // 定义枚举 enum Color { #define X(name) name, COLOR_XMACRO #undef X }; // 定义字符串数组 const char* ColorNames[] = { #define X(name) #name, COLOR_XMACRO #undef X }; 在这个例子中，COLOR_XMACRO 宏定义了一个颜色列表。然后，通过在不同的上下文中展开 X 宏，我们生成了一个 Color 枚举和一个 ColorNames 字符串数组。\nX-Macro 也可以用于更复杂的代码生成任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define PERSON_XMACRO \\ X(std::string, Name) \\ X(int, Age) \\ X(double, Height) // 定义结构体 struct Person { #define X(type, name) type name; PERSON_XMACRO #undef X }; // 序列化函数 std::string Serialize(const Person\u0026amp; p) { std::string result; #define X(type, name) result += std::to_string(p.name) + \u0026#34; \u0026#34;; PERSON_XMACRO #undef X return result; } // 反序列化函数（简化版） void Deserialize(Person\u0026amp; p, const std::string\u0026amp; s) { std::istringstream iss(s); #define X(type, name) iss \u0026gt;\u0026gt; p.name; PERSON_XMACRO #undef X } 在这个例子中，PERSON_XMACRO 定义了一个 Person 结构体的字段。然后，我们生成了该结构体的定义以及其序列化和反序列化函数。\n减少代码重复: 通过在多个地方展开相同的宏，减少了代码重复。 提高可维护性: 如果需要添加、删除或修改某个元素，只需在一个地方进行更改。 灵活性: 可以在不同的上下文中以不同的方式展开相同的宏。 可读性: 对于不熟悉 X-Macro 的人来说，代码可能难以理解。 调试困难: 预处理器生成的代码可能难以调试。 总体来说，X-Macro 是一种非常强大的代码生成技术，尤其适用于需要生成重复或模式化代码的场景。然而，它也有一些缺点，如可能降低代码的可读性和可调试性。因此，在使用 X-Macro 时，应权衡其优缺点。\n","permalink":"https://canftin.github.io/posts/tech/%E4%BB%8E%E9%9B%B6%E6%9E%84%E9%80%A0%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A82-%E5%85%AC%E5%85%B1%E5%BA%93/","summary":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做","title":"从零构造现代语言编译器(2): 公共库"},{"content":"什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 123、3.14、0xFF、1.23e-4 都可以被视为数值字面量。\n字面量的类型通常根据其格式和位置决定。例如在大多数编程语言[1][2][3]中，带有小数点的数字将被视为浮点数（如 3.14 ），而没有小数点的数字将被视为整数（如 123 ）。\n更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。\n本章将从数值字面量的解析入手，开始进入编译器构造的世界。\nCarbon数值类型介绍 Carbon中数值类型[4][5]有如下几种：\n整数类型\n整数根据进制分为如下类型：十进制（例如 12345 ）、十六进制（例如 0x1FE ）、二进制（例如 0b1010 ）等\n实数类型\n实数类型总是包含 . 符号，实数类型例如基础类型 123.456 以及科学技术法表示 123.456e789、0x1.2p123 等，其中科学技术法表示中的字符 e 及 p 在Carbon中称为指数（对应代码中exponent 字符，实际在幂运算中应为底数），对于一个十进制值 N 来说，e 相当于10±N，而 p 相当于2±N。\n且实数类型字面量 exponent 字符后可跟随 + 或 - 字符，例如 12.34e+56 或 56.34e-12。\n数字分隔符[6]\n数字分隔符由下划线 _ 表示，例如十进制数: 1_23_456_7890、十六进制数: 0x7_F_FF_FFFF、实数: 2_147.48_3648e12_345 或 0x1_00CA.FE_F00Dp+2_4、二进制数: 0b1_000_101_11 等。\n数值字面量词法解析： 首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 _ 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 exponent 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供NumericLiteralToken类的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。\n以下代码参考numeric_literal section1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class NumericLiteralToken { public: auto Text() const -\u0026gt; llvm::StringRef { return text; } static auto Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt;; auto GetRadixPoint() -\u0026gt; int { return radix_point; } auto GetExponent() -\u0026gt; int { return exponent; } private: NumericLiteralToken() {} llvm::StringRef text; // \u0026#39;.\u0026#39;字符的偏移量 int radix_point; // \u0026#39;e\u0026#39;或\u0026#39;p\u0026#39;字符的偏移量 int exponent; }; 其中我们重点关注Lex接口的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 auto NumericLiteralToken::Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt; { NumericLiteralToken result; // 判断source_text是否为空以及第一个字符是否为数字 if (source_text.empty() || !IsDecimalDigit(source_text.front())) { return llvm::None; } bool seen_plus_minus = false; bool seen_radix_point = false; bool seen_potential_exponent = false; // 由于之前已经确认过首字符，这里索引从1开始 int i = 1; for (int n = source_text.size(); i != n; ++i) { char c = source_text[i]; if (IsAlnum(c) || c == \u0026#39;_\u0026#39;) { // 只支持小写的 \u0026#39;e\u0026#39;，如果存在该字符且发现点号以及未探索 // 到加减号则记录exponent索引位置，否则继续下一轮循环 if (IsLower(c) \u0026amp;\u0026amp; seen_radix_point \u0026amp;\u0026amp; !seen_plus_minus) { result.exponent = i; seen_potential_exponent = true; } continue; } // 当前字符为 \u0026#39;.\u0026#39; 时，记录radix_point if (c == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1]) \u0026amp;\u0026amp; !seen_radix_point) { result.radix_point = i; seen_radix_point = true; continue; } // 当前字符为 \u0026#39;+\u0026#39; 或 \u0026#39;-\u0026#39; 时，记录seen_plus_minus if ((c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; seen_potential_exponent \u0026amp;\u0026amp; result.exponent == i - 1 \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1])) { assert(!seen_plus_minus \u0026amp;\u0026amp; \u0026#34;should only consume one + or -\u0026#34;); seen_plus_minus = true; continue; } break; } // 返回探索到的字符串，以当前i的值为索引切分子串 result.text = source_text.substr(0, i); // 记录 \u0026#39;.\u0026#39; 偏移 if (!seen_radix_point) { result.radix_point = i; } // 记录 \u0026#39;e\u0026#39; 或 \u0026#39;p\u0026#39; 偏移 if (!seen_potential_exponent) { result.exponent = i; } return result; } 以上代码中，source_text用于接受外部传入的数值字符串，该类型为llvm::StringRef类型（StringRef类型分析可参考chapter12_s1.2: LLVM ADT StringRef介绍及使用），首先判断source_text是否为空以及第一个字符是否为数字，如果不满足条件则返回llvm::None，llvm::None实际为一个枚举数值类型，返回值为llvm::Optional（Optional类型分析可参考chapter12_s1.3: LLVM ADT Optional介绍及使用）。\n接下来使用三个变量seen_plus_minus（是否探索到 + 或 - ）、seen_radix_point（是否探索到 . ）、seen_potential_exponent（是否探索到 e 或者 p ）用于后续词法解析的条件判断。\n在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。\n跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。\n数值字面量语法解析 在词法层面我们切分并完成了NumericLiteralToken对象的解析，接下来需要实现数值字面量的解析，实现这一步的目标是在语义上能对不同数值字面量提取更多的信息，其中包括数值字面量的合规性检查、提取数据等，将数值字面量解析拆分为了Tokenizer和Parser两部分，使得每部分过程更为明确和便于后期扩展。\n我们关注numeric_literal代码section2中的友元类Parser实现，将section1中NumericLiteralToken里两个函数GetRadixPoint和GetExponent的能力删除，将提取对应数据的能力移交至Parser，函数返回值改为llvm::APInt（参考阅读什么是APInt链接）。\n以下代码参考numeric_literal section2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class NumericLiteralToken::Parser { public: Parser(NumericLiteralToken literal); auto IsInteger() -\u0026gt; bool { return literal.radix_point == static_cast\u0026lt;int\u0026gt;(literal.Text().size()); } auto GetRadix() const -\u0026gt; int { return radix; } auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; private: NumericLiteralToken literal; // 存储对应字面量 // 基数默认为10，可以为 2 或 10 或 16 int radix = 10; // 词法结构：[radix] int_part [. fract_part [[ep] [+-] exponent_part]] llvm::StringRef int_part; // 整数部分 llvm::StringRef fract_part; // 小数部分 llvm::StringRef exponent_part; // 指数部分 // 对应数据是否需要清除`_`或`.`符号，默认为false bool mantissa_needs_cleaning = false; bool exponent_needs_cleaning = false; // 在`exponent`部分后面发现了`-`符号 bool exponent_is_negative = false; }; 具体看一下Parser的构造函数，构造时传入NumericLiteralToken对象，根据该对象里的radix_point数据进行int_part数据的切分，并对切分结果前两个字符做检查，根据0x或0b首字符判断进制，随即切分fract_part数据以及exponent_part数据，并判断是否在exponent部分后面发现了-符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 NumericLiteralToken::Parser::Parser(NumericLiteralToken literal) : literal(literal) { int_part = literal.text.substr(0, literal.radix_point); if (int_part.consume_front(\u0026#34;0x\u0026#34;)) { radix = 16; } else if (int_part.consume_front(\u0026#34;0b\u0026#34;)) { radix = 2; } fract_part = literal.text.substr(literal.radix_point + 1, literal.exponent - literal.radix_point - 1); exponent_part = literal.text.substr(literal.exponent + 1); if (!exponent_part.consume_front(\u0026#34;+\u0026#34;)) { exponent_is_negative = exponent_part.consume_front(\u0026#34;-\u0026#34;); } } Parser构造函数中构建好数据后，需要提供接口获取对应数据。\n其中包括四个函数接口：\n1 2 3 4 auto IsInteger() -\u0026gt; bool; auto GetRadix() const -\u0026gt; int; auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; IsInteger()用于判断是否为一个整数，判断方式为小数点位置是否在字符串末尾，字符串显示不存在小数点时，小数点默认在末尾。 GetRadix()用于获取进制。 GetMantissa()用于获取小数部分。 GetExponent()用于获取指数部分。 其中GetMantissa()和GetExponent()都调用了ParseInteger接口，ParseInteger完成获取具体数值的功能，以下为ParseInteger接口代码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static auto ParseInteger(llvm::StringRef digits, int radix, bool needs_cleaning) -\u0026gt; llvm::APInt { llvm::SmallString\u0026lt;32\u0026gt; cleaned; // 预分配32个字节的字符串 if (needs_cleaning) { cleaned.reserve(digits.size()); // 根据目标大小重建长度 std::remove_copy_if(digits.begin(), digits.end(), std::back_inserter(cleaned), [](char c) { return c == \u0026#39;_\u0026#39; || c == \u0026#39;.\u0026#39;; }); digits = cleaned; } llvm::APInt value; if (digits.getAsInteger(radix, value)) { llvm_unreachable(\u0026#34;should never fail\u0026#34;); } return value; } 当解析包含小数点和下划线的字面量时，将忽视这两种字符，例如在解析 123.456e7 字面量时，我们期望获取到小数部分mantissa即(123456)和指数部分exponent(7-3=4)，根据这两个数我们能计算出真实的数据为：1234560000，其中GetMantissa函数如下：\n1 2 3 4 5 6 auto NumericLiteralToken::Parser::GetMantissa() -\u0026gt; llvm::APInt { // 如果为整数从int_part为结尾，否则以fract_part为结尾 const char* end = IsInteger() ? int_part.end() : fract_part.end(); llvm::StringRef digits(int_part.begin(), end - int_part.begin()); return ParseInteger(digits, radix, mantissa_needs_cleaning); } 获取exponent的函数GetExponent如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 auto NumericLiteralToken::Parser::GetExponent() -\u0026gt; llvm::APInt { llvm::APInt exponent(64, 0); // 创建64位值为0的exponent对象。 // 如果存在指数部分，就进入这个分支。 if (!exponent_part.empty()) { // 解析指数部分。这个函数会将字符串形式的指数转换为整数。其中， // 第一个参数是指数部分，第二个参数10是代表十进制，第三个参数 // 表示解析过程中是否需要进行清理。 exponent = ParseInteger(exponent_part, 10, exponent_needs_cleaning); // 检查指数的符号位是否被设置，或者指数的位宽是否小于64。 // 如果满足这些条件之一，就需要扩展指数的位宽。 if (exponent.isSignBitSet() || exponent.getBitWidth() \u0026lt; 64) { // 扩展指数的位宽。新的位宽至少为64，如果原来的位宽+1大于64， // 那么就使用原来的位宽+1。扩展后，新增的位都被设置为0。 exponent = exponent.zext(std::max(64U, exponent.getBitWidth() + 1)); } // 如果指数是负数，就需要取反。 if (exponent_is_negative) { exponent.negate(); // 取反操作。 } } // 计算小数部分的字符数量，这个数量会影响实际的指数大小。 int excess_exponent = fract_part.size(); // 如果基数是16，即如果是十六进制的数，那么每一个小数部 // 分的字符都会减少4个指数（因为一个十六进制的字符等于4个二进制位）。 if (radix == 16) { excess_exponent *= 4; // 将小数部分的字符数量乘以4。 } exponent -= excess_exponent; // 从指数中减去小数部分的字符数量。 // 如果原来的指数是负数，但是计算后的指数变为非负，那么就进入这个分支。 if (exponent_is_negative \u0026amp;\u0026amp; !exponent.isNegative()) { // 扩展指数的位宽，新增的位被设置为0。 exponent = exponent.zext(exponent.getBitWidth() + 1); // 设置指数的符号位，使得指数变为负数。 exponent.setSignBit(); } return exponent; } 从上面我们可以看到mantissa_needs_cleaning和exponent_needs_cleaning永远为false，原因是因为这两个标志位需要在获取数据之前对字面量做检查后进行设置，对传入不满足要求的字面量做预处理检查后才允许提取。\n关于字面量检查部分在下一章Chapter2: 诊断信息中进行说明与分析。\n引用 [1] : Floating-point numeric types - C# reference | Microsoft Learn [2] : numeric_literals | MDN Web [3] : json-tutorial | miloyip [4] : numeric_literals | Carbon [5] : proposals 0143 | Carbon [6] : proposals 1983 | Carbon ","permalink":"https://canftin.github.io/posts/tech/%E4%BB%8E%E9%9B%B6%E6%9E%84%E9%80%A0%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","summary":"什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个","title":"从零构造现代语言编译器(1): 词法分析"},{"content":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，预计2-3年内结束实验[2]。\nCarbon官方项目选择Bazel构建工具，一方面是因为Google内部工具链的高可用性，相比于Go语言早期构建方式，作为同样出自Google之手的Carbon语言，避免手搓Makefile的繁琐，选用更加现代的工具链作为构建工具，另一方面也由于Google在LLVM之上的积累和贡献[3]，LLVM目前仓库中Bazel构建方式由Google团队完成及合并（不过经过测试发现，存在年久失修的问题[4]）。\n本项目介绍及依赖安装 本项目基于Carbon，为深入剖析现代编译器前端实现以及LLVM工具链上层使用，一步一步实现名为Cocktail（鸡尾酒）的语言，代码协议遵从官方仓库Lisence[5]，项目按照LLVM仓库主流构建方式和代码结构组织，使用CMake、Google test、Google mock等工具完成。\n本项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试，需要安装的依赖环境参考如下命令：\n1 sudo apt-get install cmake g++ clang bison flex libgtest-dev libgmock-dev make valgrind libbenchmark-dev llvm-15-dev CMake项目结构 首先从0到1构建CMake项目结构，参照clang的项目结构，project_structure代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 . ├── CMakeLists.txt ├── include │ └── Cocktail │ └── Lexer │ └── Basic.h ├── lib │ └── Lexer │ └── Basic.cc └── unittests ├── CMakeLists.txt └── Lexer ├── Basic.t.cc └── CMakeLists.txt 其中include作为Cocktail的头文件目录，lib作为Cocktail的库文件目录，其中C++文件一律以.cc作为后缀，unittests作为Cocktail单元测试文件目录，并且其中单元测试一律以.t.cc作为后缀，单元测试依赖头文件以.t.h为后缀。\n可在该目录下执行如下命令完成构建（make），或自行选用Ninja build：\n1 2 3 4 5 \u0026gt; mkdir build \u0026gt; cd build \u0026gt; cmake .. \u0026gt; make -j$(nproc) \u0026gt; ctest -j$(nproc) cmake构建结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 -- The C compiler identification is GNU 11.3.0 -- The CXX compiler identification is GNU 11.3.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Project: \u0026#39;cocktail\u0026#39; -- Performing Test HAVE_FFI_CALL -- Performing Test HAVE_FFI_CALL - Success -- Found FFI: /usr/lib/x86_64-linux-gnu/libffi.so -- Performing Test Terminfo_LINKABLE -- Performing Test Terminfo_LINKABLE - Success -- Found Terminfo: /usr/lib/x86_64-linux-gnu/libtinfo.so -- Found ZLIB: /usr/lib/x86_64-linux-gnu/libz.so (found version \u0026#34;1.2.11\u0026#34;) -- Found LibXml2: /usr/lib/x86_64-linux-gnu/libxml2.so (found version \u0026#34;2.9.13\u0026#34;) -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- unittest files found: Basic.t.cc -- Configuring done -- Generating done -- Build files have been written to: /carbon-blog/code/project_structure/build make构建结果如下：\n1 2 3 4 5 6 [ 25%] Building CXX object CMakeFiles/cocktail.dir/lib/Lexer/Basic.cc.o [ 50%] Linking CXX static library libcocktail.a [ 50%] Built target cocktail [ 75%] Building CXX object unittests/Lexer/CMakeFiles/Basic.t.dir/Basic.t.cc.o [100%] Linking CXX executable Basic.t [100%] Built target Basic.t ctest构建结果如下：\n1 2 3 4 5 6 7 8 9 Test project /carbon-blog/code/project_structure/build Start 1: Basic.t 1/2 Test #1: Basic.t .......................... Passed 0.01 sec Start 2: Basic.t-memory-check 2/2 Test #2: Basic.t-memory-check ............. Passed 0.97 sec 100% tests passed, 0 tests failed out of 2 Total Test time (real) = 0.98 sec 介绍CMake构建文件 在主目录下CMakeList.txt文件中可以看到这条add_compile_options(-fno-rtti)编译选项，这里表明禁用C++的RTTI特性，由于LLVM实现了自己的一套RTTI机制，此处加入该选项禁用。\nset(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm)设置LLVM路径，由于上述使用apt包管理安装llvm-15-dev，LLVM默认CMake路径为/usr/lib/llvm-15/lib/cmake/llvm。\n同时需要加入如下条件使得项目完成LLVM的引入：\n1 2 3 4 find_package(LLVM REQUIRED CONFIG) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) 关于内存泄漏检查，使用valgrind工具，将其加入ctest中，对编译出的二进制目标进行测试：\n1 2 3 4 find_program(CMAKE_MEMORYCHECK_COMMAND valgrind) set(memcheck_command ${CMAKE_MEMORYCHECK_COMMAND} ${CMAKE_MEMORYCHECK_COMMAND_OPTIONS} --error-exitcode=1 --leak-check=full) add_test(${FILE_NAME}-memory-check ${memcheck_command} ./${FILE_NAME}) clang-format使用 clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format[6]配置。\nclang-tidy使用 clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy[7]配置。\n项目调试的前置知识 由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件[8]，得以直观显示LLVM数据结构。\n引用 [1] : “C++的后继语言”\n[2] : 实验\n[3] : 贡献\n[4] : 年久失修的问题\n[5] : 官方仓库Lisence\n[6] : .clang-format\n[7] : .clang-tidy\n[8] : lldbDataFormatters插件\n","permalink":"https://canftin.github.io/posts/tech/%E4%BB%8E%E9%9B%B6%E6%9E%84%E9%80%A0%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A80-%E5%BC%80%E5%A7%8B/","summary":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，","title":"从零构造现代语言编译器(0): 开始"},{"content":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年我个人陆陆续续整理了一些资料和笔记，但只适合我自己查找回顾，导致思维脉络过于零散，不够系统。 我现在的工作专注于编译器开发，目前工作三年，前两年一直在做一些后端业务型的服务或工具的开发，近一年主要集中在底层语言编译器以及ai编译器开发部分。 重启这个博客，一方面想让自己开始保持一定的知识整理习惯，增强语言输出能力，另一方面也是总结归纳底层系统知识。 最近的一个愿景就是先成体系地输出关于现代语言编译器的构造系列文章，尝试去从源码分析的角度完整剖析语言编译器的构成，希望从这里开始重新投入。\n","permalink":"https://canftin.github.io/posts/tech/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E5%90%AF/","summary":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年","title":"重启博客"},{"content":"我是矩木，目前专注于编译器开发，我的GitHub。\n","permalink":"https://canftin.github.io/about/","summary":"我是矩木，目前专注于编译器开发，我的GitHub。","title":"关于我"}]