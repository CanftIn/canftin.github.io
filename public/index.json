[{"content":" // TODO: 1. 分析老版本mmap的SourceBuffer。\n// TODO: 2. 分vfs版本SourceBuffer。\n1. 为什么需要SourceBuffer 2. mmap版本SourceBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SourceBuffer { public: static auto CreateFromText(llvm::Twine text, llvm::StringRef filename = \u0026#34;/text\u0026#34;) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt;; static auto CreateFromFile(llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt;; SourceBuffer() = delete; SourceBuffer(const SourceBuffer\u0026amp;) = delete; SourceBuffer(SourceBuffer\u0026amp;\u0026amp; arg) noexcept; ~SourceBuffer(); [[nodiscard]] auto filename() const -\u0026gt; llvm::StringRef { return filename_; } [[nodiscard]] auto text() const -\u0026gt; llvm::StringRef { return text_; } private: enum class ContentMode { Uninitialized, MMapped, Owned, }; // Constructor for mmapped content. explicit SourceBuffer(std::string filename, llvm::StringRef text); // Constructor for owned content. explicit SourceBuffer(std::string filename, std::string text); ContentMode content_mode_; std::string filename_; std::string text_storage_; llvm::StringRef text_; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 static auto CheckContentSize(int64_t size) -\u0026gt; llvm::Error { if (size \u0026lt; std::numeric_limits\u0026lt;int32_t\u0026gt;::max()) { return llvm::Error::success(); } return llvm::createStringError(llvm::inconvertibleErrorCode(), \u0026#34;Input too large!\u0026#34;); } auto SourceBuffer::CreateFromText(llvm::Twine text, llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt; { std::string buffer = text.str(); auto size_check = CheckContentSize(buffer.size()); if (size_check) { return std::move(size_check); } return SourceBuffer(filename.str(), std::move(buffer)); } static auto ErrnoToError(int errno_value) -\u0026gt; llvm::Error { return llvm::errorCodeToError( std::error_code(errno_value, std::generic_category())); } auto SourceBuffer::CreateFromFile(llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt; { std::string filename_str = filename.str(); errno = 0; int file_descriptor = open(filename_str.c_str(), O_RDONLY); if (file_descriptor == -1) { return ErrnoToError(errno); } auto closer = llvm::make_scope_exit([file_descriptor] { close(file_descriptor); }); struct stat stat_buffer = {}; errno = 0; if (fstat(file_descriptor, \u0026amp;stat_buffer) == -1) { return ErrnoToError(errno); } int64_t size = stat_buffer.st_size; if (size == 0) { return SourceBuffer(std::move(filename_str), std::string()); } auto size_check = CheckContentSize(size); if (size_check) { return std::move(size_check); } errno = 0; void* mapped_text = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, file_descriptor, /*offset=*/0); if (mapped_text == MAP_FAILED) { return ErrnoToError(errno); } errno = 0; closer.release(); if (close(file_descriptor) == -1) { munmap(mapped_text, size); return ErrnoToError(errno); } return SourceBuffer( std::move(filename_str), llvm::StringRef(static_cast\u0026lt;const char*\u0026gt;(mapped_text), size)); } SourceBuffer::SourceBuffer(SourceBuffer\u0026amp;\u0026amp; arg) noexcept : content_mode_( std::exchange(arg.content_mode_, ContentMode::Uninitialized)), filename_(std::move(arg.filename_)), text_storage_(std::move(arg.text_storage_)), text_(content_mode_ == ContentMode::Owned ? text_storage_ : arg.text_) {} SourceBuffer::SourceBuffer(std::string filename, std::string text) : content_mode_(ContentMode::Owned), filename_(std::move(filename)), text_storage_(std::move(text)), text_(text_storage_) {} SourceBuffer::SourceBuffer(std::string filename, llvm::StringRef text) : content_mode_(ContentMode::MMapped), filename_(std::move(filename)), text_(text) { COCKTAIL_CHECK(!text.empty()) \u0026lt;\u0026lt; \u0026#34;Must not have an empty text when we have mapped data from a file!\u0026#34;; } SourceBuffer::~SourceBuffer() { if (content_mode_ == ContentMode::MMapped) { errno = 0; int result = munmap(const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;const void*\u0026gt;(text_.data())), text_.size()); COCKTAIL_CHECK(result != -1) \u0026lt;\u0026lt; \u0026#34;Unmapping text failed!\u0026#34;; } } 3. llvm::vfs版本SourceBuffer 这段代码定义了一个名为SourceBuffer的类，该类表示Carbon源代码的缓冲区。以下是对这段代码的详细解释：\n注释概述 SourceBuffer：这个类持有Carbon源代码的文本缓冲区，并使其可供Carbon编译器的其余部分使用。它拥有底层源代码文本的内存，并确保其与缓冲区对象一样长寿。\n来源：每个源代码文本缓冲区在概念上都是从Carbon源文件加载的，即使在构造缓冲区时直接提供。还保留并提供了应该用于该Carbon源文件的名称。\n内存管理：由于源代码文本的底层内存可能是从文件中读取的，我们可能希望使用像mmap这样的工具将该文件映射到内存中，所以为了避免需要为映射的文件定义复制语义，缓冲区本身是不可复制的。如果需要，我们可以在未来放宽这一限制，并增加一些实现复杂性。\n类定义 SourceBuffer：这是主要的类定义，它代表了Carbon源代码的缓冲区。 公共成员函数 CreateFromFile：这是一个静态函数，用于从指定的文件名打开一个文件。如果成功，它返回一个SourceBuffer对象；如果失败，它打印一个错误并返回nullopt（即没有有效的SourceBuffer对象）。\n构造函数：默认构造函数被删除，这意味着你不能直接创建一个SourceBuffer对象。你必须使用上面的CreateFromFile函数或其他类似的工厂函数来创建一个SourceBuffer对象。\nfilename：这是一个常量成员函数，返回源文件的名称。\ntext：这是一个常量成员函数，返回源代码文本的引用。\n私有成员 私有构造函数：这个构造函数是私有的，这意味着你不能从类的外部直接调用它。它接受一个文件名和一个llvm::MemoryBuffer的唯一指针，并将它们存储在私有成员变量中。\nfilename_：这是一个私有成员变量，用于存储源文件的名称。\ntext_：这是一个私有成员变量，它是一个指向llvm::MemoryBuffer的唯一指针，用于存储源代码文本。\n总结 SourceBuffer类是用于管理Carbon源代码的缓冲区的。它提供了从文件创建缓冲区的功能，并提供了访问源文件名和源代码文本的方法。为了内存管理和文件映射的方便，这个类是不可复制的。\n","permalink":"https://canftin.github.io/posts/tech/p6_compiler_build_5_source_buffer/","summary":"// TODO: 1. 分析老版本mmap的SourceBuffer。 // TODO: 2. 分vfs版本SourceBuffer。 1. 为什么需要SourceBuffer 2. mma","title":"从零构造现代语言编译器(5): 缓冲区"},{"content":"1. 注释 在现有的编程语言中，注释有多种用途。主要的用例包括：\n文档：为API的用户和未来的维护者提供人类可读的注释，解释其功能以及如何使用它。这种注释通常附加在函数声明、类定义、公共成员声明、文件范围等API的相似粒度级别上。 1 2 3 4 5 6 7 /// 一个连接小部件集合的容器。 class WidgetAssembly { /// 如果可能的话，改善组件的外观。 void decorate(bool repaint_all = false); // ... }; 实现注释：为代码的未来读者或维护者提供人类可读的注释，解释意图和机制，或总结代码的行为，以避免读者或维护者需要详细阅读它。当这些细节从代码本身可能不容易看出或可能需要非平凡的工作来推断时，通常使用这种注释，而且这种注释往往很短。 1 2 3 4 5 6 7 8 9 10 11 12 void WidgetAssembly::decorate(bool repaint_all) { // ... // 绘制上次更改后的所有小部件。 for (auto \u0026amp;w : widgets) { if (repaint_all || w.modified \u0026gt; last_foo) w.paint(); } last_decorate = now(); // ... } 语法消歧注释：包含代码或伪代码的注释，旨在让人类读者更容易地按照编译器的方式解析代码。 1 2 3 4 5 6 7 8 9 10 void WidgetAssembly::decorate(bool repaint_all /*= false*/) { // ... /*static*/ std::unique_ptr\u0026lt;WidgetAssembly\u0026gt; WidgetAssembly::make() { // ... assembly.decorate(/*repaint_all=*/true); // ... } // 结束命名空间 WidgetLibrary 禁用的代码：包含已被禁用的代码区域的注释，因为代码不完整或不正确，或为了在调试时隔离问题，或作为正在进行的更改的参考材料。通常认为将这样的注释加入版本控制是不良实践。 1.1 背景 在C++中，实际上有三种不同的方式来表示注释：\n1.1.1 行注释 在C++中，单行注释（有时是多行注释）使用// ...表示：\n1 2 // 下一行声明了一个变量。 int n; // 这是关于\u0026#39;n\u0026#39;的注释。 (这些有时被称为\u0026quot;BCPL注释\u0026quot;。)\n可以出现在任何地方（在一行的开头或在标记后）。 可以包含任何文本（除了换行符）。 在逻辑行的末尾结束。 通过在注释末尾添加\\（或在C++14及更早版本中的??/）来继续。 与非注释语法无歧义。 \u0026ldquo;嵌套\u0026rdquo;，即//内的//无效。 不与其他类型的注释嵌套。 这种注释语法经常用来表示文档（有时使用Doxygen风格的///引入符）和实现注释。\n1.1.2 块注释 在C++中，行内注释（有时是多行注释）使用/*...*/表示：\n1 f(/*size*/5, /*initial value*/1); 可以出现在任何地方（在一行的开头或在标记后）。 可以包含任何文本（除了*/）。 在*/分隔符处结束（该分隔符可能由\\行继续分隔）。 与非注释语法有歧义：int a=1, *b=\u0026amp;a, c=a/*b;，尽管这在实践中不是问题。 不嵌套——第一个*/结束了注释。 这种注释语法经常用来表示语法消歧注释，并有时用于禁用的代码。某些编码风格还使用这种注释风格来表示较长的文档注释（有时使用Doxygen风格的/**引入符）。\n1.1.3 #if 0 在C++程序中，代码块经常使用#if 0注释掉：\n1 2 3 #if 0 int n; #endif 只能出现在逻辑行的开头。 只能包含预处理标记序列（包括无效标记，如'，但不包括未终止的多行字符串字面量）。 在匹配的#endif分隔符处结束。 与任何其他语法无歧义。 嵌套得当，并且可以在其中嵌套其他种类的注释。 这种语法通常只用于禁用的代码。\n1.2 详细内容 1.2.1 注释概述 _注释_是一个词法元素，以//字符开始并运行到行的末尾。我们没有物理行继续的机制，所以尾随的\\不会将注释扩展到后续的行。\n试验: 在引入注释的//字符之前不能有其他文本，除了水平空白。要么整行都是注释，要么一点也不是。\n//后的字符必须是一个空白字符。换行符是一个空白字符，所以只包含//的行是一个有效的注释。文件的结尾也构成空白。\n在形成标记之前，所有注释都被删除。\n示例：\n1 2 3 4 // 这是一个注释，会被忽略。\\ 这不是一个注释。 var Int: x; // 错误，不允许尾随注释 1.2.2 块注释 试验: 不提供块注释的支持。通过注释掉区域中的每一行来注释掉大量的人类可读的文本或代码。\n块注释的理由 对于实现注释的用例，支持块注释的价值不大。我们期望这样的注释通常很短，而在现有的C++代码库中，如果有长的实现注释，通常使用的是行注释而不是块注释。因此，由于我们认为文档用例超出了范围，并且打算通过语言语法解决语法消歧用例，块注释的唯一目的就是禁用代码。块注释可以为行内禁用的代码和多行禁用的代码提供更方便的支持。\n现有的块注释语法不适合禁用代码的用例。C++中的/* ... */块注释不嵌套，并且不能用于可靠地注释掉一个代码块，因为它可以被//注释或字符串字面量中的*/终止。#if 0 ... #endif语法不适合Carbon，因为我们不打算通常有一个预处理器，而且需要文本之间的内容由大部分有效的标记序列组成，不允许某些形式的不完整代码。\n我们应该不情愿地发明新东西：为了禁用代码的短暂和罕见的用例，很难证明引入新的语法的成本是合理的。同样，我们应该不情愿地使用现有的语法与新的语义，如一个/* ... */注释，它标记其内容，以避免对C++开发者的惊讶。\n禁用代码的用例可以用行注释来解决，通过注释掉预期区域中的每一行，并在禁用行内的代码时重新排列或复制行。这可能很麻烦，但不清楚这种负担是否足以证明将另一种形式的注释引入到语言中。通过不提供这样的注释形式，我们的目标是发现结果摩擦是否证明了语言的增加。\n1.2.3 保留的注释 //字符后面不跟随空白的注释是为未来的扩展保留的。预期的可能的扩展是块注释、文档注释和代码折叠区域标记。\n保留的注释的理由 我们预期将来可能会增加其他种类的注释。在注释语法中保留语法空间，以便程序容易避免，允许我们将这样的额外注释作为非破坏性的变更添加。\n1.3 考虑的替代方案 1.3.1 行内注释 我们可以包括一个类似于C风格块注释的功能，作为提供附加到小于一行的程序元素的注释的方式。在C++代码中，这样的注释经常用于注释函数参数名称和类似的语法消歧用例：\n1 render(/*use_world_coords=*/true, /*draw_frame=*/false); 我们期望这些用例将由Carbon的语法扩展来解决，例如通过添加命名参数或注释语法，以允许这样的话语以代码而不是注释的形式表示，所以它们对Carbon程序员和Carbon语言工具都是有意义的。\n我们可以允许在包含其他内容的行上的尾部注释。这样的注释在我们的样本C++语料库中经常用于描述同一行上的实体、标签或闭合括号的含义：\n1 2 3 4 5 6 7 namespace N { int n; // number of hats enum Mode { mode1, // first mode mode2 // second mode }; } // end namespace N 除了最后一种情况，我们期望将注释移到声明之前是合理的。\u0026ldquo;end namespace\u0026quot;注释的情况是另一个语法消歧用例，我们期望通过语法更改来解决。总的来说，我们应该避免任何需要消歧注释的语法，要么通过将这些注释提升到语言语法，要么通过更改语法直到注释不再需要，例如不为描述命名空间和包的内容的大范围提供一个分隔的范围语法。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 这声明了命名空间N，但没有打开一个范围。 namespace N; // 这声明了命名空间N的一个成员。 @\u0026#34;Number of hats.\u0026#34; var Int: N.n; enum N.Mode { @\u0026#34;First mode.\u0026#34; mode1; @\u0026#34;Second mode.\u0026#34; mode2; } 行内注释对于代码格式化工具来说是一个挑战，它们需要理解注释\u0026quot;附加到\u0026quot;什么程序语法上，以便正确地将注释与代码重新排列。这种关注通过要求注释始终在自己的行上被缓解，但并没有完全消除。我们可以通过使用方向标记在注释中来允许行内注释，同时仍然保留一些关于注释如何附加的想法：\n1 2 3 4 match (x) { case .Foo(1, 2, //\u0026gt; either 3 or 4 \u0026gt;// Int: n) =\u0026gt; { ... } case .Foo(2, Int: n //\u0026lt; either 3 or 4 \u0026lt;//, 5) =\u0026gt; { ... } } 即使有了理解注释如何附加的方法，行包装这样的注释也是一个复杂的挑战。例如，在多行上有对齐的尾部注释的情况下，格式化需要特殊处理：\n1 2 3 var Int: quality = 3; // The quality of the widget. It should always // be between 1 and 9. var Int: blueness = 72; // The blueness of the widget, as a percentage. 在这里，一个将blueness重命名为blue_percent的工具可能需要重新排列quality后面的注释以及blueness后面的注释。此外，如果最后一行变得太长，保持注释与变量在同一行可能变得不可行，需要更实质性的重写：\n1 2 // The blueness of the widget, as a percentage. var Int: blue_percent = Floor(ComputeBluenessRatio() * 100); 不支持尾随和行内注释的决定是试验性的，如果我们发现在完整的语言设计的背景下需要这样的注释，应该重新考虑。\n1.3.2 多行文本注释 不提供多行文本注释的支持。相反，这样的注释是通过在每行前加上相同的// 注释标记来表示的。\n要求每行重复注释标记将提高可读性，通过消除非本地状态的来源，并消除了不必要的和不有帮助的注释语法的变化。这种注释的风格在其他语言中很常见，并且得到了编辑器的很好支持。即使在使用/* ... */来注释掉人类可读的文本块的C和C++代码中，也通常在\n每行前加上*或其他标记，以使注释更容易阅读。\n1.3.3 块注释 我们考虑了各种不同的块注释选项。我们的主要目标是允许注释掉大量的Carbon代码，这些代码可能是或可能不是格式良好的（包括包含块注释的代码，这意味着这样的注释需要嵌套）。考虑的替代方案包括：\n完全基于行的块注释，它会删除行，而不考虑它们是否嵌套在字符串字面量中，具有新颖的特性，允许注释掉块字符串字面量的部分内容。这种替代方案的缺点是它会在包含Carbon代码的字符串字面量内部产生令人惊讶的行为。\n完全词法化的块注释，其中开头和结尾注释标记之间的令牌序列会被生成并丢弃，词法规则稍微放宽，以避免拒绝格式不良的代码。这将类似于C和C++的#if 0 \u0026hellip; #endif。这种替代方案的缺点是它无法处理不完整的代码片段，如未终止的块字符串字面量。与非词法化语法相比，处理起来也会有些低效，但考虑到块注释预期是短暂的，这可能在很大程度上是不相关的。\n一种混合方法，使用//\\{和//\\}作为定界符，这些定界符在非原始字符串字面量中是无效的，并且只对原始字符串字面量有缩进要求。这种替代方案的缺点是它在词法规则中引入了额外的复杂性，通过不同地对待不同种类的字符串字面量。\n使用/*和*/作为注释标记。这种替代方案的缺点是它使用与C和C++相似的语法，但语义有所不同，从而增加了混淆的风险。\n然而，考虑到这种注释的有限用例和我们希望最小化我们的创新性，我们在这个提议中没有追求这些选项。\n1.3.4 文档注释 我们可以为文档注释添加一个不同的注释语法，也许将文档注释视为产生真实令牌，而不是由词法分析器剥离。但是，在讨论中，有很大的支持使用不像注释的语法来表示文档。例如，我们可以引入一个属性语法，如使用@ \u0026lt;expression\u0026gt;作为声明的前缀来附加属性。然后，可以将字符串字面量属性视为文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @\u0026#34;Get the size of the thing.\u0026#34; fn GetThingSize() -\u0026gt; Int; @\u0026#34;\u0026#34;\u0026#34; Rate the quality of the widget. Returns a quality factor between 0.0 and 1.0. \u0026#34;\u0026#34;\u0026#34; fn RateQuality( @\u0026#34;The widget to rate.\u0026#34; Widget: w, @\u0026#34;A widget quality database.\u0026#34; QualityDB: db) -\u0026gt; Float; 这个用例将由未来的提议来探索。\n1.3.5 代码折叠注释 一些代码编辑器能够“折叠”源文件的区域，以便于导航。在某些情况下，这些折叠区域可以通过使用注释行来定制。例如，在VS Code中，这是通过包含#region和#endregion的注释来实现的：\n1 2 3 4 // #region 函数 F 和 G fn f() { ... } fn g() { ... } // #endregion 支持这样的标记作为行注释中的正常文本不需要额外的努力。然而，我们可以考虑引入一个特定的Carbon语法用于区域注释，以鼓励在代码编辑器之间使用通用的表示。这个提议没有涵盖这样的支持，但可以通过一种新形式的注释来处理。\n1.4 语言设计 carbon只提供一种注释，它以//开始并运行到行的末尾。在同一行上的注释之前不允许有代码，且引入注释的//后必须跟随空白。\n我们选择了这种注释语法，因为它简单、易于理解、易于实现、易于编辑、易于格式化，并且与其他语言的注释语法相似。\n","permalink":"https://canftin.github.io/posts/tech/p5_compiler_build_4_lang_design/","summary":"1. 注释 在现有的编程语言中，注释有多种用途。主要的用例包括： 文档：为API的用户和未来的维护者提供人类可读的注释，解释其功能以及如何使用它。这","title":"从零构造现代语言编译器(4): 语言设计"},{"content":"1. 什么是诊断 诊断信息（Diagnostics）在编程语言中，通常是编译器用来告诉程序员源代码中存在的问题的消息。这些问题可能包括语法错误、类型错误、未定义的符号、可能的运行时错误等。每种编译器都有自己的方式来显示这些信息。\nGCC（GNU Compiler Collection）：GCC是一个开源的编译器套件，支持C、C++、Java、Fortran等多种语言。当GCC遇到错误时，它会输出错误信息，包含了错误的类型、发生错误的源文件和行号，以及可能的原因。例如：\n1 2 3 4 test.c: In function \u0026#39;main\u0026#39;: test.c:2:5: error: \u0026#39;printf\u0026#39; undeclared (first use in this function) printf(\u0026#34;Hello, World!\\n\u0026#34;); ^~~~~~ 这个错误信息告诉我们在test.c文件的main函数中，第2行第5个字符处使用了未声明的printf（应该是printf）。\nClang：Clang是一个编译器前端，支持C语言、C++、Objective-C和Objective-C++编程语言。Clang的诊断信息相比GCC更为友好和详细，它会以易于理解的方式提供错误的上下文和修复建议。例如：\n1 2 3 4 test.cpp:1:1: error: C++ requires a type specifier for all declarations \u0026#34;Test\u0026#34; ^~~~ int 这个错误信息告诉我们在test.cpp文件的第1行第1个字符处缺少类型说明符，并建议添加int。\nRust：Rust是一种系统编程语言，注重安全、并发和内存效率。Rust编译器的诊断信息非常友好，包含了错误类型、发生错误的源文件和行号、错误的代码片段以及可能的解决方法。例如：\n1 2 3 4 5 error[E0425]: cannot find value `foo` in this scope --\u0026gt; main.rs:2:5 | 2 | foo; | ^^^ not found in this scope 这个错误信息告诉我们在main.rs文件的第2行第5个字符处找不到foo这个值。\n以上都是简单的例子，实际的诊断信息可能会更复杂，包含更多的上下文和建议。\n2. 诊断信息有哪些 Carbon定义了一系列诊断信息，用于在编译或运行时报告错误、警告或其他信息。这些诊断信息通常用于编译器、解释器或其他代码分析工具。诊断信息被分为几个不同的类别：\n1. SourceBuffer diagnostics（源缓冲区诊断） ErrorOpeningFile: 打开文件时出错。 ErrorStattingFile: 获取文件状态时出错。 FileTooLarge: 文件太大。 ErrorReadingFile: 读取文件时出错。 2. Lexer diagnostics（词法分析器诊断） 这部分包含了与词法分析有关的诊断信息，例如无效的数字、字符串未终止等。\nBinaryRealLiteral: 二进制实数字面量有问题，可能是格式错误。 ContentBeforeStringTerminator: 在字符串终结符之前有额外的内容。 DecimalEscapeSequence: 十进制转义序列有问题，可能是格式或值错误。 EmptyDigitSequence: 数字序列为空，例如在一个预期应有数字的地方什么都没有。 HexadecimalEscapeMissingDigits: 十六进制转义序列缺少必需的数字。 InvalidDigit: 无效的数字字符，例如在十进制数中出现了非0-9的字符。 InvalidDigitSeparator: 无效的数字分隔符，例如在数字中使用了不允许的字符作为分隔符。 InvalidHorizontalWhitespaceInString: 在字符串中有无效的水平空白字符。 IrregularDigitSeparators: 数字分隔符使用不规范，例如两个分隔符连续出现。 MismatchedClosing: 不匹配的关闭符号，例如一个括号或引号没有与之匹配的开始符号。 MismatchedIndentInString: 在多行字符串中，缩进不匹配。 MultiLineStringWithDoubleQuotes: 使用双引号在多行字符串中可能是不允许的。 NoWhitespaceAfterCommentIntroducer: 注释引导符（如//或/*）后面没有空白。 TooManyDigits: 数字含有太多的位数，超出了处理能力。 TrailingComment: 有尾随的注释，可能是在不应该出现注释的地方出现了注释。 UnicodeEscapeMissingBracedDigits: Unicode转义序列缺少必需的括在大括号里的数字。 UnicodeEscapeSurrogate: Unicode转义序列是一个代理项，这可能是不允许的。 UnicodeEscapeTooLarge: Unicode转义序列中的值太大。 UnknownBaseSpecifier: 未知的基数说明符，例如在数字前面有一个未知的前缀。 UnknownEscapeSequence: 未知的转义序列，例如\\z。 UnmatchedClosing: 有一个不匹配的关闭符号，没有与之匹配的开始符号。 UnrecognizedCharacters: 有无法识别的字符。 UnterminatedString: 字符串没有正确终止，缺少结束引号。 WrongRealLiteralExponent: 实数字面量的指数部分有误。 3. Parser diagnostics（语法分析器诊断） BinaryOperatorRequiresWhitespace: 二元运算符两侧需要空白字符。 ExpectedArraySemi: 期望在数组定义或初始化中看到一个分号。 ExpectedCloseSymbol: 期望一个关闭符号，如闭括号或闭花括号。 ExpectedCodeBlock: 期望一个代码块，通常由花括号包围。 ExpectedExpression: 期望一个表达式。 ExpectedIdentifierAfterDotOrArrow: 在.或-\u0026gt;后期望一个标识符。 ExpectedParameterName: 期望一个参数名。 ExpectedParenAfter: 在某个元素后期望一个括号。 ExpectedExpressionSemi: 在表达式后期望一个分号。 ExpectedStatementSemi: 在语句后期望一个分号。 ExpectedStructLiteralField: 期望一个结构体字面量字段。 ExpectedVariableDeclaration: 期望一个变量声明。 ExpectedVariableName: 期望一个变量名。 OperatorRequiresParentheses: 运算符需要括号。 StatementOperatorAsSubexpression: 语句运算符用作子表达式。 UnaryOperatorRequiresParentheses: 一元运算符需要括号。 UnaryOperatorHasWhitespace: 一元运算符后有空白。 UnaryOperatorRequiresWhitespace: 一元运算符需要空白。 UnexpectedTokenAfterListElement: 列表元素后出现意外的令牌。 UnrecognizedDeclaration: 无法识别的声明。 包相关诊断（Package-related diagnostics）\nExpectedIdentifierAfterPackage: 在package关键字后期望一个标识符。 ExpectedLibraryName: 期望一个库名。 MissingLibraryKeyword: 缺少library关键字。 ExpectedApiOrImpl: 期望api或impl。 For循环特定诊断（For-specific diagnostics）\nExpectedIn: 在for循环中期望in关键字。 ExpectedInNotColon: 期望in而不是冒号。 If条件特定诊断（If-specific diagnostics）\nExpectedThenAfterIf: 在if后期望then。 ExpectedElseAfterIf: 在if后期望else。 声明诊断（Declaration diagnostics）\nExpectedDeclarationName: 期望一个声明名。 ExpectedDeclarationSemi: 在声明后期望一个分号。 ExpectedDeclarationSemiOrDefinition: 在声明后期望一个分号或定义。 MethodImplNotAllowed: 方法实现不允许。 ParametersRequiredByIntroducer: 引入者需要参数。 ParametersRequiredByDeduced: 由推导出的类型需要参数。 4. Semantics diagnostics（语义诊断） 这部分包含了与代码语义有关的诊断信息，例如类型不匹配、数组越界等。\n这些都是用于在语义分析阶段报告各种类型的错误或警告的诊断标识符。语义分析通常涉及类型检查、作用域解析等。下面是对每个标识符可能代表的含义的解释：\nSemanticsTodo: 一个占位符，用于标记尚未实现的语义检查。 AddressOfEphemeralReference: 尝试获取短暂引用（例如，函数返回值）的地址。 AddressOfNonReference: 尝试获取非引用类型的地址。 ArrayInitFromLiteralArgCountMismatch: 数组从字面量初始化时，参数数量不匹配。 ArrayInitFromExpressionArgCountMismatch: 数组从表达式初始化时，参数数量不匹配。 AssignmentToNonAssignable: 尝试给不可赋值的对象（例如，常量或表达式）赋值。 DereferenceOfNonPointer: 尝试解引用非指针类型。 DereferenceOfType: 尝试解引用一个类型（而不是变量或表达式）。 NameNotFound: 找不到指定的名称（变量、函数等）。 NameDeclarationDuplicate: 名称声明重复。 NameDeclarationPrevious: 名称在之前已经被声明。 CallArgCountMismatch: 函数调用的参数数量不匹配。 InCallToFunction: 在对函数的调用中有问题。 InCallToFunctionParam: 在对函数参数的处理中有问题。 MissingReturnStatement: 缺少返回语句。 RepeatedConst: const关键字被重复使用。 InvalidArrayExpression: 无效的数组表达式。 TypeNotIndexable: 尝试索引一个不可索引的类型。 IndexOutOfBounds: 数组或其他可索引对象的索引越界。 TupleIndexIntegerLiteral: 元组索引必须是整数字面量。 ReturnStatementDisallowExpression: 返回语句中不允许有表达式。 ReturnStatementImplicitNote: 返回语句有隐式的注意事项（可能是类型推断或其他）。 ReturnStatementMissingExpression: 返回语句缺少表达式。 ImplicitAsConversionFailure: 隐式转换失败。 QualifiedDeclarationInNonScope: 在非作用域内有限定声明。 QualifiedDeclarationNonScopeEntity: 限定声明不是作用域实体。 QualifiedExpressionUnsupported: 不支持限定表达式。 QualifiedExpressionNameNotFound: 限定表达式中找不到名称。 UseOfNonExpressionAsValue: 尝试将非表达式用作值。 5. Other diagnostics（其他诊断） COCKTAIL_DIAGNOSTIC_KIND(TestDiagnostic): 仅用于单元测试的诊断。 COCKTAIL_DIAGNOSTIC_KIND(TestDiagnosticNote): 仅用于单元测试的诊断注释。 3. 诊断信息模块构建 责任链模式\n","permalink":"https://canftin.github.io/posts/tech/p4_compiler_build_3_diagnostics/","summary":"1. 什么是诊断 诊断信息（Diagnostics）在编程语言中，通常是编译器用来告诉程序员源代码中存在的问题的消息。这些问题可能包括语法错误、类","title":"从零构造现代语言编译器(3): 诊断信息"},{"content":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做对比分析。\n1. 流 引入工具基类Printable如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /// CRTP基类，用于打印类型，子类必须实现Print接口： /// - auto Print(llvm::raw_ostream\u0026amp; out) -\u0026gt; void; template \u0026lt;typename DerivedT\u0026gt; class Printable { /// 提供给debugger的简单接口， /// `LLVM_DUMP_METHOD` 宏确保只有在调试构建中才会包含这个方法。 LLVM_DUMP_METHOD void Dump() const { static_cast\u0026lt;const DerivedT*\u0026gt;(this)-\u0026gt;Print(llvm::errs()); } /// llvm::raw_ostream输出。 friend auto operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; llvm::raw_ostream\u0026amp; { obj.Print(out); return out; } /// std::ostream输出。 friend auto operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; std::ostream\u0026amp; { llvm::raw_os_ostream raw_os(out); obj.Print(raw_os); return out; } friend auto PrintTo(DerivedT* p, std::ostream* out) -\u0026gt; void { *out \u0026lt;\u0026lt; static_cast\u0026lt;const void*\u0026gt;(p); if (p) { *out \u0026lt;\u0026lt; \u0026#34; pointing to \u0026#34; \u0026lt;\u0026lt; *p; } } }; 这里的Printable类被设计为一个基类，用于实现可打印的对象，它期望子类实现一个Print接口。\n1.1 Printable类的用途和功能 类型打印: 通过Print接口，子类可以自定义如何将其内容打印到输出流。 多种输出流支持: 支持llvm::raw_ostream和std::ostream两种输出流。 调试支持: 提供了一个Dump方法，用于在调试时快速查看对象的状态。 假设有一个Person类，我们希望能够打印其信息：\n1 2 3 4 5 6 7 8 9 10 class Person : public Printable\u0026lt;Person\u0026gt; { public: Person(std::string name, int age) : name(name), age(age) {} void Print(llvm::raw_ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;Person { name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; }\u0026#34;; } private: std::string name; int age; } 现在，Person类就可以使用Printable提供的所有功能。\n1 2 3 Person p(\u0026#34;Alice\u0026#34;, 30); llvm::raw_ostream\u0026amp; os = llvm::outs(); os \u0026lt;\u0026lt; p; // 输出：Person { name: Alice, age: 30 } 1.2 介绍CRTP和Mixin CRTP是C++中一种常用的编程模式，全名为“Curiously Recurring Template Pattern”，中文可以翻译为“奇异递归模板模式”。这个模式主要用于实现编译时多态性，也就是在编译时解析多态行为，而不是运行时。\n编译时多态: 由于多态行为在编译时就被解析，因此运行时性能开销小。 代码复用: 可以在基类中实现通用逻辑，减少代码重复。 类型安全: 使用static_cast进行类型转换是安全的，因为基类知道派生类的确切类型。 不适用于运行时多态: CRTP无法实现运行时多态，因为它依赖于编译时类型信息。 代码可读性: 对于不熟悉CRTP的开发者来说，代码可能会显得有些复杂。 在CRTP中，一个模板基类会以其派生类作为模板参数。这样，基类就可以在编译时知道其派生类的类型，基类就可以调用派生类的方法或访问其成员，即使这些方法或成员在基类中并没有被声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实际的实现 } }; 在这个例子中，Base类有一个interface方法，它内部调用了implementation方法。这个implementation方法是在Derived类中定义的，但Base类可以通过static_cast安全地调用它。\nCRTP常用于以下几种场景：\n静态多态: 如上面的例子所示，可以用于实现编译时多态。 Mixin 类: 可以用CRTP实现mixin（混入）功能，即在一个类中混入另一个类的功能。 工具类: 如在问题中的Printable类，用于提供一组通用的接口或实现。 总体来说，CRTP是一种非常强大而灵活的编程模式，尤其适用于需要高性能和代码复用的场景。\nMixin 功能 在 C++ 中，Mixin 是一种编程模式，用于通过组合而非继承来向一个类添加额外的功能或行为。Mixin 类通常是一些小型、可复用的组件，它们定义了特定的行为或功能，但不应该单独使用。通过将多个 Mixin 类组合在一起，你可以创建出具有多种功能的复杂对象。\nMixin 通常与模板编程和多重继承一起使用，以实现更高的灵活性和代码复用。\n假设你有一个 LoggerMixin 类，它提供了日志功能。\n1 2 3 4 5 6 class LoggerMixin { public: void log(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;[LOG]: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; 再假设你有一个 TimerMixin 类，用于计算代码执行时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;chrono\u0026gt; class TimerMixin { public: void startTimer() { start = std::chrono::high_resolution_clock::now(); } void stopTimer() { auto stop = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(stop - start); std::cout \u0026lt;\u0026lt; \u0026#34;Time taken: \u0026#34; \u0026lt;\u0026lt; duration.count() \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; }; 现在，你可以创建一个新类，通过多重继承来组合这两个 Mixin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass : public LoggerMixin, public TimerMixin { public: void doSomething() { log(\u0026#34;Starting operation...\u0026#34;); startTimer(); // 执行一些操作 // ... stopTimer(); log(\u0026#34;Operation completed.\u0026#34;); } }; 使用：\n1 2 3 4 5 int main() { MyClass obj; obj.doSomething(); return 0; } 这样，MyClass 就继承了 LoggerMixin 和 TimerMixin 的所有功能，而你不需要在 MyClass 中重新实现这些功能。\n代码复用: 你可以在多个类中重用同一个 Mixin。 解耦: Mixin 使得功能模块与业务逻辑解耦，更易于维护和扩展。 灵活性: 你可以灵活地组合多个 Mixin，以创建具有所需功能的新类。 复杂性: 使用多重继承和模板可能会增加代码复杂性。 名称冲突: 如果两个 Mixin 有相同的成员，可能会导致名称冲突。 1.3 LLVM输出流重载 LLVM是一个编译器基础设施项目，提供了一系列模块化的编译器组件和工具链。它用于开发编译器前端和后端，以及其他代码转换和代码生成工具。其中llvm::raw_ostream是llvm上的原始输出流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace llvm { /// 注入一个 `operator\u0026lt;\u0026lt;` 重载到 llvm 命名空间， /// 将 LLVM 类型的 `raw_ostream` 重载映射到 `std::ostream` 重载。 template \u0026lt;typename StreamT, typename ClassT, typename = std::enable_if_t\u0026lt; std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;, typename = std::enable_if_t\u0026lt; !std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt;\u0026gt; auto operator\u0026lt;\u0026lt;(StreamT\u0026amp; standard_out, const ClassT\u0026amp; value) -\u0026gt; StreamT\u0026amp; { raw_os_ostream(standard_out) \u0026lt;\u0026lt; value; return standard_out; } } // namespace llvm 这段代码定义了一个模板函数 operator\u0026lt;\u0026lt;，该函数重载了流插入运算符 \u0026lt;\u0026lt;。这个重载函数位于 llvm 命名空间中，并且是为了将 LLVM 的 raw_ostream 类型的重载映射到 C++ 标准库的 std::ostream 类型。其中 StreamT 代表流类型，通常是 std::ostream 或其派生类，ClassT 代表要输出的类的类型。\nstd::enable_if_t\u0026lt;std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;: 这个条件使用SFINAE（替换失败不是错误）确保 StreamT 是 std::ostream 的基类或者就是 std::ostream 本身。\nstd::enable_if_t\u0026lt;!std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt; 这个条件确保 ClassT 不是 raw_ostream 类型。\nraw_os_ostream(standard_out) \u0026lt;\u0026lt; value; 这里创建了一个 raw_os_ostream 对象，该对象是 LLVM 提供的一个流类，用于将 std::ostream 包装成 raw_ostream。然后，使用 raw_ostream 的 \u0026lt;\u0026lt; 运算符将 value 输出到这个流中。\n这样做的目的是利用 LLVM 已经为 raw_ostream 定义的 \u0026lt;\u0026lt; 运算符重载。这样，任何能够通过 raw_ostream 输出的 ClassT 类型都可以通过这个新的 \u0026lt;\u0026lt; 运算符重载输出到 std::ostream。\nreturn standard_out; 最后，函数返回传入的 std::ostream 引用，以支持链式调用。\n假设 LLVM 已经为一个名为 MyLLVMClass 的类定义了如下的 \u0026lt;\u0026lt; 运算符重载：\n1 2 3 4 llvm::raw_ostream\u0026amp; operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const MyLLVMClass\u0026amp; obj) { // ... 输出逻辑 return out; } 现在，你可以这样使用新的 \u0026lt;\u0026lt; 运算符重载：\n1 std::cout \u0026lt;\u0026lt; MyLLVMClassInstance; // 这里会调用上面定义的 operator\u0026lt;\u0026lt; 这样，MyLLVMClassInstance 就会被正确地输出到 std::cout，而这一切都是通过 LLVM 的 raw_ostream 完成的。\n总结一下，这段代码的主要目的是为了提供一种机制，使得任何可以通过 LLVM 的 raw_ostream 输出的对象都可以直接通过 C++ 的 std::ostream 输出，从而实现两者之间的重载映射。这样做提高了代码的可复用性和一致性。\n2. EnumBase枚举模版类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// 用CRTP以及X-Macro来生成枚举类的模板类。 template \u0026lt;typename DerivedT, typename EnumT, const llvm::StringLiteral Names[]\u0026gt; class EnumBase : public Printable\u0026lt;DerivedT\u0026gt; { public: using RawEnumType = EnumT; // 用于定义原始的模版类型。 using EnumType = DerivedT; // 派生的枚举类型。 using UnderlyingType = std::underlying_type_t\u0026lt;RawEnumType\u0026gt;; // 原始枚举类型的底层类型。 /// 允许将枚举类转换为原始的枚举类型， constexpr operator RawEnumType() const { return value_; } explicit operator bool() const = delete; /// 返回枚举的名称。 [[nodiscard]] auto name() const -\u0026gt; llvm::StringRef { return Names[AsInt()]; } /// 打印名称，使用于Printable，必须实现。 auto Print(llvm::raw_ostream\u0026amp; out) const -\u0026gt; void { out \u0026lt;\u0026lt; name(); } protected: constexpr EnumBase() = default; /// 从原始枚举器创建类型。 static constexpr auto Create(RawEnumType value) -\u0026gt; EnumType { EnumType result; result.value_ = value; return result; } /// 转换为整数类型。 constexpr auto AsInt() const -\u0026gt; UnderlyingType { return static_cast\u0026lt;UnderlyingType\u0026gt;(value_); } /// 从底层整数类型转换为枚举类型。 static constexpr auto FromInt(UnderlyingType value) -\u0026gt; EnumType { return Create(static_cast\u0026lt;RawEnumType\u0026gt;(value)); } private: RawEnumType value_; }; 这段代码定义了一个用于生成枚举类的模板类 EnumBase，以及一系列用于辅助生成枚举类的宏。这个模板类和宏的组合提供了一种灵活、可复用的方式来创建和操作枚举类。它的设计目的：\n类型安全: 通过使用强类型的枚举（enum class），提供更好的类型安全。 可打印: 通过继承以上的 Printable，使得枚举值可以被打印。 名称获取: 提供了一个 name() 方法，用于获取枚举值的名称。 2.1 主要宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 创造原始枚举类（不涉及名称）。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) \\ namespace Internal { \\ enum class EnumClassName##RawEnum : UnderlyingType; \\ } \\ enum class Internal::EnumClassName##RawEnum : UnderlyingType // 创造原始枚举类。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS(EnumClassName, UnderlyingType) \\ namespace Internal { \\ extern const llvm::StringLiteral EnumClassName##Names[]; \\ } \\ COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) // 在原始枚举类的定义中生成每个枚举值。 #define COCKTAIL_RAW_ENUM_ENUMERATOR(Name) Name, #define COCKTAIL_ENUM_BASE(EnumClassName) \\ COCKTAIL_ENUM_BASE_CRTP(EnumClassName, EnumClassName, EnumClassName) #define COCKTAIL_ENUM_BASE_CRTP(EnumClassName, LocalTypeNameForEnumClass, \\ EnumClassNameForNames) \\ ::Cocktail::Internal::EnumBase\u0026lt;LocalTypeNameForEnumClass, \\ Internal::EnumClassName##RawEnum, \\ Internal::EnumClassNameForNames##Names\u0026gt; // 枚举类体内生成每个值的命名常量声明。 #define COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) static const EnumType Name; // 枚举类体外定义每个命名常量。 #define COCKTAIL_ENUM_CONSTANT_DEFINITION(EnumClassName, Name) \\ constexpr EnumClassName EnumClassName::Name = \\ EnumClassName::Create(RawEnumType::Name); #define COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION(Name) \\ static constexpr const typename Base::EnumType\u0026amp; Name = \\ Base::Create(Base::RawEnumType::Name); // 在 `.cc` 文件中为枚举类开始定义每个枚举器的常量名数组。 #define COCKTAIL_DEFINE_ENUM_CLASS_NAMES(EnumClassName) \\ constexpr llvm::StringLiteral Internal::EnumClassName##Names[] #define COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #Name, COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES: 定义一个没有名称数组的原始枚举类。 COCKTAIL_DEFINE_RAW_ENUM_CLASS: 定义一个有名称数组的原始枚举类。 COCKTAIL_RAW_ENUM_ENUMERATOR: 在原始枚举类定义中生成每个枚举值。 COCKTAIL_ENUM_BASE: 生成用于派生的 EnumBase 类型。 COCKTAIL_ENUM_CONSTANT_DECLARATION: 在枚举类体内生成每个值的命名常量声明。 COCKTAIL_ENUM_CONSTANT_DEFINITION: 在枚举类体外定义每个命名常量。 COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION: 用于内联定义每个命名常量。 COCKTAIL_DEFINE_ENUM_CLASS_NAMES: 在 .cc 文件中为枚举类开始定义每个枚举器的常量名数组。 COCKTAIL_ENUM_CLASS_NAME_STRING: 用于生成枚举值名称的字符串。 这个 EnumBase 类和相关的宏提供了一种高度可定制和可复用的方式来创建和操作枚举类。它们解决了类型安全、可打印性和名称获取等常见问题，同时也提供了一种简洁、一致的方式来定义和使用枚举类。这样的设计非常适用于大型项目中，特别是那些需要多次定义和使用不同枚举类的项目。\n2.2 什么是X-Macro X-Macro 是一种 C 和 C++ 预处理器技术，用于生成重复或模式化的代码。这种技术通过定义宏来实现，这些宏在不同的上下文中被多次展开，以生成不同的代码片段。X-Macro 主要用于减少代码重复，提高代码的可维护性。\n一个典型的 X-Macro 的使用方式是定义一个宏，该宏接受一个或多个参数，并在不同的上下文中多次展开。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define COLOR_XMACRO \\ X(Red) \\ X(Green) \\ X(Blue) // 定义枚举 enum Color { #define X(name) name, COLOR_XMACRO #undef X }; // 定义字符串数组 const char* ColorNames[] = { #define X(name) #name, COLOR_XMACRO #undef X }; 在这个例子中，COLOR_XMACRO 宏定义了一个颜色列表。然后，通过在不同的上下文中展开 X 宏，我们生成了一个 Color 枚举和一个 ColorNames 字符串数组。\nX-Macro 也可以用于更复杂的代码生成任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define PERSON_XMACRO \\ X(std::string, Name) \\ X(int, Age) \\ X(double, Height) // 定义结构体 struct Person { #define X(type, name) type name; PERSON_XMACRO #undef X }; // 序列化函数 std::string Serialize(const Person\u0026amp; p) { std::string result; #define X(type, name) result += std::to_string(p.name) + \u0026#34; \u0026#34;; PERSON_XMACRO #undef X return result; } // 反序列化函数（简化版） void Deserialize(Person\u0026amp; p, const std::string\u0026amp; s) { std::istringstream iss(s); #define X(type, name) iss \u0026gt;\u0026gt; p.name; PERSON_XMACRO #undef X } 在这个例子中，PERSON_XMACRO 定义了一个 Person 结构体的字段。然后，我们生成了该结构体的定义以及其序列化和反序列化函数。\n减少代码重复: 通过在多个地方展开相同的宏，减少了代码重复。 提高可维护性: 如果需要添加、删除或修改某个元素，只需在一个地方进行更改。 灵活性: 可以在不同的上下文中以不同的方式展开相同的宏。 可读性: 对于不熟悉 X-Macro 的人来说，代码可能难以理解。 调试困难: 预处理器生成的代码可能难以调试。 总体来说，X-Macro 是一种非常强大的代码生成技术，尤其适用于需要生成重复或模式化代码的场景。然而，它也有一些缺点，如可能降低代码的可读性和可调试性。因此，在使用 X-Macro 时，应权衡其优缺点。\n2.3 TokenKind实际使用 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #ifndef COCKTAIL_ENUM_BASE_TEST_KIND #error \u0026#34;Must define the x-macro to use this file.\u0026#34; #endif COCKTAIL_ENUM_BASE_TEST_KIND(Beep) COCKTAIL_ENUM_BASE_TEST_KIND(Boop) COCKTAIL_ENUM_BASE_TEST_KIND(Burr) #undef COCKTAIL_ENUM_BASE_TEST_KIND COCKTAIL_DEFINE_RAW_ENUM_CLASS(TestKind, uint8_t) { #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) COCKTAIL_RAW_ENUM_ENUMERATOR(Name) #include \u0026#34;EnumBase.t.def\u0026#34; }; class TestKind : public COCKTAIL_ENUM_BASE(TestKind) { public: #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) \\ COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) #include \u0026#34;EnumBase.t.def\u0026#34; using EnumBase::AsInt; using EnumBase::FromInt; }; #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) \\ COCKTAIL_ENUM_CONSTANT_DEFINITION(TestKind, Name) #include \u0026#34;EnumBase.t.def\u0026#34; COCKTAIL_DEFINE_ENUM_CLASS_NAMES(TestKind) = { #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #include \u0026#34;EnumBase.t.def\u0026#34; }; 这段代码使用了 X-Macro 和其他预处理器宏来定义一个名为 TestKind 的枚举类，以及与之相关的一些功能。这里的 X-Macro 是 COCKTAIL_ENUM_BASE_TEST_KIND，它被用于定义枚举值（Beep、Boop、Burr）和其他相关的代码。\n宏展开之后的样子:\n定义原始枚举类 1 2 3 4 5 enum class TestKindRawEnum : uint8_t { Beep, Boop, Burr }; 定义派生的枚举类 1 2 3 4 5 6 7 8 9 class TestKind : public EnumBase\u0026lt;TestKind, TestKindRawEnum, TestKindNames\u0026gt; { public: static const TestKind Beep; static const TestKind Boop; static const TestKind Burr; using EnumBase::AsInt; using EnumBase::FromInt; }; 定义命名常量 1 2 3 constexpr TestKind TestKind::Beep = TestKind::Create(TestKindRawEnum::Beep); constexpr TestKind TestKind::Boop = TestKind::Create(TestKindRawEnum::Boop); constexpr TestKind TestKind::Burr = TestKind::Create(TestKindRawEnum::Burr); 定义枚举类名称数组 1 2 3 4 5 constexpr llvm::StringLiteral TestKindNames[] = { \u0026#34;Beep\u0026#34;, \u0026#34;Boop\u0026#34;, \u0026#34;Burr\u0026#34; }; 通过使用 X-Macro 和其他预处理器宏，这段代码成功地定义了一个名为 TestKind 的枚举类，该枚举类具有以下特性：\n它有三个枚举值：Beep、Boop 和 Burr。 它继承自一个模板基类 EnumBase，该基类提供了一些额外的功能，如 AsInt() 和 FromInt() 方法。 它有一个与枚举值对应的名称数组 TestKindNames。 这样的设计提供了一种灵活、可复用的方式来创建和操作枚举类，同时也减少了代码重复和提高了可维护性。\nEnumBase主要用于以复用宏的方式生成Token类型，在词法分析里，过去的TokenKind是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class TokenKind { enum class KindEnum : uint8_t { #define COCKTAIL_TOKEN(TokenName) TokenName, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; public: #define COCKTAIL_TOKEN(TokenName) \\ static constexpr auto TokenName() -\u0026gt; TokenKind { \\ return TokenKind(KindEnum::TokenName); \\ } #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; TokenKind() = delete; friend auto operator==(const TokenKind\u0026amp; lhs, const TokenKind\u0026amp; rhs) -\u0026gt; bool { return lhs.kind_value_ == rhs.kind_value_; } friend auto operator!=(const TokenKind\u0026amp; lhs, const TokenKind\u0026amp; rhs) -\u0026gt; bool { return lhs.kind_value_ != rhs.kind_value_; } [[nodiscard]] auto Name() const -\u0026gt; llvm::StringRef; [[nodiscard]] auto IsKeyword() const -\u0026gt; bool; [[nodiscard]] auto IsSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsGroupingSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsOpeningSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsClosingSymbol() const -\u0026gt; bool; [[nodiscard]] auto GetOpeningSymbol() const -\u0026gt; TokenKind; [[nodiscard]] auto GetClosingSymbol() const -\u0026gt; TokenKind; [[nodiscard]] auto GetFixedSpelling() const -\u0026gt; llvm::StringRef; [[nodiscard]] auto IsOneOf(std::initializer_list\u0026lt;TokenKind\u0026gt; kinds) const -\u0026gt; bool { for (TokenKind kind : kinds) { if (*this == kind) { return true; } } return false; } [[nodiscard]] auto IsSizedTypeLiteral() const -\u0026gt; bool; constexpr operator KindEnum() const { return kind_value_; } auto Print(llvm::raw_ostream\u0026amp; out) const -\u0026gt; void { out \u0026lt;\u0026lt; GetFixedSpelling(); } private: constexpr explicit TokenKind(KindEnum kind_value) : kind_value_(kind_value) {} KindEnum kind_value_; }; auto TokenKind::Name() const -\u0026gt; llvm::StringRef { static constexpr llvm::StringLiteral Names[] = { #define COCKTAIL_TOKEN(TokenName) #TokenName, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Names[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsKeyword() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_SYMBOL_TOKEN(TokenName, Spelling) true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsGroupingSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ true, #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsOpeningSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsClosingSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsSizedTypeLiteral() const -\u0026gt; bool { return *this == TokenKind::IntegerTypeLiteral() || *this == TokenKind::UnsignedIntegerTypeLiteral() || *this == TokenKind::FloatingPointTypeLiteral(); } auto TokenKind::GetOpeningSymbol() const -\u0026gt; TokenKind { static constexpr TokenKind Table[] = { #define COCKTAIL_TOKEN(TokenName) Error(), #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ OpeningName(), #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; auto result = Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; // COCKTAIL_CHECK(result != Error()) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } auto TokenKind::GetClosingSymbol() const -\u0026gt; TokenKind { static constexpr TokenKind Table[] = { #define COCKTAIL_TOKEN(TokenName) Error(), #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ ClosingName(), #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; auto result = Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; // COCKTAIL_CHECK(result != Error()) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } auto TokenKind::GetFixedSpelling() const -\u0026gt; llvm::StringRef { static constexpr llvm::StringLiteral Table[] = { #define COCKTAIL_TOKEN(TokenName) \u0026#34;\u0026#34;, #define COCKTAIL_SYMBOL_TOKEN(TokenName, Spelling) Spelling, #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) Spelling, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } 这里会更直观，类型变量存在类中，直接用于所有接口中的底层数据，但可复用性会降低。\n使用EnumBase更新后的TokenKind如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 COCKTAIL_DEFINE_RAW_ENUM_CLASS(TokenKind, uint8_t) { #define COCKTAIL_TOKEN(TokenName) COCKTAIL_RAW_ENUM_ENUMERATOR(TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; }; class TokenKind : public COCKTAIL_ENUM_BASE(TokenKind) { public: #define COCKTAIL_TOKEN(TokenName) COCKTAIL_ENUM_CONSTANT_DECLARATION(TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; /// 所有keyword token。 static const llvm::ArrayRef\u0026lt;TokenKind\u0026gt; KeywordTokens; /// 检查此标记是否为简单的符号序列（如标点符号）。 /// 这些符号可以直接出现在源代码中，并且可以使用starts_with进行词法分析。 [[nodiscard]] auto is_symbol() const -\u0026gt; bool { return IsSymbol[AsInt()]; } /// 检查此标记是否为分组符号（如括号、大括号等），这些符号在标记流中必须匹配。 [[nodiscard]] auto is_grouping_symbol() const -\u0026gt; bool { return IsGroupingSymbol[AsInt()]; } /// 对于结束符号，返回其对应的开头符号。 [[nodiscard]] auto opening_symbol() const -\u0026gt; TokenKind { auto result = OpeningSymbol[AsInt()]; COCKTAIL_CHECK(result != Error) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } /// 检查此标记是否为分组的开头符号。 [[nodiscard]] auto is_opening_symbol() const -\u0026gt; bool { return IsOpeningSymbol[AsInt()]; } /// 对于开头符号，返回其对应的结束符号。 [[nodiscard]] auto closing_symbol() const -\u0026gt; TokenKind { auto result = ClosingSymbol[AsInt()]; COCKTAIL_CHECK(result != Error) \u0026lt;\u0026lt; \u0026#34;Only opening symbol are valid!\u0026#34;; return result; } /// 检查此标记是否为分组的结束符号。 [[nodiscard]] auto is_closing_symbol() const -\u0026gt; bool { return IsClosingSymbol[AsInt()]; } /// 检查此标记是否为单字符符号，且此字符不是其他符号的一部分。 [[nodiscard]] auto is_one_char_symbol() const -\u0026gt; bool { return IsOneCharSymbol[AsInt()]; }; /// 检查此标记是否为关键字。 [[nodiscard]] auto is_keyword() const -\u0026gt; bool { return IsKeyword[AsInt()]; }; /// 检查此标记是否为带有大小的类型字面量（如整数、浮点数类型字面量）。 [[nodiscard]] auto is_sized_type_literal() const -\u0026gt; bool { return *this == TokenKind::IntegerTypeLiteral || *this == TokenKind::UnsignedIntegerTypeLiteral || *this == TokenKind::FloatingPointTypeLiteral; }; /// 如果此标记在源代码中有固定的拼写，则返回它。否则返回空字符串。 [[nodiscard]] auto fixed_spelling() const -\u0026gt; llvm::StringRef { return FixedSpelling[AsInt()]; }; /// 获取此标记所对应的解析树节点的预期数量。 [[nodiscard]] auto expected_parse_tree_size() const -\u0026gt; int { return ExpectedParseTreeSize[AsInt()]; } /// 检查此标记是否在提供的列表中。 [[nodiscard]] auto IsOneOf(std::initializer_list\u0026lt;TokenKind\u0026gt; kinds) const -\u0026gt; bool { for (TokenKind kind : kinds) { if (*this == kind) { return true; } } return false; } private: static const TokenKind KeywordTokensStorage[]; static const bool IsSymbol[]; static const bool IsGroupingSymbol[]; static const bool IsOpeningSymbol[]; static const TokenKind ClosingSymbol[]; static const bool IsClosingSymbol[]; static const TokenKind OpeningSymbol[]; static const bool IsOneCharSymbol[]; static const bool IsKeyword[]; static const llvm::StringLiteral FixedSpelling[]; static const int8_t ExpectedParseTreeSize[]; }; #define COCKTAIL_TOKEN(TokenName) \\ COCKTAIL_ENUM_CONSTANT_DEFINITION(TokenKind, TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; constexpr TokenKind TokenKind::KeywordTokensStorage[] = { #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) TokenKind::TokenName, #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; }; constexpr llvm::ArrayRef\u0026lt;TokenKind\u0026gt; TokenKind::KeywordTokens = KeywordTokensStorage; 3. 错误状态 ","permalink":"https://canftin.github.io/posts/tech/p3_compiler_build_2_common_lib/","summary":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做","title":"从零构造现代语言编译器(2): 公共库"},{"content":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 123、3.14、0xFF、1.23e-4 都可以被视为数值字面量。\n字面量的类型通常根据其格式和位置决定。例如在大多数编程语言[1][2][3]中，带有小数点的数字将被视为浮点数（如 3.14 ），而没有小数点的数字将被视为整数（如 123 ）。\n更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。\n本章将从数值字面量的解析入手，开始进入编译器构造的世界。\nCarbon数值类型介绍 Carbon中数值类型[4][5]有如下几种：\n整数类型\n整数根据进制分为如下类型：十进制（例如 12345 ）、十六进制（例如 0x1FE ）、二进制（例如 0b1010 ）等\n实数类型\n实数类型总是包含 . 符号，实数类型例如基础类型 123.456 以及科学技术法表示 123.456e789、0x1.2p123 等，其中科学技术法表示中的字符 e 及 p 在Carbon中称为指数（对应代码中exponent 字符，实际在幂运算中应为底数），对于一个十进制值 N 来说，e 相当于10±N，而 p 相当于2±N。\n且实数类型字面量 exponent 字符后可跟随 + 或 - 字符，例如 12.34e+56 或 56.34e-12。\n数字分隔符[6]\n数字分隔符由下划线 _ 表示，例如十进制数: 1_23_456_7890、十六进制数: 0x7_F_FF_FFFF、实数: 2_147.48_3648e12_345 或 0x1_00CA.FE_F00Dp+2_4、二进制数: 0b1_000_101_11 等。\n数值字面量词法解析： 首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 _ 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 exponent 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供NumericLiteralToken类的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。\n以下代码参考numeric_literal section1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class NumericLiteralToken { public: auto Text() const -\u0026gt; llvm::StringRef { return text; } static auto Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt;; auto GetRadixPoint() -\u0026gt; int { return radix_point; } auto GetExponent() -\u0026gt; int { return exponent; } private: NumericLiteralToken() {} llvm::StringRef text; // \u0026#39;.\u0026#39;字符的偏移量 int radix_point; // \u0026#39;e\u0026#39;或\u0026#39;p\u0026#39;字符的偏移量 int exponent; }; 其中我们重点关注Lex接口的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 auto NumericLiteralToken::Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt; { NumericLiteralToken result; // 判断source_text是否为空以及第一个字符是否为数字 if (source_text.empty() || !IsDecimalDigit(source_text.front())) { return llvm::None; } bool seen_plus_minus = false; bool seen_radix_point = false; bool seen_potential_exponent = false; // 由于之前已经确认过首字符，这里索引从1开始 int i = 1; for (int n = source_text.size(); i != n; ++i) { char c = source_text[i]; if (IsAlnum(c) || c == \u0026#39;_\u0026#39;) { // 只支持小写的 \u0026#39;e\u0026#39;，如果存在该字符且发现点号以及未探索 // 到加减号则记录exponent索引位置，否则继续下一轮循环 if (IsLower(c) \u0026amp;\u0026amp; seen_radix_point \u0026amp;\u0026amp; !seen_plus_minus) { result.exponent = i; seen_potential_exponent = true; } continue; } // 当前字符为 \u0026#39;.\u0026#39; 时，记录radix_point if (c == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1]) \u0026amp;\u0026amp; !seen_radix_point) { result.radix_point = i; seen_radix_point = true; continue; } // 当前字符为 \u0026#39;+\u0026#39; 或 \u0026#39;-\u0026#39; 时，记录seen_plus_minus if ((c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; seen_potential_exponent \u0026amp;\u0026amp; result.exponent == i - 1 \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1])) { assert(!seen_plus_minus \u0026amp;\u0026amp; \u0026#34;should only consume one + or -\u0026#34;); seen_plus_minus = true; continue; } break; } // 返回探索到的字符串，以当前i的值为索引切分子串 result.text = source_text.substr(0, i); // 记录 \u0026#39;.\u0026#39; 偏移 if (!seen_radix_point) { result.radix_point = i; } // 记录 \u0026#39;e\u0026#39; 或 \u0026#39;p\u0026#39; 偏移 if (!seen_potential_exponent) { result.exponent = i; } return result; } 以上代码中，source_text用于接受外部传入的数值字符串，该类型为llvm::StringRef类型（StringRef类型分析可参考chapter12_s1.2: LLVM ADT StringRef介绍及使用），首先判断source_text是否为空以及第一个字符是否为数字，如果不满足条件则返回llvm::None，llvm::None实际为一个枚举数值类型，返回值为llvm::Optional（Optional类型分析可参考chapter12_s1.3: LLVM ADT Optional介绍及使用）。\n接下来使用三个变量seen_plus_minus（是否探索到 + 或 - ）、seen_radix_point（是否探索到 . ）、seen_potential_exponent（是否探索到 e 或者 p ）用于后续词法解析的条件判断。\n在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。\n跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。\n数值字面量语法解析 在词法层面我们切分并完成了NumericLiteralToken对象的解析，接下来需要实现数值字面量的解析，实现这一步的目标是在语义上能对不同数值字面量提取更多的信息，其中包括数值字面量的合规性检查、提取数据等，将数值字面量解析拆分为了Tokenizer和Parser两部分，使得每部分过程更为明确和便于后期扩展。\n我们关注numeric_literal代码section2中的友元类Parser实现，将section1中NumericLiteralToken里两个函数GetRadixPoint和GetExponent的能力删除，将提取对应数据的能力移交至Parser，函数返回值改为llvm::APInt（参考阅读什么是APInt链接）。\n以下代码参考numeric_literal section2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class NumericLiteralToken::Parser { public: Parser(NumericLiteralToken literal); auto IsInteger() -\u0026gt; bool { return literal.radix_point == static_cast\u0026lt;int\u0026gt;(literal.Text().size()); } auto GetRadix() const -\u0026gt; int { return radix; } auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; private: NumericLiteralToken literal; // 存储对应字面量 // 基数默认为10，可以为 2 或 10 或 16 int radix = 10; // 词法结构：[radix] int_part [. fract_part [[ep] [+-] exponent_part]] llvm::StringRef int_part; // 整数部分 llvm::StringRef fract_part; // 小数部分 llvm::StringRef exponent_part; // 指数部分 // 对应数据是否需要清除`_`或`.`符号，默认为false bool mantissa_needs_cleaning = false; bool exponent_needs_cleaning = false; // 在`exponent`部分后面发现了`-`符号 bool exponent_is_negative = false; }; 具体看一下Parser的构造函数，构造时传入NumericLiteralToken对象，根据该对象里的radix_point数据进行int_part数据的切分，并对切分结果前两个字符做检查，根据0x或0b首字符判断进制，随即切分fract_part数据以及exponent_part数据，并判断是否在exponent部分后面发现了-符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 NumericLiteralToken::Parser::Parser(NumericLiteralToken literal) : literal(literal) { int_part = literal.text.substr(0, literal.radix_point); if (int_part.consume_front(\u0026#34;0x\u0026#34;)) { radix = 16; } else if (int_part.consume_front(\u0026#34;0b\u0026#34;)) { radix = 2; } fract_part = literal.text.substr(literal.radix_point + 1, literal.exponent - literal.radix_point - 1); exponent_part = literal.text.substr(literal.exponent + 1); if (!exponent_part.consume_front(\u0026#34;+\u0026#34;)) { exponent_is_negative = exponent_part.consume_front(\u0026#34;-\u0026#34;); } } Parser构造函数中构建好数据后，需要提供接口获取对应数据。\n其中包括四个函数接口：\n1 2 3 4 auto IsInteger() -\u0026gt; bool; auto GetRadix() const -\u0026gt; int; auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; IsInteger()用于判断是否为一个整数，判断方式为小数点位置是否在字符串末尾，字符串显示不存在小数点时，小数点默认在末尾。 GetRadix()用于获取进制。 GetMantissa()用于获取小数部分。 GetExponent()用于获取指数部分。 其中GetMantissa()和GetExponent()都调用了ParseInteger接口，ParseInteger完成获取具体数值的功能，以下为ParseInteger接口代码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static auto ParseInteger(llvm::StringRef digits, int radix, bool needs_cleaning) -\u0026gt; llvm::APInt { llvm::SmallString\u0026lt;32\u0026gt; cleaned; // 预分配32个字节的字符串 if (needs_cleaning) { cleaned.reserve(digits.size()); // 根据目标大小重建长度 std::remove_copy_if(digits.begin(), digits.end(), std::back_inserter(cleaned), [](char c) { return c == \u0026#39;_\u0026#39; || c == \u0026#39;.\u0026#39;; }); digits = cleaned; } llvm::APInt value; if (digits.getAsInteger(radix, value)) { llvm_unreachable(\u0026#34;should never fail\u0026#34;); } return value; } 当解析包含小数点和下划线的字面量时，将忽视这两种字符，例如在解析 123.456e7 字面量时，我们期望获取到小数部分mantissa即(123456)和指数部分exponent(7-3=4)，根据这两个数我们能计算出真实的数据为：1234560000，其中GetMantissa函数如下：\n1 2 3 4 5 6 auto NumericLiteralToken::Parser::GetMantissa() -\u0026gt; llvm::APInt { // 如果为整数从int_part为结尾，否则以fract_part为结尾 const char* end = IsInteger() ? int_part.end() : fract_part.end(); llvm::StringRef digits(int_part.begin(), end - int_part.begin()); return ParseInteger(digits, radix, mantissa_needs_cleaning); } 获取exponent的函数GetExponent如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 auto NumericLiteralToken::Parser::GetExponent() -\u0026gt; llvm::APInt { llvm::APInt exponent(64, 0); // 创建64位值为0的exponent对象。 // 如果存在指数部分，就进入这个分支。 if (!exponent_part.empty()) { // 解析指数部分。这个函数会将字符串形式的指数转换为整数。其中， // 第一个参数是指数部分，第二个参数10是代表十进制，第三个参数 // 表示解析过程中是否需要进行清理。 exponent = ParseInteger(exponent_part, 10, exponent_needs_cleaning); // 检查指数的符号位是否被设置，或者指数的位宽是否小于64。 // 如果满足这些条件之一，就需要扩展指数的位宽。 if (exponent.isSignBitSet() || exponent.getBitWidth() \u0026lt; 64) { // 扩展指数的位宽。新的位宽至少为64，如果原来的位宽+1大于64， // 那么就使用原来的位宽+1。扩展后，新增的位都被设置为0。 exponent = exponent.zext(std::max(64U, exponent.getBitWidth() + 1)); } // 如果指数是负数，就需要取反。 if (exponent_is_negative) { exponent.negate(); // 取反操作。 } } // 计算小数部分的字符数量，这个数量会影响实际的指数大小。 int excess_exponent = fract_part.size(); // 如果基数是16，即如果是十六进制的数，那么每一个小数部 // 分的字符都会减少4个指数（因为一个十六进制的字符等于4个二进制位）。 if (radix == 16) { excess_exponent *= 4; // 将小数部分的字符数量乘以4。 } exponent -= excess_exponent; // 从指数中减去小数部分的字符数量。 // 如果原来的指数是负数，但是计算后的指数变为非负，那么就进入这个分支。 if (exponent_is_negative \u0026amp;\u0026amp; !exponent.isNegative()) { // 扩展指数的位宽，新增的位被设置为0。 exponent = exponent.zext(exponent.getBitWidth() + 1); // 设置指数的符号位，使得指数变为负数。 exponent.setSignBit(); } return exponent; } 从上面我们可以看到mantissa_needs_cleaning和exponent_needs_cleaning永远为false，原因是因为这两个标志位需要在获取数据之前对字面量做检查后进行设置，对传入不满足要求的字面量做预处理检查后才允许提取。\n关于字面量检查部分在下一章Chapter2: 诊断信息中进行说明与分析。\n2. 字符串字面量 // TODO: 1. 讲解字符串字面量代码。 // TODO: 2. 讲解字符串字面量设计。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 auto StringLiteral::Lex(llvm::StringRef source_text) -\u0026gt; std::optional\u0026lt;StringLiteral\u0026gt; { int64_t cursor = 0; const int64_t source_text_size = source_text.size(); // 确定前缀中的#数量。 while (cursor \u0026lt; source_text_size \u0026amp;\u0026amp; source_text[cursor] == \u0026#39;#\u0026#39;) { ++cursor; } const int hash_level = cursor; const std::optional\u0026lt;Introducer\u0026gt; introducer = Introducer::Lex(source_text.substr(hash_level)); if (!introducer) { return std::nullopt; } cursor += introducer-\u0026gt;prefix_size; const int prefix_len = cursor; // 初始化终结符和转义序列标记。 llvm::SmallString\u0026lt;16\u0026gt; terminator(introducer-\u0026gt;terminator); llvm::SmallString\u0026lt;16\u0026gt; escape(\u0026#34;\\\\\u0026#34;); // 整终结符和转义序列的大小。 terminator.resize(terminator.size() + hash_level, \u0026#39;#\u0026#39;); escape.resize(escape.size() + hash_level, \u0026#39;#\u0026#39;); /// TODO: 在找到终结符之前检测多行字符串字面量的缩进/反缩进。 for (; cursor \u0026lt; source_text_size; ++cursor) { // 快速跳过不感兴趣的字符。 static constexpr CharSet InterestingChars = {\u0026#39;\\\\\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;}; if (!InterestingChars[source_text[cursor]]) { continue; } // 多字符的终结符和转义序列都以可预测的字符开始， // 并且不包含嵌入的、未转义的终结符或换行符。 switch (source_text[cursor]) { case \u0026#39;\\\\\u0026#39;: // 处理转义字符。 if (escape.size() == 1 || source_text.substr(cursor + 1).startwith(escape.substr(1))) { cursor += escape.size(); // 单行字符串且转义字符是换行符。 if (cursor \u0026gt;= source_text_size || (introducer-\u0026gt;kind == NotMultiLine \u0026amp;\u0026amp; source_text[cursor] == \u0026#39;\\n\u0026#39;)) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } } break; case \u0026#39;\\n\u0026#39;: // 单行字符串。 if (introducer-\u0026gt;kind == NotMultiLine) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } break; case \u0026#39;\u0026#34;\u0026#39;: case \u0026#39;\\\u0026#39;\u0026#39;: if (source_text.substr(cursor).startswith(terminator)) { llvm::StringRef text = source_text.substr(0, cursor + terminator.size()); llvm::StringRef content = source_text.substr(prefix_len, cursor - prefix_len); return StringLiteral(text, content, hash_level, introducer-\u0026gt;kind, /*is_terminated=*/true); } break; default: // 对于非终结符，不执行任何操作。 break; } } return StringLiteral(source_text, source_text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } 首先，我们需要理解代码的逻辑以构建自动机。这段代码的主要目的是解析字符串字面量，特别是处理多行字符串、转义序列和终结符。\n基于代码的逻辑，我们可以构建以下自动机，以下是自动机图示：\n首先，我们需要理解自动机的基本概念。在计算机科学中，一个自动机是一个抽象的机器，它可以处于有限数量的不同状态之一，且在任何给定时刻只能处于其中一个状态。自动机根据输入序列中的符号进行状态转换。\n现在，让我们详细分析上述自动机的每个部分：\n开始状态 (Start): 这是解析字符串时的初始状态。在这个状态下，我们首先检查字符串的前缀是否包含#字符。\nHashCount: 在这个状态下，我们计算#的数量。这是为了确定多行字符串的终结符需要与开始的#数量匹配。\n多行状态 (MultiLine): 如果字符串以'''或\u0026quot;\u0026quot;\u0026quot;开始，我们进入这个状态。在这个状态下，我们查找与开始匹配的终结符。终结符需要与开始的#数量匹配。\n常规状态 (Regular): 如果字符串以一个双引号\u0026quot;开始，我们进入这个状态。在这个状态下，我们查找另一个双引号或转义序列。\n转义状态 (Escape): 当我们在常规状态下遇到反斜杠\\时，我们进入这个状态。这是因为反斜杠通常用于表示转义序列，例如\\\u0026quot;表示一个双引号字符。在这个状态下，我们查找与转义序列匹配的字符。\n结束状态 (End): 当我们找到与开始匹配的终结符或达到字符串的末尾时，我们进入这个状态。这表示我们已经成功地解析了整个字符串。\n为什么这个自动机是这样设计的？\n这个自动机是基于Carbon语言中字符串字面量的词法规则设计的。这些规则定义了如何从源代码中解析字符串。特别是，这个自动机处理了以下几点：\n#字符的数量，这决定了多行字符串的终结符。 多行字符串和常规字符串的区别。 转义序列，这是在常规字符串中表示特殊字符的方法。 通过这个自动机，我们可以准确地解析Carbon语言中的字符串字面量，无论它们是多行的、常规的还是包含转义序列的。\n字符串解析例子：\n对于输入###'''hello world'''###：\n我们首先计算#的数量为3。 然后，我们确定这是一个多行字符串，并查找与'''###匹配的终结符。 我们成功地找到了终结符并结束了解析。 对于输入\u0026quot;hello \\\\\u0026quot; world\u0026quot;：\n我们确定这是一个常规字符串。 我们继续解析，直到遇到反斜杠\\，然后进入转义状态。 在转义状态下，我们找到另一个反斜杠，并返回常规状态。 我们继续解析，直到找到终结符\u0026quot;并结束解析。 这个自动机提供了一个高层次的视图，描述了如何解析字符串字面量。\n引用 [1] : Floating-point numeric types - C# reference | Microsoft Learn [2] : numeric_literals | MDN Web [3] : json-tutorial | miloyip [4] : numeric_literals | Carbon [5] : proposals 0143 | Carbon [6] : proposals 1983 | Carbon ","permalink":"https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/","summary":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一","title":"从零构造现代语言编译器(1): 词法分析"},{"content":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，预计2-3年内结束实验[2]。\nCarbon官方项目选择Bazel构建工具，一方面是因为Google内部工具链的高可用性，相比于Go语言早期构建方式，作为同样出自Google之手的Carbon语言，避免手搓Makefile的繁琐，选用更加现代的工具链作为构建工具，另一方面也由于Google在LLVM之上的积累和贡献[3]，LLVM目前仓库中Bazel构建方式由Google团队完成及合并（不过经过测试发现，存在年久失修的问题[4]）。\n本项目介绍及依赖安装 本项目基于Carbon，为深入剖析现代编译器前端实现以及LLVM工具链上层使用，一步一步实现名为Cocktail（鸡尾酒）的语言，代码协议遵从官方仓库Lisence[5]，项目按照LLVM仓库主流构建方式和代码结构组织，使用CMake、Google test、Google mock等工具完成。\n本项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试，需要安装的依赖环境参考如下命令：\n1 sudo apt-get install cmake g++ clang bison flex libgtest-dev libgmock-dev make valgrind libbenchmark-dev llvm-15-dev CMake项目结构 首先从0到1构建CMake项目结构，参照clang的项目结构，project_structure代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 . ├── CMakeLists.txt ├── include │ └── Cocktail │ └── Lexer │ └── Basic.h ├── lib │ └── Lexer │ └── Basic.cc └── unittests ├── CMakeLists.txt └── Lexer ├── Basic.t.cc └── CMakeLists.txt 其中include作为Cocktail的头文件目录，lib作为Cocktail的库文件目录，其中C++文件一律以.cc作为后缀，unittests作为Cocktail单元测试文件目录，并且其中单元测试一律以.t.cc作为后缀，单元测试依赖头文件以.t.h为后缀。\n可在该目录下执行如下命令完成构建（make），或自行选用Ninja build：\n1 2 3 4 5 \u0026gt; mkdir build \u0026gt; cd build \u0026gt; cmake .. \u0026gt; make -j$(nproc) \u0026gt; ctest -j$(nproc) cmake构建结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 -- The C compiler identification is GNU 11.3.0 -- The CXX compiler identification is GNU 11.3.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Project: \u0026#39;cocktail\u0026#39; -- Performing Test HAVE_FFI_CALL -- Performing Test HAVE_FFI_CALL - Success -- Found FFI: /usr/lib/x86_64-linux-gnu/libffi.so -- Performing Test Terminfo_LINKABLE -- Performing Test Terminfo_LINKABLE - Success -- Found Terminfo: /usr/lib/x86_64-linux-gnu/libtinfo.so -- Found ZLIB: /usr/lib/x86_64-linux-gnu/libz.so (found version \u0026#34;1.2.11\u0026#34;) -- Found LibXml2: /usr/lib/x86_64-linux-gnu/libxml2.so (found version \u0026#34;2.9.13\u0026#34;) -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- unittest files found: Basic.t.cc -- Configuring done -- Generating done -- Build files have been written to: /carbon-blog/code/project_structure/build make构建结果如下：\n1 2 3 4 5 6 [ 25%] Building CXX object CMakeFiles/cocktail.dir/lib/Lexer/Basic.cc.o [ 50%] Linking CXX static library libcocktail.a [ 50%] Built target cocktail [ 75%] Building CXX object unittests/Lexer/CMakeFiles/Basic.t.dir/Basic.t.cc.o [100%] Linking CXX executable Basic.t [100%] Built target Basic.t ctest构建结果如下：\n1 2 3 4 5 6 7 8 9 Test project /carbon-blog/code/project_structure/build Start 1: Basic.t 1/2 Test #1: Basic.t .......................... Passed 0.01 sec Start 2: Basic.t-memory-check 2/2 Test #2: Basic.t-memory-check ............. Passed 0.97 sec 100% tests passed, 0 tests failed out of 2 Total Test time (real) = 0.98 sec 介绍CMake构建文件 在主目录下CMakeList.txt文件中可以看到这条add_compile_options(-fno-rtti)编译选项，这里表明禁用C++的RTTI特性，由于LLVM实现了自己的一套RTTI机制，此处加入该选项禁用。\nset(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm)设置LLVM路径，由于上述使用apt包管理安装llvm-15-dev，LLVM默认CMake路径为/usr/lib/llvm-15/lib/cmake/llvm。\n同时需要加入如下条件使得项目完成LLVM的引入：\n1 2 3 4 find_package(LLVM REQUIRED CONFIG) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) 关于内存泄漏检查，使用valgrind工具，将其加入ctest中，对编译出的二进制目标进行测试：\n1 2 3 4 find_program(CMAKE_MEMORYCHECK_COMMAND valgrind) set(memcheck_command ${CMAKE_MEMORYCHECK_COMMAND} ${CMAKE_MEMORYCHECK_COMMAND_OPTIONS} --error-exitcode=1 --leak-check=full) add_test(${FILE_NAME}-memory-check ${memcheck_command} ./${FILE_NAME}) clang-format使用 clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format[6]配置。\nclang-tidy使用 clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy[7]配置。\n项目调试的前置知识 由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件[8]，得以直观显示LLVM数据结构。\n引用 [1] : “C++的后继语言”\n[2] : 实验\n[3] : 贡献\n[4] : 年久失修的问题\n[5] : 官方仓库Lisence\n[6] : .clang-format\n[7] : .clang-tidy\n[8] : lldbDataFormatters插件\n","permalink":"https://canftin.github.io/posts/tech/p1_compiler_build_0_start/","summary":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，","title":"从零构造现代语言编译器(0): 开始"},{"content":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年我个人陆陆续续整理了一些资料和笔记，但只适合我自己查找回顾，导致思维脉络过于零散，不够系统。 我现在的工作专注于编译器开发，目前工作三年，前两年一直在做一些后端业务型的服务或工具的开发，近一年主要集中在底层语言编译器以及ai编译器开发部分。 重启这个博客，一方面想让自己开始保持一定的知识整理习惯，增强语言输出能力，另一方面也是总结归纳底层系统知识。 最近的一个愿景就是先成体系地输出关于现代语言编译器的构造系列文章，尝试去从源码分析的角度完整剖析语言编译器的构成，希望从这里开始重新投入。\n","permalink":"https://canftin.github.io/posts/tech/p0_restart_blog/","summary":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年","title":"重启博客"},{"content":"我是矩木，目前专注于编译器开发，我的GitHub。\n","permalink":"https://canftin.github.io/about/","summary":"我是矩木，目前专注于编译器开发，我的GitHub。","title":"关于我"}]