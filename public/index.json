[{"content":"这篇文章作为LLVM源码分析系列的开篇，初步介绍LLVM中format的相关机制和原理，format在LLVM中较为容易理解，从这里启航，后续慢慢剖析LLVM中的实现。\n1. 关于代码格式化 在讲这篇文章之前，首先要讲讲 format 到底是什么，在不同的语言中以及不同的库中，它的输出形式是什么样子，如何对程序员友好的输出 format，以及关于它的性能。\n1.1 什么是 format 在大多数现代语言中都提供了基本的 format 即格式化操作，在 Rust 中，格式化字符串和其他数据主要通过 std::fmt 模块和 println! 宏实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Point { x: i32, y: i32, } impl std::fmt::Display for Point { fn fmt(\u0026amp;self, f: \u0026amp;mut std::fmt::Formatter) -\u0026gt; std::fmt::Result { write!(f, \u0026#34;({}, {})\u0026#34;, self.x, self.y) } } let point = Point { x: 5, y: 10 }; println!(\u0026#34;{}\u0026#34;, point); // 输出: (5, 10) 以上，std::fmt::Formatter 类型提供了一系列方法和选项，为用户友好的输出格式化类型。std::fmt 提供的功能允许用户以各种方式格式化和显示数据，使 Rust 代码更具可读性。\n1 2 3 4 5 6 7 8 9 10 11 let name = \u0026#34;world\u0026#34;; let message = format!(\u0026#34;Hello, {}!\u0026#34;, name); let num = 15; let x = 10; let ref_to_x = \u0026amp;x; println!(\u0026#34;{}\u0026#34;, message); println!(\u0026#34;{:b}\u0026#34;, num); // 输出二进制: 1111 println!(\u0026#34;{:o}\u0026#34;, num); // 输出八进制: 17 println!(\u0026#34;{:x}\u0026#34;, num); // 输出小写十六进制: f println!(\u0026#34;{:p}\u0026#34;, ref_to_x); // 输出 x 的引用的内存地址 println!(\u0026#34;{:e}\u0026#34;, num); // 输出小写的科学记数法 Rust 的 format! 宏提供了类型安全的字符串格式化。这意味着编译时会检查格式字符串与给定参数是否匹配，有助于避免许多常见的运行时错误。\nGo 的 fmt 包提供了格式化 I/O 功能，其中包括了各种函数如 Println(), Printf(), Sprint() 等。\n1 2 3 4 5 6 7 import \u0026#34;fmt\u0026#34; func main() { name := \u0026#34;world\u0026#34; message := fmt.Sprintf(\u0026#34;Hello, %s!\u0026#34;, name) fmt.Println(message) } Sprintf 用于格式化并返回一个字符串。Go 的格式化是反射驱动的，为多种类型提供了强大的格式化选项。\n在 C# 中，字符串格式化的主要方式是 string.Format() 方法和 $ 字符串插值（从 C# 6 开始）。\n1 2 3 4 5 6 7 8 9 using System; public class HelloWorld { public static void Main() { string name = \u0026#34;world\u0026#34;; string message = String.Format(\u0026#34;Hello, {0}!\u0026#34;, name); Console.WriteLine(message); } } String.Format 方法提供了一个格式化字符串和参数列表，并返回格式化后的字符串。该方法在运行时检查格式与参数是否匹配，并提供了各种格式化选项，例如日期、货币和自定义格式化。\nPython 提供了多种字符串格式化方法，如 % 格式化、str.format() 和 f-strings。f-strings 是 Python 3.6 之后引入的，提供了简洁的内嵌表达式插值。\n1 2 3 name = \u0026#34;world\u0026#34; message = \u0026#34;Hello, {}!\u0026#34;.format(name) print(message) 或使用 f-string (Python 3.6+):\n1 2 3 name = \u0026#34;world\u0026#34; message = f\u0026#34;Hello, {name}!\u0026#34; print(message) 而在 C++ 中，C++ 的标准输出流（如 std::cout、std::cerr）与流操作符（如 \u0026lt;\u0026lt;）结合使用，提供了一种顺序、连续的方式来输出数据。\n通过流操作符可以轻松地链式输出各种数据类型。但是格式化能力相对有限。例如，设置字段宽度、填充字符和精度通常需要先设置特定的 I/O 操作符或成员函数。\nC++20 已经引入了 std::format，基于github上的 fmtlib 库，format 提供了一种更加灵活、描述性强、类型安全的格式化字符串的方法，能够使用更丰富的格式选项来构造字符串。例如：\n1 std::string message = std::format(\u0026#34;Hello, {}!\u0026#34;, \u0026#34;world\u0026#34;); 以上介绍了几种不同语言中的format，总而言之，各种语言中的 format 功能都是为了使字符串格式化变得更加简单、安全和强大。\n1.2 LLVM 的 formatv 字符串格式化 LLVM 虽然不经常进行大量的字符串操作和解析，但进行了大量的字符串格式化。从诊断信息、到 LLVM 工具的输出，例如 llvm-readobj，再到打印详细的反汇编列表和 LLDB 运行时日志，都需要字符串格式化。\nformatv 在使用上类似于 printf，但使用了不同的语法，该语法主要受到 Python 和 C# 的影响。但不同于 printf，它在编译时推断要格式化的类型，因此不需要像 %d 这样的格式说明符。这减少了尝试构造可移植格式字符串的心智负担，特别是对于平台特定类型，如 size_t 或指针类型。与 printf 和 Python 都不同，如果 LLVM 不知道如何格式化该类型，它还会失败并不编译。以上这两个属性确保该函数比传统的格式化方法（如 printf 函数族）更安全、更简单。\n使用 llvm format 的方式：\n调用 formatv 包括一个由 0 个或多个替换序列组成的格式字符串，后跟一个可变长度的替换值列表。 替换序列是 {N[[,align]:style]} 形式的字符串。 N 是替换值列表中的参数的 0 为索引。这意味着可以多次、可能使用不同的样式和/或对齐选项、以任何顺序引用相同的参数。 自定义格式化：\n有两种方法可以自定义类型的格式化行为。\n为类型 T 提供 llvm::format_provider\u0026lt;T\u0026gt; 的模板特化，以及相应的静态格式化方法。 1 2 3 4 5 6 7 8 9 10 11 12 namespace llvm { template\u0026lt;\u0026gt; struct format_provider\u0026lt;MyFooBar\u0026gt; { static void format(const MyFooBar \u0026amp;V, raw_ostream \u0026amp;Stream, StringRef Style) { // Do whatever is necessary to format `V` into `Stream` } }; void foo() { MyFooBar X; std::string S = formatv(\u0026#34;{0}\u0026#34;, X); } } 这是一种有用的扩展性机制，用于为用户自定义类型添加支持自定义选项的格式化。但当想要扩展已知如何格式化的类型的机制时，则需要其他方法。\n提供从 llvm::FormatAdapter\u0026lt;T\u0026gt; 继承的格式化适配器。 1 2 3 4 5 6 7 8 9 10 11 12 13 namespace anything { struct format_int_custom : public llvm::FormatAdapter\u0026lt;int\u0026gt; { explicit format_int_custom(int N) : llvm::FormatAdapter\u0026lt;int\u0026gt;(N) {} void format(llvm::raw_ostream \u0026amp;Stream, StringRef Style) override { // Do whatever is necessary to format ``this-\u0026gt;Item`` into ``Stream`` } }; } namespace llvm { void foo() { std::string S = formatv(\u0026#34;{0}\u0026#34;, anything::format_int_custom(42)); } } 如果检测到类型是从 FormatAdapter\u0026lt;T\u0026gt; 派生出来的，formatv 将在传入指定样式的参数上调用格式化方法。这允许为任何类型提供自定义格式化，包括已经具有内置格式化提供程序的类型。\nformatv 示例：\n以下提供了一组示例，演示了 formatv 的用法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 std::string S; // 对基本类型和隐式字符串转换的简单格式化。 S = formatv(\u0026#34;{0} ({1:P})\u0026#34;, 7, 0.35); // S == \u0026#34;7 (35.00%)\u0026#34; // 乱序引用和多重引用 outs() \u0026lt;\u0026lt; formatv(\u0026#34;{0} {2} {1} {0}\u0026#34;, 1, \u0026#34;test\u0026#34;, 3); // 输出 \u0026#34;1 3 test 1\u0026#34; // 左、右和中心对齐 S = formatv(\u0026#34;{0,7}\u0026#34;, \u0026#39;a\u0026#39;); // S == \u0026#34; a\u0026#34;; S = formatv(\u0026#34;{0,-7}\u0026#34;, \u0026#39;a\u0026#39;); // S == \u0026#34;a \u0026#34;; S = formatv(\u0026#34;{0,=7}\u0026#34;, \u0026#39;a\u0026#39;); // S == \u0026#34; a \u0026#34;; S = formatv(\u0026#34;{0,+7}\u0026#34;, \u0026#39;a\u0026#39;); // S == \u0026#34; a\u0026#34;; // 自定义样式 S = formatv(\u0026#34;{0:N} - {0:x} - {1:E}\u0026#34;, 12345, 123908342); // S == \u0026#34;12,345 - 0x3039 - 1.24E8\u0026#34; // 适配器 S = formatv(\u0026#34;{0}\u0026#34;, fmt_align(42, AlignStyle::Center, 7)); // S == \u0026#34; 42 \u0026#34; S = formatv(\u0026#34;{0}\u0026#34;, fmt_repeat(\u0026#34;hi\u0026#34;, 3)); // S == \u0026#34;hihihi\u0026#34; S = formatv(\u0026#34;{0}\u0026#34;, fmt_pad(\u0026#34;hi\u0026#34;, 2, 6)); // S == \u0026#34; hi \u0026#34; // 范围 std::vector\u0026lt;int\u0026gt; V = {8, 9, 10}; S = formatv(\u0026#34;{0}\u0026#34;, make_range(V.begin(), V.end())); // S == \u0026#34;8, 9, 10\u0026#34; S = formatv(\u0026#34;{0:$[+]}\u0026#34;, make_range(V.begin(), V.end())); // S == \u0026#34;8+9+10\u0026#34; S = formatv(\u0026#34;{0:$[ + ]@[x]}\u0026#34;, make_range(V.begin(), V.end())); // S == \u0026#34;0x8 + 0x9 + 0xA\u0026#34; 这些示例展示了 formatv 的使用方式，可用于灵活和类型安全地格式化字符串。\nformatv 示例：\n1 2 3 4 std::string S; S = formatv(\u0026#34;{0} ({1:P})\u0026#34;, 7, 0.35); // S == \u0026#34;7 (35.00%)\u0026#34; // ... (其他示例) S = formatv(\u0026#34;{0:$[ + ]@[x]}\u0026#34;, make_range(V.begin(), V.end())); // S == \u0026#34;0x8 + 0x9 + 0xA\u0026#34; llvm formatv 对比 printf 的好处：\n比传统的 printf 更安全、简单。 类型安全，防止格式化错误。 更易于构造可移植的格式字符串。 llvm formatv 与 fmtlib 的不同：\nformatv 有着与 Python 和 C# 类似的格式化语法，而 fmtlib 的语法受到 Python 的 str.format() 的影响。 formatv 在编译时推断格式化类型，而 fmtlib 也提供了相似的类型安全特性。 formatv 的扩展性可能与 fmtlib 有所不同，因为它们采用了不同的方法来实现自定义格式化。 总的来说，formatv 提供了一个强大而类型安全的方式来格式化字符串，并具有与其他格式化方法不同的特性和优点。\n2. formatv的极简实现 以下我提供一个简单的format实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 template \u0026lt;typename... Args\u0026gt; auto Format(const char* formatter, const Args\u0026amp;... args) -\u0026gt; std::string; template \u0026lt;typename... Args\u0026gt; auto Format(const std::string\u0026amp; formatter, const Args\u0026amp;... args) -\u0026gt; std::string; template \u0026lt;typename... Args\u0026gt; auto PrintFormatted(const char* formatter, const Args\u0026amp;... args) -\u0026gt; void; template \u0026lt;typename... Args\u0026gt; auto PrintFormatted(const std::string\u0026amp; formatter, const Args\u0026amp;... args) -\u0026gt; void; inline auto IsDigit(char c) -\u0026gt; bool { return c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } inline auto Consume(const char*\u0026amp; s) -\u0026gt; char { assert(*s); return *(s++); } inline auto ConsumeIf(const char*\u0026amp; s, char c) -\u0026gt; bool { assert(c != \u0026#39;\\0\u0026#39;); if (*s == c) { ++s; return true; } return false; } class FormatError : public std::runtime_error { public: explicit FormatError(const std::string\u0026amp; msg) : std::runtime_error(msg) {} }; inline void FormatAssert(bool pred, std::string msg = \u0026#34;Unknown format error.\u0026#34;) { if (!pred) { throw FormatError(msg); } } template \u0026lt;typename Stream, typename... Args\u0026gt; auto FormatImpl(Stream\u0026amp; output, const std::string\u0026amp; formatter, const Args\u0026amp;... args) -\u0026gt; void { static_assert(sizeof...(args) \u0026lt; 11, \u0026#34;Only support 10 args.\u0026#34;); if (formatter.empty()) { return; } constexpr auto ArgsCount = sizeof...(args); std::function\u0026lt;void(Stream\u0026amp;)\u0026gt; helpers[10] = {[\u0026amp;](auto\u0026amp; ss) { ss \u0026lt;\u0026lt; args; }...}; size_t next_id = 0; for (const auto* p = formatter.c_str(); *p;) { if (ConsumeIf(p, \u0026#39;{\u0026#39;)) { if (ConsumeIf(p, \u0026#39;{\u0026#39;)) { output.put(\u0026#39;{\u0026#39;); } else { size_t id; if (ConsumeIf(p, \u0026#39;}\u0026#39;)) { id = next_id++; } else { assert(IsDigit(*p)); id = Consume(p) - \u0026#39;0\u0026#39;; FormatAssert(id \u0026gt;= 0 \u0026amp;\u0026amp; id \u0026lt;= 9, \u0026#34;Argument id must be within [0,10).\u0026#34;); FormatAssert(id \u0026lt; ArgsCount, \u0026#34;Not enough arguments.\u0026#34;); FormatAssert(ConsumeIf(p, \u0026#39;}\u0026#39;), \u0026#34;Invalid argument reference.\u0026#34;); } helpers[id](output); } } else if (ConsumeIf(p, \u0026#39;}\u0026#39;)) { if (ConsumeIf(p, \u0026#39;}\u0026#39;)) { output.put(\u0026#39;}\u0026#39;); } else { FormatAssert(false, \u0026#34;An isolated closing brace is not allowed.\u0026#34;); } } else { output.put(Consume(p)); } } } template \u0026lt;typename... Args\u0026gt; auto Format(const char* formatter, const Args\u0026amp;... args) -\u0026gt; std::string { std::stringstream ss; FormatImpl(ss, formatter, args...); return ss.str(); } template \u0026lt;typename... Args\u0026gt; auto PrintFormatted(const char* formatter, const Args\u0026amp;... args) -\u0026gt; void { FormatImpl(std::cout, formatter, args...); } 这段代码实现了一种类似于字符串格式化的机制，它允许使用占位符来动态替换字符串中的值。该机制包括两个主要函数模板：Format 和 PrintFormatted，以及相关的辅助函数。\n逐步详细分析这段代码：\n2.1 辅助函数 FormatAssert FormatAssert 是一个辅助函数，用于在断言失败时抛出 FormatError 异常。这个函数的目的是确保断言的条件为真，如果条件为假，就会抛出异常。用于检查格式字符串的有效性和参数的合法性。\n2.2 函数模板 FormatImpl FormatImpl 是一个模板函数，接受一个输出流（通常是 std::stringstream 或 std::cout）以及一个格式字符串和一系列参数。它的主要任务是解析格式字符串并根据参数的数量和格式进行替换，然后将结果输出到给定的输出流。\n函数内部的关键部分是解析格式字符串的循环。它遍历格式字符串的每个字符，根据字符的不同来执行不同的操作：\n如果遇到双花括号 {{，则输出一个单独的花括号 {。 如果遇到花括号 {，则开始解析占位符。 占位符中可以包含占位符索引，例如 {0}、{1}，或者可以省略，例如 {}。 解析占位符时，首先检查是否有索引，如果没有则使用下一个可用索引。 然后根据索引查找对应的参数，并使用参数的类型的 \u0026lt;\u0026lt; 操作符将参数添加到输出流中。 如果占位符不是合法的格式，例如 {10}，或者没有正确的闭合括号，将会抛出异常。 2.3 函数模板 Format 和 PrintFormatted 这两个函数是对 FormatImpl 函数的封装，使其更加方便地使用。\nFormat 函数接受一个格式字符串和一系列参数，然后创建一个 std::stringstream 对象，在其中使用 FormatImpl 将格式化后的字符串放入流中，并返回最终的格式化结果作为一个字符串。 PrintFormatted 函数接受一个格式字符串和一系列参数，然后直接使用 FormatImpl 将格式化后的内容输出到标准输出流 std::cout。 这两个函数使得使用格式化字符串更加方便。\n2.4 测试使用 1 2 3 4 5 std::string yield = Format(\u0026#34;a({},{},{},{})\u0026#34;, 1, 2.2, \u0026#39;3\u0026#39;, \u0026#34;\\\u0026#34;4\\\u0026#34;\u0026#34;); std::string yield = Format(\u0026#34;{{{0}}}\u0026#34;, \u0026#34;text\u0026#34;); std::string yield = Format(\u0026#34;{{{0}, {2}\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;); std::string yield = Format(\u0026#34;test-{2}{1}{0}\u0026#34;, 11, 22, 33); std::string yield = Format(\u0026#34;{}{}{0}!!\u0026#34;, 11, 22); 这个简易实现代码的问题在于它只能接受10个 id，只是在字符串语法层面完成了基础的功能，接下来我们看一下llvm format的实现。\n3. LLVM formatv源码分析 LLVM formatv使用了LLVM Support 和 ADT 库做支持。这里我提供抽离出 LLVM format 组件后的仓库：https://github.com/CanftIn/formatv，这个修改后的format库仅依赖于标准库，便于我们进行代码分析。\n3.1 FormatVariadicDetails 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 // 这是一个模板结构，充当自定义的格式提供者。 // 用户应该为特定的类型特化这个模板以提供格式化功能。 template \u0026lt;typename T, typename Enable = void\u0026gt; struct FormatProvider {}; namespace Internal { // 它是一个抽象基类，定义了一个纯虚函数format。所有适配器类都需要继承这个基类并实现这个函数。 class FormatAdapter { public: virtual void format(std::ostream\u0026amp; os, std::string options) = 0; protected: virtual ~FormatAdapter() = default; private: virtual void anchor() {} }; // ProviderFormatAdapter 和 StreamOperatorFormatAdapter 类: // 这两个类都是FormatAdapter的具体子类。 // // ProviderFormatAdapter使用FormatProvider为特定类型进行格式化， // 而StreamOperatorFormatAdapter则使用流插入运算符(\u0026lt;\u0026lt;)为类型进行格式化。 template \u0026lt;typename T\u0026gt; class ProviderFormatAdapter : public FormatAdapter { public: explicit ProviderFormatAdapter(T\u0026amp;\u0026amp; item) : item_(std::forward\u0026lt;T\u0026gt;(item)) {} void format(std::ostream\u0026amp; os, std::string options) override { FormatProvider\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::format(item_, os, options); } private: T item_; }; template \u0026lt;typename T\u0026gt; class StreamOperatorFormatAdapter : public FormatAdapter { public: explicit StreamOperatorFormatAdapter(T\u0026amp;\u0026amp; item) : item_(std::forward\u0026lt;T\u0026gt;(item)) {} void format(std::ostream\u0026amp; os, std::string /*options*/) override { os \u0026lt;\u0026lt; item_; } private: T item_; }; template \u0026lt;typename T\u0026gt; class MissingFormatAdapter; template \u0026lt;typename T, T\u0026gt; struct SameType; // HasFormatProvider 和 HasStreamOperator 类: // 这两个模板结构用于检查一个给定的类型是否有与FormatProvider或流插入运算符相关的格式化功能。 // FormatProvider should have the signature: // static void format(const T\u0026amp;, raw_stream \u0026amp;, StringRef); template \u0026lt;class T\u0026gt; class HasFormatProvider { public: using Decayed = std::decay_t\u0026lt;T\u0026gt;; using SignatureFormat = void (*)(const Decayed\u0026amp;, std::ostream\u0026amp;, std::string); template \u0026lt;typename U\u0026gt; static auto test(SameType\u0026lt;SignatureFormat, \u0026amp;U::format\u0026gt;*) -\u0026gt; char; template \u0026lt;typename U\u0026gt; static auto test(...) -\u0026gt; double; static constexpr bool const Value = (sizeof(test\u0026lt;FormatProvider\u0026lt;Decayed\u0026gt;\u0026gt;(nullptr)) == 1); }; template \u0026lt;class T\u0026gt; class HasStreamOperator { public: using ConstRefT = const std::decay_t\u0026lt;T\u0026gt;\u0026amp;; template \u0026lt;typename U\u0026gt; static auto test( std::enable_if_t\u0026lt;std::is_same_v\u0026lt;decltype(std::declval\u0026lt;std::ostream\u0026amp;\u0026gt;() \u0026lt;\u0026lt; std::declval\u0026lt;U\u0026gt;()), std::ostream\u0026amp;\u0026gt;, int*\u0026gt;) -\u0026gt; char; template \u0026lt;typename U\u0026gt; static auto test(...) -\u0026gt; double; static constexpr bool const Value = (sizeof(test\u0026lt;ConstRefT\u0026gt;(nullptr)) == 1); }; // Uses* 结构: // 这些结构根据上面的检查，决定哪种适配器应该用于给定的类型。 template \u0026lt;typename T\u0026gt; struct UsesFormatMember : public std::integral_constant\u0026lt; bool, std::is_base_of_v\u0026lt;FormatAdapter, std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt;\u0026gt; { }; template \u0026lt;typename T\u0026gt; struct UsesFormatProvider : public std::integral_constant\u0026lt;bool, !UsesFormatMember\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; HasFormatProvider\u0026lt;T\u0026gt;::Value\u0026gt; {}; template \u0026lt;typename T\u0026gt; struct UsesStreamOperator : public std::integral_constant\u0026lt;bool, !UsesFormatMember\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; !UsesFormatProvider\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; HasStreamOperator\u0026lt;T\u0026gt;::Value\u0026gt; {}; template \u0026lt;typename T\u0026gt; struct UsesMissingProvider : public std::integral_constant\u0026lt;bool, !UsesFormatMember\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; !UsesFormatProvider\u0026lt;T\u0026gt;::value \u0026amp;\u0026amp; !HasStreamOperator\u0026lt;T\u0026gt;::Value\u0026gt; {}; // build_format_adapter 函数模板: // 这是一个函数模板的重载集合，根据对象的类型选择合适的格式适配器， // 并将对象传递给适配器进行格式化。它使用SFINAE来选择适当的重载版本， // 根据对象是否满足不同的格式化要求。 template \u0026lt;typename T\u0026gt; auto build_format_adapter(T\u0026amp;\u0026amp; item) -\u0026gt; std::enable_if_t\u0026lt;UsesFormatMember\u0026lt;T\u0026gt;::value, T\u0026gt; { return std::forward\u0026lt;T\u0026gt;(item); } template \u0026lt;typename T\u0026gt; auto build_format_adapter(T\u0026amp;\u0026amp; item) -\u0026gt; std::enable_if_t\u0026lt;UsesFormatProvider\u0026lt;T\u0026gt;::value, ProviderFormatAdapter\u0026lt;T\u0026gt;\u0026gt; { return ProviderFormatAdapter\u0026lt;T\u0026gt;(std::forward\u0026lt;T\u0026gt;(item)); } template \u0026lt;typename T\u0026gt; auto build_format_adapter(T\u0026amp;\u0026amp; item) -\u0026gt; std::enable_if_t\u0026lt;UsesStreamOperator\u0026lt;T\u0026gt;::value, StreamOperatorFormatAdapter\u0026lt;T\u0026gt;\u0026gt; { return StreamOperatorFormatAdapter\u0026lt;T\u0026gt;(std::forward\u0026lt;T\u0026gt;(item)); } template \u0026lt;typename T\u0026gt; auto build_format_adapter(T\u0026amp;\u0026amp; item) -\u0026gt; std::enable_if_t\u0026lt;UsesMissingProvider\u0026lt;T\u0026gt;::value, MissingFormatAdapter\u0026lt;T\u0026gt;\u0026gt; { return MissingFormatAdapter\u0026lt;T\u0026gt;(std::forward\u0026lt;T\u0026gt;(item)); } } // namespace Internal 这里先简单讲一下上面用到的适配器模式。\n1. 适配器模式简单示例：\n假设我们有一个旧的系统，其中有一个 OldPrinter 类可以打印简单的文本消息。现在我们想要一个新的打印机类 NewPrinter，它可以打印富文本。但我们不想改变旧代码。我们可以使用适配器模式来实现这一目标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 旧的打印机 class OldPrinter { public: void printSimpleMessage(const std::string\u0026amp; msg) { std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; // 新的打印机 class NewPrinter { public: void printRichMessage(const std::string\u0026amp; msg) { // 假设这里有一些富文本处理 std::cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;rich\u0026gt;\u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; \u0026#34;\u0026lt;/rich\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 适配器 class PrinterAdapter : public OldPrinter { NewPrinter newPrinter; public: void printSimpleMessage(const std::string\u0026amp; msg) override { newPrinter.printRichMessage(msg); } }; int main() { PrinterAdapter adaptedPrinter; adaptedPrinter.printSimpleMessage(\u0026#34;Hello, Adapter Pattern!\u0026#34;); return 0; } 输出：\n1 \u0026lt;rich\u0026gt;Hello, Adapter Pattern!\u0026lt;/rich\u0026gt; 2. 大型项目实际使用的代码例子：\n在大型项目中，数据库迁移是一个常见的场景。假设我们的项目最初使用 SQLite，但现在想迁移到 PostgreSQL。这两个数据库在某些查询语法上可能有所不同。我们可以使用适配器模式来确保代码的一致性。\n首先，定义一个数据库接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Database { public: virtual void connect() = 0; virtual void query(const std::string\u0026amp; q) = 0; }; class SQLite : public Database { // 实现SQLite的具体逻辑 }; class PostgreSQL : public Database { // 实现PostgreSQL的具体逻辑 }; class DatabaseAdapter : public SQLite { PostgreSQL pg; public: void connect() override { pg.connect(); } void query(const std::string\u0026amp; q) override { // 可能需要将SQLite的查询语法转换为PostgreSQL的查询语法 pg.query(convertQuery(q)); } std::string convertQuery(const std::string\u0026amp; q) { // 实现转换逻辑 return q; } }; 在上面提供的 format 代码部分中，适配器模式的使用有其特定的优点：\n统一格式化接口： 虽然不同的数据类型可能有不同的格式化需求和实现，但使用适配器模式可以为所有这些类型提供统一的格式化接口。这意味着无论数据类型的内部如何，调用代码只需知道如何与FormatAdapter接口交互。\n解耦： 适配器模式允许将数据类型的具体格式化逻辑从其使用方式中分离出来。这意味着，如果某个类型的格式化逻辑需要更改，那么只需要更改相应的适配器或 FormatProvider，而不需要更改调用格式化功能的其他部分。\n灵活性： 使用适配器模式，可以轻松地为不支持默认格式化（例如流运算符）的类型提供自定义的格式化方法。\n扩展性： 如果在未来需要添加对新的数据类型或格式化方法的支持，只需添加新的 FormatProvider 或适配器，而无需修改现有的调用代码。\n可维护性： 由于格式化逻辑与其使用方式分离，因此更容易维护。对一个类型的格式化逻辑的更改不会影响其他类型或调用代码。\n降低复杂性： 通过提供一个统一的接口和几个适配器，可以将复杂的格式化决策和逻辑隐藏在适配器模式的实现中，从而降低客户端代码的复杂性。\n更好的代码组织： 有了明确的结构和分离的职责，代码组织得更加清晰。每个适配器或 FormatProvider 都有其明确的目的，使得开发人员更容易理解和跟踪代码的工作方式。\n总的来说，适配器模式提供了一种灵活、扩展性强并且易于维护的方法，来处理可能存在的不同的格式化需求。\n3.2 FormatAlign 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 enum class AlignStyle : uint8_t { Left, // \u0026#34;-\u0026#34; Center, // \u0026#34;=\u0026#34; Right, // \u0026#34;+\u0026#34; }; struct FormatAlign { Internal::FormatAdapter\u0026amp; adapter_; // 引用要格式化并对齐的FormatAdapter。 AlignStyle where_; // 一个指示如何对齐输出的AlignStyle枚举值。 size_t amount_; // 指示总共需要多少字符宽度的大小。 char fill_; // 当输出的文本不足指定的字符宽度时，用来填充的字符，默认为空格。 FormatAlign(Internal::FormatAdapter\u0026amp; adapter, AlignStyle where, size_t amount, char fill = \u0026#39; \u0026#39;) : adapter_(adapter), where_(where), amount_(amount), fill_(fill) {} void format(std::ostream\u0026amp; os, std::string options) { if (amount_ == 0) { adapter_.format(os, options); return; } std::ostringstream stream; adapter_.format(stream, options); std::string item = stream.str(); if (amount_ \u0026lt;= item.size()) { os \u0026lt;\u0026lt; item; return; } size_t pad_amount = amount_ - item.size(); switch (where_) { case AlignStyle::Left: os \u0026lt;\u0026lt; item; fill(os, pad_amount); break; case AlignStyle::Center: { size_t x = pad_amount / 2; fill(os, x); os \u0026lt;\u0026lt; item; fill(os, pad_amount - x); break; } default: fill(os, pad_amount); os \u0026lt;\u0026lt; item; break; } } private: void fill(std::ostream\u0026amp; os, uint32_t count) { for (uint32_t i = 0; i \u0026lt; count; ++i) { os \u0026lt;\u0026lt; fill_; } } }; 这段代码定义了一个关于文本对齐的功能。它能够对 FormatAdapter 的输出进行对齐。\nAlignStyle 枚举类：\n这是一个指示对齐方式的枚举。有三种对齐方式：左对齐、居中和右对齐，它们被标记为 \u0026ldquo;-\u0026rdquo;, \u0026ldquo;=\u0026rdquo; 和 \u0026ldquo;+\u0026quot;。 FormatAlign 结构体：\n这个结构体的目的是对一个给定的 FormatAdapter 的输出进行对齐。\nformat 方法是这个结构体的核心，它的目的是首先使用 adapter_ 来获取要对齐的字符串，并将其对齐到指定的宽度 amount_。具体的对齐方式取决于 where_ 成员的值。\nfill 是一个私有的辅助函数，用于在 std::ostream 中插入指定数量的 fill_ 字符。\n此部分代码允许用户指定文本的对齐方式和宽度，并选择填充字符。例如，用户可能希望将数字对齐到右侧，使用空格作为填充字符，以使所有数字都能在相同的宽度内对齐。\n假设有一个可以使用 FormatAdapter 接口的数字，并且将这个数字格式化为10个字符宽，并将其居中对齐，使用 \u0026lsquo;.\u0026rsquo; 作为填充字符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; int main() { std::ostringstream num_stream; num_stream \u0026lt;\u0026lt; 12345; Internal::FormatAdapter adapter; FormatAlign align(adapter, AlignStyle::Center, 10, \u0026#39;.\u0026#39;); std::ostringstream final_stream; align.format(final_stream, \u0026#34;\u0026#34;); std::cout \u0026lt;\u0026lt; final_stream.str() \u0026lt;\u0026lt; std::endl; // 输出: \u0026#34;...12345...\u0026#34; return 0; } 3.3 FormatVariadic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 // 格式化字符串中的替换操作类型。 enum class ReplacementType : uint8_t { Empty, // 表示没有替换。 Format, // 表示应该格式化和替换的项目。 Literal, // 表示应原样插入的字符串字面量。 }; // 保存每个替换项的格式说明详情。 struct ReplacementItem { ReplacementItem() = default; explicit ReplacementItem(std::string literal) : type(ReplacementType::Literal), spec(std::move(literal)) {} ReplacementItem(std::string spec, size_t index, size_t align, AlignStyle where, char pad, std::string options) : type(ReplacementType::Format), spec(std::move(spec)), index(index), align(align), where(where), pad(pad), options(std::move(options)) {} // 替换的类型。 ReplacementType type = ReplacementType::Empty; // 来自格式的原始字符串。 std::string spec; // 要替换的值的索引。 size_t index = 0; // align, where, pad: 对齐的规格说明。 size_t align = 0; // 对齐大小。 AlignStyle where = AlignStyle::Right; // 对齐样式。 char pad = 0; // 填充字符。 // 替换项的其他格式选项。 std::string options; }; class FormatvObjectBase; auto operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const FormatvObjectBase\u0026amp; obj) -\u0026gt; std::ostream\u0026amp;; // 用于格式化对象的基类。 class FormatvObjectBase { public: FormatvObjectBase(const FormatvObjectBase\u0026amp;) = delete; auto operator=(const FormatvObjectBase\u0026amp;) -\u0026gt; FormatvObjectBase\u0026amp; = delete; // 根据替换项格式化字符串并将其写入给定的ostream。 void format(std::ostream\u0026amp; os) const { for (auto\u0026amp; r : ParseFormatString(fmt_)) { switch (r.type) { case ReplacementType::Empty: continue; case ReplacementType::Literal: os \u0026lt;\u0026lt; r.spec; continue; case ReplacementType::Format: { if (r.index \u0026gt;= adapters_.size()) { os \u0026lt;\u0026lt; r.spec; continue; } auto* w = adapters_[r.index]; FormatAlign align(*w, r.where, r.align, r.pad); align.format(os, r.options); } default: continue; } } } // 解析格式字符串以获取替换项列表。 static auto ParseFormatString(std::string fmt) -\u0026gt; std::vector\u0026lt;ReplacementItem\u0026gt; { std::vector\u0026lt;ReplacementItem\u0026gt; replacements; ReplacementItem i; while (!fmt.empty()) { std::tie(i, fmt) = SplitLiteralAndReplacement(fmt); if (i.type != ReplacementType::Empty) { replacements.push_back(i); } } return replacements; } // 将单个替换规格解析为ReplacementItem。 static auto ParseReplacementItem(std::string spec) -\u0026gt; std::optional\u0026lt;ReplacementItem\u0026gt; { // 移除 spec 字符串的 { 和 }。 std::string rep_string = FormatUtil::trim(spec, \u0026#34;{}\u0026#34;); char pad = \u0026#39; \u0026#39;; std::size_t align = 0; AlignStyle where = AlignStyle::Right; std::string options; size_t index = 0; // 移除 rep_string 的前后空白字符。 rep_string = FormatUtil::trim(rep_string); // 尝试从 rep_string 开始的位置解析一个整数，并将其赋值给 index。 if (FormatUtil::ConsumeInteger(rep_string, 0, index)) { assert(false \u0026amp;\u0026amp; \u0026#34;Invalid replacement sequence index!\u0026#34;); return ReplacementItem{}; } rep_string = FormatUtil::trim(rep_string); // 第一个字符为 `,`，它将尝试解析字段布局。 // `,`: 通常是用于字段布局或对齐的指示符。 // 例如，`{0,10}`，其中 0 是要替换的参数索引， // 10 是指示字段宽度或对齐的数字。`,` 符号在此处用作分隔符。 if (!rep_string.empty() \u0026amp;\u0026amp; rep_string.front() == \u0026#39;,\u0026#39;) { rep_string = FormatUtil::drop_front(rep_string, 1); if (!ConsumeFieldLayout(rep_string, where, align, pad)) { assert(false \u0026amp;\u0026amp; \u0026#34;Invalid replacement field layout specification!\u0026#34;); } } rep_string = FormatUtil::trim(rep_string); // 第一个字符是否为 `:`，它会从 rep_string 中提取选项字符串。 // `:`: 这通常是用于格式选项的指示符。 // 例如， `{0:0.00}`，其中 0 是要替换的参数索引，0.00 是指示 // 如何格式化数字的选项（例如，始终显示两位小数）。 if (!rep_string.empty() \u0026amp;\u0026amp; rep_string.front() == \u0026#39;:\u0026#39;) { rep_string = FormatUtil::drop_front(rep_string, 1); options = FormatUtil::trim(rep_string); rep_string = \u0026#34;\u0026#34;; } rep_string = FormatUtil::trim(rep_string); if (!rep_string.empty()) { assert(false \u0026amp;\u0026amp; \u0026#34;Unexpected characters found in replacement string!\u0026#34;); } return ReplacementItem{spec, index, align, where, pad, options}; } // 返回格式化的字符串。 auto str() const -\u0026gt; std::string { std::ostringstream stream; stream \u0026lt;\u0026lt; *this; std::string result = stream.str(); stream.flush(); return result; } // 将对象转换为字符串。 operator std::string() const { return str(); } protected: FormatvObjectBase(std::string fmt, ArrayRef\u0026lt;Internal::FormatAdapter*\u0026gt; adapters) : fmt_(std::move(fmt)), adapters_(adapters.begin(), adapters.end()) {} FormatvObjectBase(FormatvObjectBase\u0026amp;\u0026amp;) = default; // 解析对齐、填充和宽度规格。 static auto ConsumeFieldLayout(std::string\u0026amp; spec, AlignStyle\u0026amp; where, size_t\u0026amp; align, char\u0026amp; pad) -\u0026gt; bool { where = AlignStyle::Right; align = 0; pad = \u0026#39; \u0026#39;; if (spec.empty()) { return true; } if (spec.size() \u0026gt; 1) { if (auto loc = FormatUtil::TranslateLocChar(spec[1])) { pad = spec[0]; where = *loc; spec = FormatUtil::drop_front(spec, 2); } else if (auto loc = FormatUtil::TranslateLocChar(spec[0])) { where = *loc; spec = FormatUtil::drop_front(spec, 1); } } bool failed = FormatUtil::ConsumeInteger(spec, 0, align); return !failed; } // 从输入的 fmt 字符串中分离字面量和替换项。 // 即它寻找 `{...}` 结构中的替换项，并将其与其前面的字面量一起返回。 // 如果找到一个连续的 `{` 或者 `{{`，它将按照适当的逻辑对其进行处理。 static auto SplitLiteralAndReplacement(std::string fmt) -\u0026gt; std::pair\u0026lt;ReplacementItem, std::string\u0026gt; { while (!fmt.empty()) { // 处理没有 { 开头的字符串。 if (fmt.front() != \u0026#39;{\u0026#39;) { std::size_t bo = FormatUtil::find_first_of(fmt, \u0026#39;{\u0026#39;); return std::make_pair(ReplacementItem{FormatUtil::substr(fmt, 0, bo)}, FormatUtil::substr(fmt, bo)); } // 处理连续的 { 字符。 // 如果找到一个或多个 {，它会尝试获取连续的 { 个数，并将其保存在 braces 中。 std::string braces = FormatUtil::take_while(fmt, [](char c) { return c == \u0026#39;{\u0026#39;; }); // 如果连续的 `{` 个数大于1（即 `{{`），它将其解释为转义字符， // 并只保留其中一半作为字面量返回。剩下的部分被视为后续的字符串。 if (braces.size() \u0026gt; 1) { size_t num_excaped_braces = braces.size() / 2; std::string middle = FormatUtil::take_front(fmt, num_excaped_braces); std::string right = FormatUtil::drop_front(fmt, num_excaped_braces * 2); return std::make_pair(ReplacementItem{middle}, right); } // 查找匹配的 }。 std::size_t bc = FormatUtil::find_first_of(fmt, \u0026#39;}\u0026#39;); if (bc == std::string::npos) { assert(false \u0026amp;\u0026amp; \u0026#34;Unterminated brace sequence. Escape with {{ for a literal \u0026#34; \u0026#34;brace.\u0026#34;); return std::make_pair(ReplacementItem{fmt}, std::string()); } // 查找嵌套的 {。 std::size_t bo2 = FormatUtil::find_first_of(fmt, \u0026#39;{\u0026#39;, 1); if (bo2 \u0026lt; bc) { return std::make_pair(ReplacementItem{FormatUtil::substr(fmt, 0, bo2)}, FormatUtil::substr(fmt, bo2)); } // 处理格式说明符。 // 在 { 和 } 之间的字符串被视为替换项的格式说明符。 std::string spec = FormatUtil::slice(fmt, 1, bc); std::string right = FormatUtil::substr(fmt, bc + 1); // 调用 ParseReplacementItem 函数来解析这个说明符。 auto ri = ParseReplacementItem(spec); // 解析成功，它返回解析得到的 ReplacementItem 和 } 之后的字符串。 if (ri) { return std::make_pair(*ri, right); } // 上述所有情况都没有返回结果，函数将删除 fmt 中到 bc 位置之前的所有字符，并继续循环。 fmt = FormatUtil::drop_front(fmt, bc + 1); } // 遍历完整个 fmt 字符串仍然没有找到任何替换项，它将返回整个字符串作为字面量。 return std::make_pair(ReplacementItem{fmt}, std::string()); } std::string fmt_; ArrayRef\u0026lt;Internal::FormatAdapter*\u0026gt; adapters_; }; // 允许直接将格式化的结果流式传输到输出流。 inline auto operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const FormatvObjectBase\u0026amp; obj) -\u0026gt; std::ostream\u0026amp; { obj.format(os); return os; } // 表示具有特定参数的格式化操作的模板类。 // 它捕获格式字符串和作为元组的格式化值。 // 保存每个参数的格式适配器的指针，这些适配器知道如何格式化该特定类型。 template \u0026lt;typename Tuple\u0026gt; class FormatvObject : public FormatvObjectBase { public: FormatvObject(std::string fmt, Tuple\u0026amp;\u0026amp; params) : FormatvObjectBase(fmt, parameter_pointers_), parameters_(std::move(params)), parameter_pointers_(std::apply(CreateAdapters(), parameters_)) {} FormatvObject(const FormatvObject\u0026amp; rhs) = delete; FormatvObject(FormatvObject\u0026amp;\u0026amp; rhs) : FormatvObjectBase(std::move(rhs)), parameters_(std::move(rhs.parameters_)) { parameter_pointers_ = std::apply(CreateAdapters(), parameters_); adapters_ = parameter_pointers_; } private: // 创建格式适配器。 struct CreateAdapters { template \u0026lt;typename... Ts\u0026gt; auto operator()(Ts\u0026amp;... items) -\u0026gt; std::array\u0026lt;Internal::FormatAdapter*, std::tuple_size\u0026lt;Tuple\u0026gt;::value\u0026gt; { return {{\u0026amp;items...}}; } }; Tuple parameters_; std::array\u0026lt;Internal::FormatAdapter*, std::tuple_size\u0026lt;Tuple\u0026gt;::value\u0026gt; parameter_pointers_; }; /// // 用户创建格式化字符串的主要接口。 /// // Convert to std::string. /// std::string S = formatv(\u0026#34;{0} {1}\u0026#34;, 1234.412, \u0026#34;test\u0026#34;).str(); /// /// OS \u0026lt;\u0026lt; formatv(\u0026#34;{0} {1}\u0026#34;, 1234.412, \u0026#34;test\u0026#34;); template \u0026lt;typename... Ts\u0026gt; inline auto formatv(const char* fmt, Ts\u0026amp;\u0026amp;... vals) -\u0026gt; FormatvObject\u0026lt;decltype(std::make_tuple( Internal::build_format_adapter(std::forward\u0026lt;Ts\u0026gt;(vals))...))\u0026gt; { using ParamTuple = decltype(std::make_tuple( Internal::build_format_adapter(std::forward\u0026lt;Ts\u0026gt;(vals))...)); return FormatvObject\u0026lt;ParamTuple\u0026gt;( fmt, std::make_tuple( Internal::build_format_adapter(std::forward\u0026lt;Ts\u0026gt;(vals))...)); } 单独对 SplitLiteralAndReplacement 函数中多个连续{，只保留其中一半作为字面量返回的原因：\n这种处理方式是为了使得格式化字符串中可以包含字面量的大括号 { 和 }。在许多格式化库中，{ 和 } 用于定义变量替换的位置，但如果你真的想在结果字符串中包含一个 { 或 } 怎么办呢？这时，你就需要一种方法来\u0026quot;转义\u0026quot;这些特殊字符，使它们被解释为普通字符。\n为了实现这一目的，这段代码使用了一个简单的规则：连续的两个 { 被解释为一个字面量的 {。同样，连续的两个 } 被解释为一个字面量的 }。\n考虑以下格式化字符串：\n1 \u0026#34;Hello {{name}}! The braces are: {{ and }}\u0026#34; 在这个字符串中，{{name}} 是一个变量替换，而连续的 {{ 和 }} 是转义的大括号。当这个格式化字符串被处理时，它应该产生以下输出（假设 name 被替换为 \u0026ldquo;Alice\u0026rdquo;）：\n1 \u0026#34;Hello Alice! The braces are: { and }\u0026#34; 所以，连续的 {{ 被解释为单个的 {，连续的 }} 被解释为单个的 }，这就是为什么只保留一半的原因。\n3.4 Format Format 接口不做赘述，主要使用 std::snprintf 作为内部输出函数，主体实现方式和 FormatVariadic 类似。\n至此对llvm中format部分的分析结束。\n4. 引用 [1]. https://zh.cppreference.com/w/cpp/header/format\n[2]. https://llvm.org/docs/ProgrammersManual.html#formatting-strings-the-formatv-function\n[3]. https://github.com/CanftIn/formatv\n","permalink":"https://canftin.github.io/posts/tech/p10_llvm_analysis_0_formatv/","summary":"这篇文章作为LLVM源码分析系列的开篇，初步介绍LLVM中format的相关机制和原理，format在LLVM中较为容易理解，从这里启航，后","title":"LLVM源码分析系列(0): formatv"},{"content":" 为什么不直接在tree中放NodeImpl*指针，NodeImpl指向自己的其他结点，而要用smallvector记录索引的方式，两者相比后者有什么好处？\n使用 NodeImpl* 指针直接连接节点之间的关系是一种常见的方式来构建解析树，这被称为 \u0026ldquo;树的引用链接\u0026rdquo;。虽然这是一种有效的方法，但使用 llvm::SmallVector 记录索引的方式有一些优势：\n内存连续性: 当使用 NodeImpl* 指针直接链接节点时，每个节点都需要一个额外的指针字段来引用其子节点。这可能导致节点的内存分布不连续，因为子节点可以位于内存中的任何位置。相比之下，使用索引的方式可以保持节点在内存中的连续性，这可以提高内存访问的效率。\n内存效率: 使用索引可以显著降低每个节点的内存开销。指针通常需要占用4字节（32位系统）或8字节（64位系统）的内存，而索引通常可以用较少的字节来表示。这对于大型解析树来说是一个重要的考虑因素，因为可以减少内存占用。\n数据的一致性和稳定性: 使用索引的方式可以使解析树的节点保持更加一致和稳定的状态。如果使用 NodeImpl* 直接链接节点，当解析树进行动态修改时，可能需要频繁地调整指针以反映新的结构。这可能会引入潜在的 bug 和不稳定性。使用索引，解析树的结构更容易维护，因为节点之间的链接不会频繁更改。\n总之，使用 llvm::SmallVector 记录索引的方式可以提高内存和性能效率，同时保持解析树的数据一致性和稳定性。\n深度优先后序遍历是什么，反向后序（reverse postorder即RPO）遍历是什么，举例详细解释：\n深度优先后序遍历：深度优先后序遍历是一种树或图遍历算法，它首先从根节点开始，深度优先地遍历树的每个分支，然后在返回根节点之前，遍历子节点。具体来说，遍历顺序如下： 从根节点开始，递归地遍历第一个子节点。 在子节点的子树上递归地执行相同的步骤，直到达到叶子节点。 然后返回父节点，继续递归到下一个兄弟节点（如果存在）。 最终，回到根节点，遍历完成。 深度优先后序遍历的一个关键特点是，在访问任何节点之前，它会首先访问该节点的所有子节点。这使得该遍历方式特别适用于树结构的处理，例如解析树。\n反向后序（RPO）遍历：反向后序遍历是深度优先后序遍历的一种变体，它的遍历顺序是相反的，即从根节点开始，首先遍历兄弟节点，然后递归到子节点。具体来说，遍历顺序如下： 从根节点开始，遍历所有兄弟节点。 对于每个兄弟节点，递归地执行相同的步骤，首先遍历其兄弟节点，然后递归到子节点。 最终，回到根节点，遍历完成。 反向后序遍历与深度优先后序遍历相比，更注重在兄弟节点之间的顺序，而不是子节点的顺序。这种遍历方式通常用于图的拓扑排序或执行后续遍历算法的情况。\n举例详细解释：\n假设有以下简单的树结构表示数学表达式：\n1 2 3 4 5 6 + ├── 2 ├── * │ ├── 3 │ └── 4 └── 5 深度优先后序遍历：遍历顺序是 2, 3, 4, *, 5, +。首先深度遍历左子树，然后返回到根节点，再遍历右子树。\n反向后序遍历：遍历顺序是 2, 3, 4, 5, *, +。首先遍历兄弟节点，然后递归到子节点。\n总之，深度优先后序遍历和反向后序遍历是两种不同的遍历方式，它们在遍历节点的顺序上有所不同，适用于不同的应用场景。\n","permalink":"https://canftin.github.io/posts/tech/p9_compiler_build_8_parse_tree/","summary":"为什么不直接在tree中放NodeImpl*指针，NodeImpl指向自己的其他结点，而要用smallvector记录索引的方式，两者相比后","title":"从零构造现代语言编译器(8): 解析树"},{"content":"表达式 目录 表达式 目录 概述 优先级 名称 非限定名称 限定名称和成员访问 操作符 转换和类型转换 if 表达式 数值类型文字表达式 考虑的替代方案 参考文献 概述 表达式是 Carbon 语法中产生值的部分。因为在 Carbon 中，类型是值，所以这包括指定类型的任何地方。\n1 2 3 fn Foo(a: i32*) -\u0026gt; i32 { return *a; } 这里，参数类型 i32*、返回类型 i32 和 return 语句的操作数 *a 都是表达式。\n优先级 表达式基于部分优先级排序进行解释。 缺少相对排序的表达式组件必须由开发者进行消歧，例如通过添加括号；否则，由于模糊性，表达式将无效。 只有当大多数开发者在没有括号的情况下都能理解优先级时，才会添加优先级排序。\n优先级图定义如下：\n1 ... (此处省略了图的内容，因为它是图形内容，不适合文字翻译) 图的属性包括：\n每个非空节点代表一个优先级组。空圈用于简化图形，并不代表优先级组。\n当一个表达式由不同的优先级组组成时，解释由优先级边确定：\n优先级边 A \u0026ndash;\u0026gt; B 表示 A 的优先级低于 B，所以 A 可以不用括号包含 B。例如，or --\u0026gt; not 表示 not x or y 被视为 (not x) or y。\n优先级边是传递的。例如，or --\u0026gt; == --\u0026gt; as 表示 or 的优先级低于 as。\n当一个二元操作符表达式由单个优先级组组成时，解释由优先级组的结合性确定：\n1 2 3 graph TD non[\u0026#34;非结合性\u0026#34;] left[\u0026#34;左结合性\u0026#34;] 例如，+ 和 - 是左结合的，并且在同一个优先级组中，所以 a + b + c - d 被视为 ((a + b) + c) - d。\n注意，在 Carbon 中，我们目前只有左结合操作符。与 C++ 和其他语言不同，赋值不是右结合操作符，它使用自己的语句。\n当一个一元操作符表达式由单个优先级组组成时，它可以允许不带括号的重复或不允许：\n1 2 3 graph TD non[\u0026#34;非重复\u0026#34;] repeating[\u0026#34;重复\u0026#34;] 这与二元操作符的结合性类似。\n名称 非限定名称 非限定名称 是一个单词，它不是关键字，并且前面没有句点(.)。\n待办事项: 非限定名称的名称查找规则。\n限定名称和成员访问 限定名称 是一个单词，它紧跟在句点或向右的箭头后面。限定名称出现在以下上下文中：\n指定符：. 单词 简单成员访问表达式：表达式 . 单词 简单指针成员访问表达式：表达式 -\u0026gt; 单词 1 2 3 4 5 6 7 8 9 10 11 var x: auto = {.hello = 1, .world = 2}; ^^^^^ ^^^^^ 限定名称 ^^^^^^ ^^^^^^ 指定符 x.hello = x.world; ^^^^^ ^^^^^ 限定名称 ^^^^^^^ ^^^^^^^ 成员访问表达式 x.hello = (\u0026amp;x)-\u0026gt;world; ^^^^^ 限定名称 ^^^^^^^^^^^ 指针成员访问表达式 限定名称引用由表达式出现的上下文确定的实体的成员。对于成员访问，实体由句点前的表达式命名。在结构字面量中，实体是结构类型。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package Foo api; namespace N; fn N.F() {} fn G() { // 与 `(Foo.N).F()` 相同。 // `Foo.N` 命名包 `Foo` 中的命名空间 `N`。 // `(Foo.N).F` 命名命名空间 ` N` 中的函数 `F`。 Foo.N.F(); } // `.n` 引用 `{.n: i32}` 的成员 `n`。 fn H(a: {.n: i32}) -\u0026gt; i32 { // `a.n` 解析为成员 `{.n: i32}.n`， // 并命名 `a` 的相应子对象。 return a.n; } fn J() { // `.n` 引用 `{.n: i32}` 的成员 `n`。 H({.n = 5 as i32}); } 成员访问表达式从左到右关联。如果成员名称比单个 单词 更复杂，可以使用带有括号的成员名称的复合成员访问表达式：\n表达式 . ( 表达式 ) 表达式 -\u0026gt; ( 表达式 ) 1 2 3 4 5 6 interface I { fn F[self: Self](); } class X {} impl X as I { fn F[self: Self]() {} } // `x.I.F()` 将意味着 `(x.I).F()`。 fn Q(x: X) { x.(I.F)(); } 简单或复合成员访问可以是 指针 成员访问表达式的一部分，当使用 -\u0026gt; 而不是 . 时，其中 表达式 -\u0026gt; \u0026hellip; 是 ( * 表达式 ) . \u0026hellip; 的语法糖。\n操作符 大多数表达式都被建模为操作符：\n类别 操作符 语法 功能 指针 * (一元) *x 指针解引用：由 x 指向的对象。 指针 \u0026amp; (一元) \u0026amp;x 地址：指向对象 x 的指针。 算术 - (一元) -x x 的负数。 位运算 ^ (一元) ^x x 的位补数。 算术 + x + y x 和 y 的和。 算术 - (二元) x - y x 和 y 的差。 算术 * x * y x 和 y 的乘积。 算术 / x / y x 除以 y，或其商。 算术 % x % y x 对 y 的模。 位运算 \u0026amp; x \u0026amp; y x 和 y 的位与。 位运算 | x | y x 和 y 的位或。 位运算 ^ (二元) x ^ y x 和 y 的位异或。 位运算 \u0026lt;\u0026lt; x \u0026lt;\u0026lt; y x 左移 y 位。 位运算 \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y x 右移 y 位。 转换 as x as T 将值 x 转换为类型 T。 比较 == x == y 相等：如果 x 等于 y，则为 true。 比较 != x != y 不等：如果 x 不等于 y，则为 true。 比较 \u0026lt; x \u0026lt; y 小于：如果 x 小于 y，则为 true。 比较 \u0026lt;= x \u0026lt;= y 小于或等于：如果 x 小于或等于 y，则为 true。 比较 \u0026gt; x \u0026gt; y 大于：如果 x 大于 y，则为 true。 比较 \u0026gt;= x \u0026gt;= y 大于或等于：如果 x 大于或等于 y ，则为 true。 | | 逻辑 | and | x and y | 短路逻辑与：如果两个操作数都为 true，则为 true。 | | 逻辑 | or | x or y | 短路逻辑或：如果任一操作数为 true，则为 true。 | | 逻辑 | not | not x | 逻辑非：如果操作数为 false，则为 true。 |\n二元算术和位运算操作符还有复合赋值形式。这些是语句而不是表达式，并且不产生值。\n转换和类型转换 当表达式出现在需要特定类型的表达式的上下文中时，将应用隐式转换将表达式转换为目标类型。\n表达式也可以使用as 表达式转换为特定类型。\n1 2 3 4 5 fn Bar(n: i32); fn Baz(n: i64) { // OK，与 Bar(n as i32) 相同 Bar(n); } if 表达式 if 表达式在两个表达式之间进行选择。\n1 2 3 fn Run(args: Span(StringView)) { var file: StringView = if args.size() \u0026gt; 1 then args[1] else \u0026#34;/dev/stdin\u0026#34;; } if 表达式与 C 和 C++ 中的 ?: 三元表达式类似。\n数值类型文字表达式 Carbon 的语法提供了一种简单的方法来表示不同类型的整数和浮点数。每种类型都用类似关键字的语法标识，前缀为 i、u 或 f，后跟 8 的倍数，表示数据类型的位大小。\n这些被称为数值类型文字。\n考虑的替代方案 其他表达式文档将列出更多的替代方案；此处列出的替代方案在其他地方没有提及。\n总顺序 不同操作数的不同优先级 要求少于部分顺序 参考文献 其他表达式文档将列出更多的参考文献；此处列出的参考文献在其他地方没有提及。\n提案 #555: 操作符优先级。 这是使用 markdown 输出格式的中文全文翻译。您还想知道什么？\n%%{init: {'themeVariables': {'fontFamily': 'monospace'}}}%% graph BT parens[\"(...)\"] braces[\"{...}\"] click braces \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/classes.md#literals\" unqualifiedName[\"x\"] click unqualifiedName \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/README.md#unqualified-names\" top((\" \")) memberAccess\u003e\"x.y\nx.(...)\nx-\u003ey\nx-\u003e(...)\"] click memberAccess \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/member_access.md\" constType[\"const T\"] click pointer-type \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/type_operators.md\" pointerType{\"T*\"} click pointer-type \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/type_operators.md\" pointer{\"*x\n\u0026x\n\"} click pointer \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/pointer.md\" negation[\"-x\"] click negation \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/arithmetic.md\" complement[\"^x\"] click complement \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/bitwise.md\" incDec[\"++x;\n--x;\"] click incDec \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/assignment.md\" unary((\" \")) as[\"x as T\"] click as \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/implicit_conversions.md\" multiplication\u003e\"x * y\nx / y\"] click multiplication \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/arithmetic.md\" addition\u003e\"x + y\nx - y\"] click addition \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/arithmetic.md\" modulo[\"x % y\"] click modulo \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/arithmetic.md\" bitwise_and\u003e\"x \u0026 y\"] bitwise_or\u003e\"x | y\"] bitwise_xor\u003e\"x ^ y\"] click bitwise_and \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/bitwise.md\" click bitwise_or \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/bitwise.md\" click bitwise_xor \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/bitwise.md\" shift[\"x \u003c\u003c y\nx \u003e\u003e y\"] click shift \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/bitwise.md\" comparison[\"x == y\nx != y\nx \u003c y\nx \u003c= y\nx \u003e y\nx \u003e= y\"] click comparison \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/comparison_operators.md\" not[\"not x\"] click not \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/logical_operators.md\" logicalOperand((\" \")) and\u003e\"x and y\"] click and \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/logical_operators.md\" or\u003e\"x or y\"] click or \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/logical_operators.md\" logicalExpression((\" \")) if\u003e\"if x then y else z\"] click if \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/if.md\" insideParens[\"(...)\"] assignment[\"x = y;\nx $= y;\"] click assignment \"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/assignment.md\" expressionStatement[\"x;\"] top --\u003e parens \u0026 braces \u0026 unqualifiedName constType --\u003e top pointerType --\u003e constType as --\u003e pointerType memberAccess --\u003e top pointer --\u003e memberAccess negation \u0026 complement \u0026 incDec --\u003e pointer unary --\u003e negation \u0026 complement %% Use a longer arrow here to put `not` next to `and` and `or`. not -------\u003e memberAccess as \u0026 multiplication \u0026 modulo \u0026 bitwise_and \u0026 bitwise_or \u0026 bitwise_xor \u0026 shift --\u003e unary addition --\u003e multiplication comparison --\u003e as \u0026 addition \u0026 modulo \u0026 bitwise_and \u0026 bitwise_or \u0026 bitwise_xor \u0026 shift logicalOperand --\u003e comparison \u0026 not and \u0026 or --\u003e logicalOperand logicalExpression --\u003e and \u0026 or if \u0026 expressionStatement --\u003e logicalExpression insideParens \u0026 assignment --\u003e if ","permalink":"https://canftin.github.io/posts/tech/p8_compiler_build_7_parse_precedence/","summary":"表达式 目录 表达式 目录 概述 优先级 名称 非限定名称 限定名称和成员访问 操作符 转换和类型转换 if 表达式 数值类型文字表达式 考虑的替代方案 参考文献 概述 表达式","title":"从零构造现代语言编译器(7): Parse优先级"},{"content":"1. 节点类型 2. 解析状态 这些状态代表了解析器在处理输入代码时可能遇到的各种情况。以下是对这些状态的详细解释：\nIndexExpression：处理索引表达式，如a[0]。 IndexExpressionFinish：完成索引表达式的处理。 ArrayExpression：处理数组表达式，如[T; N]。 ArrayExpressionSemi：处理数组表达式中的分号。 ArrayExpressionFinish：完成数组表达式的处理。 BraceExpression：处理大括号表达式的开始，如{...}。 BraceExpressionParameter：处理大括号表达式中的参数。 BraceExpressionParameterAfterDesignator：处理大括号表达式中的参数，该参数在一个指示符之后。 BraceExpressionParameterFinish：完成大括号表达式中的参数处理。 BraceExpressionFinish：完成大括号表达式的处理。 CallExpression：处理调用表达式，如func(...)。 CallExpressionParameterFinish：处理调用表达式中的参数后的逗号或括号。 CallExpressionFinish：完成调用表达式的处理。 CodeBlock：处理典型的代码块的开始，如{...}。 CodeBlockFinish：完成代码块的处理。 DeclarationNameAndParams：处理声明的名称和参数，如Foo[...](...)。 DeclarationNameAndParamsAfterName：处理声明名称后的部分。 DeclarationNameAndParamsAfterDeduced：处理推导参数后的部分。 DeclarationScopeLoop：处理声明范围内的内容。 Period：处理点操作，如.。 ArrowExpression：处理箭头表达式，如-\u0026gt;。 Expression：处理表达式。 ExpressionInPostfix：处理后缀表达式的开始部分。 ExpressionInPostfixLoop：处理后缀表达式的循环部分。 ExpressionLoop：处理表达式的循环部分。 IfExpression：处理if表达式。 ParenExpression：处理括号内的表达式，如(expr)。 Statement：处理单个语句。 StatementForHeader：处理for循环头部。 StatementIf：处理if语句。 StatementWhile：处理while循环。 TypeIntroducer：处理类型的引入。 Var：处理var声明。 此外，还有一些宏定义，如COCKTAIL_PARSE_STATE_VARIANT和COCKTAIL_PARSE_STATE_VARIANTS2，它们用于生成更多的状态，这些状态是基于其他状态但带有某种变体的。\n总的来说，这些状态为解析器提供了一个框架，使其能够根据输入代码的不同部分进行适当的处理。\n","permalink":"https://canftin.github.io/posts/tech/p7_compiler_build_6_parse_node_state/","summary":"1. 节点类型 2. 解析状态 这些状态代表了解析器在处理输入代码时可能遇到的各种情况。以下是对这些状态的详细解释： IndexExpression：处理","title":"从零构造现代语言编译器(6): Parse节点和状态"},{"content":" // TODO: 1. 分析老版本mmap的SourceBuffer。\n// TODO: 2. 分vfs版本SourceBuffer。\n// TODO: 3. 分析swift版本source manager和llvm。\n1. 为什么需要SourceBuffer 2. mmap版本SourceBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class SourceBuffer { public: static auto CreateFromText(llvm::Twine text, llvm::StringRef filename = \u0026#34;/text\u0026#34;) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt;; static auto CreateFromFile(llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt;; SourceBuffer() = delete; SourceBuffer(const SourceBuffer\u0026amp;) = delete; SourceBuffer(SourceBuffer\u0026amp;\u0026amp; arg) noexcept; ~SourceBuffer(); [[nodiscard]] auto filename() const -\u0026gt; llvm::StringRef { return filename_; } [[nodiscard]] auto text() const -\u0026gt; llvm::StringRef { return text_; } private: enum class ContentMode { Uninitialized, MMapped, Owned, }; // Constructor for mmapped content. explicit SourceBuffer(std::string filename, llvm::StringRef text); // Constructor for owned content. explicit SourceBuffer(std::string filename, std::string text); ContentMode content_mode_; std::string filename_; std::string text_storage_; llvm::StringRef text_; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 static auto CheckContentSize(int64_t size) -\u0026gt; llvm::Error { if (size \u0026lt; std::numeric_limits\u0026lt;int32_t\u0026gt;::max()) { return llvm::Error::success(); } return llvm::createStringError(llvm::inconvertibleErrorCode(), \u0026#34;Input too large!\u0026#34;); } auto SourceBuffer::CreateFromText(llvm::Twine text, llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt; { std::string buffer = text.str(); auto size_check = CheckContentSize(buffer.size()); if (size_check) { return std::move(size_check); } return SourceBuffer(filename.str(), std::move(buffer)); } static auto ErrnoToError(int errno_value) -\u0026gt; llvm::Error { return llvm::errorCodeToError( std::error_code(errno_value, std::generic_category())); } auto SourceBuffer::CreateFromFile(llvm::StringRef filename) -\u0026gt; llvm::Expected\u0026lt;SourceBuffer\u0026gt; { std::string filename_str = filename.str(); errno = 0; int file_descriptor = open(filename_str.c_str(), O_RDONLY); if (file_descriptor == -1) { return ErrnoToError(errno); } auto closer = llvm::make_scope_exit([file_descriptor] { close(file_descriptor); }); struct stat stat_buffer = {}; errno = 0; if (fstat(file_descriptor, \u0026amp;stat_buffer) == -1) { return ErrnoToError(errno); } int64_t size = stat_buffer.st_size; if (size == 0) { return SourceBuffer(std::move(filename_str), std::string()); } auto size_check = CheckContentSize(size); if (size_check) { return std::move(size_check); } errno = 0; void* mapped_text = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, file_descriptor, /*offset=*/0); if (mapped_text == MAP_FAILED) { return ErrnoToError(errno); } errno = 0; closer.release(); if (close(file_descriptor) == -1) { munmap(mapped_text, size); return ErrnoToError(errno); } return SourceBuffer( std::move(filename_str), llvm::StringRef(static_cast\u0026lt;const char*\u0026gt;(mapped_text), size)); } SourceBuffer::SourceBuffer(SourceBuffer\u0026amp;\u0026amp; arg) noexcept : content_mode_( std::exchange(arg.content_mode_, ContentMode::Uninitialized)), filename_(std::move(arg.filename_)), text_storage_(std::move(arg.text_storage_)), text_(content_mode_ == ContentMode::Owned ? text_storage_ : arg.text_) {} SourceBuffer::SourceBuffer(std::string filename, std::string text) : content_mode_(ContentMode::Owned), filename_(std::move(filename)), text_storage_(std::move(text)), text_(text_storage_) {} SourceBuffer::SourceBuffer(std::string filename, llvm::StringRef text) : content_mode_(ContentMode::MMapped), filename_(std::move(filename)), text_(text) { COCKTAIL_CHECK(!text.empty()) \u0026lt;\u0026lt; \u0026#34;Must not have an empty text when we have mapped data from a file!\u0026#34;; } SourceBuffer::~SourceBuffer() { if (content_mode_ == ContentMode::MMapped) { errno = 0; int result = munmap(const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;const void*\u0026gt;(text_.data())), text_.size()); COCKTAIL_CHECK(result != -1) \u0026lt;\u0026lt; \u0026#34;Unmapping text failed!\u0026#34;; } } 3. llvm::vfs版本SourceBuffer 这段代码定义了一个名为SourceBuffer的类，该类表示Carbon源代码的缓冲区。以下是对这段代码的详细解释：\n注释概述 SourceBuffer：这个类持有Carbon源代码的文本缓冲区，并使其可供Carbon编译器的其余部分使用。它拥有底层源代码文本的内存，并确保其与缓冲区对象一样长寿。\n来源：每个源代码文本缓冲区在概念上都是从Carbon源文件加载的，即使在构造缓冲区时直接提供。还保留并提供了应该用于该Carbon源文件的名称。\n内存管理：由于源代码文本的底层内存可能是从文件中读取的，我们可能希望使用像mmap这样的工具将该文件映射到内存中，所以为了避免需要为映射的文件定义复制语义，缓冲区本身是不可复制的。如果需要，我们可以在未来放宽这一限制，并增加一些实现复杂性。\n类定义 SourceBuffer：这是主要的类定义，它代表了Carbon源代码的缓冲区。 公共成员函数 CreateFromFile：这是一个静态函数，用于从指定的文件名打开一个文件。如果成功，它返回一个SourceBuffer对象；如果失败，它打印一个错误并返回nullopt（即没有有效的SourceBuffer对象）。\n构造函数：默认构造函数被删除，这意味着你不能直接创建一个SourceBuffer对象。你必须使用上面的CreateFromFile函数或其他类似的工厂函数来创建一个SourceBuffer对象。\nfilename：这是一个常量成员函数，返回源文件的名称。\ntext：这是一个常量成员函数，返回源代码文本的引用。\n私有成员 私有构造函数：这个构造函数是私有的，这意味着你不能从类的外部直接调用它。它接受一个文件名和一个llvm::MemoryBuffer的唯一指针，并将它们存储在私有成员变量中。\nfilename_：这是一个私有成员变量，用于存储源文件的名称。\ntext_：这是一个私有成员变量，它是一个指向llvm::MemoryBuffer的唯一指针，用于存储源代码文本。\n总结 SourceBuffer类是用于管理Carbon源代码的缓冲区的。它提供了从文件创建缓冲区的功能，并提供了访问源文件名和源代码文本的方法。为了内存管理和文件映射的方便，这个类是不可复制的。\n","permalink":"https://canftin.github.io/posts/tech/p6_compiler_build_5_source_buffer/","summary":"// TODO: 1. 分析老版本mmap的SourceBuffer。 // TODO: 2. 分vfs版本SourceBuffer。 // TODO: 3. 分析swift版本source mana","title":"从零构造现代语言编译器(5): 缓冲区"},{"content":"1. 注释 在现有的编程语言中，注释有多种用途。主要的用例包括：\n文档：为API的用户和未来的维护者提供人类可读的注释，解释其功能以及如何使用它。这种注释通常附加在函数声明、类定义、公共成员声明、文件范围等API的相似粒度级别上。 1 2 3 4 5 6 7 /// 一个连接小部件集合的容器。 class WidgetAssembly { /// 如果可能的话，改善组件的外观。 void decorate(bool repaint_all = false); // ... }; 实现注释：为代码的未来读者或维护者提供人类可读的注释，解释意图和机制，或总结代码的行为，以避免读者或维护者需要详细阅读它。当这些细节从代码本身可能不容易看出或可能需要非平凡的工作来推断时，通常使用这种注释，而且这种注释往往很短。 1 2 3 4 5 6 7 8 9 10 11 12 void WidgetAssembly::decorate(bool repaint_all) { // ... // 绘制上次更改后的所有小部件。 for (auto \u0026amp;w : widgets) { if (repaint_all || w.modified \u0026gt; last_foo) w.paint(); } last_decorate = now(); // ... } 语法消歧注释：包含代码或伪代码的注释，旨在让人类读者更容易地按照编译器的方式解析代码。 1 2 3 4 5 6 7 8 9 10 void WidgetAssembly::decorate(bool repaint_all /*= false*/) { // ... /*static*/ std::unique_ptr\u0026lt;WidgetAssembly\u0026gt; WidgetAssembly::make() { // ... assembly.decorate(/*repaint_all=*/true); // ... } // 结束命名空间 WidgetLibrary 禁用的代码：包含已被禁用的代码区域的注释，因为代码不完整或不正确，或为了在调试时隔离问题，或作为正在进行的更改的参考材料。通常认为将这样的注释加入版本控制是不良实践。 1.1 背景 在C++中，实际上有三种不同的方式来表示注释：\n1.1.1 行注释 在C++中，单行注释（有时是多行注释）使用// ...表示：\n1 2 // 下一行声明了一个变量。 int n; // 这是关于\u0026#39;n\u0026#39;的注释。 (这些有时被称为\u0026quot;BCPL注释\u0026quot;。)\n可以出现在任何地方（在一行的开头或在标记后）。 可以包含任何文本（除了换行符）。 在逻辑行的末尾结束。 通过在注释末尾添加\\（或在C++14及更早版本中的??/）来继续。 与非注释语法无歧义。 \u0026ldquo;嵌套\u0026rdquo;，即//内的//无效。 不与其他类型的注释嵌套。 这种注释语法经常用来表示文档（有时使用Doxygen风格的///引入符）和实现注释。\n1.1.2 块注释 在C++中，行内注释（有时是多行注释）使用/*...*/表示：\n1 f(/*size*/5, /*initial value*/1); 可以出现在任何地方（在一行的开头或在标记后）。 可以包含任何文本（除了*/）。 在*/分隔符处结束（该分隔符可能由\\行继续分隔）。 与非注释语法有歧义：int a=1, *b=\u0026amp;a, c=a/*b;，尽管这在实践中不是问题。 不嵌套——第一个*/结束了注释。 这种注释语法经常用来表示语法消歧注释，并有时用于禁用的代码。某些编码风格还使用这种注释风格来表示较长的文档注释（有时使用Doxygen风格的/**引入符）。\n1.1.3 #if 0 在C++程序中，代码块经常使用#if 0注释掉：\n1 2 3 #if 0 int n; #endif 只能出现在逻辑行的开头。 只能包含预处理标记序列（包括无效标记，如'，但不包括未终止的多行字符串字面量）。 在匹配的#endif分隔符处结束。 与任何其他语法无歧义。 嵌套得当，并且可以在其中嵌套其他种类的注释。 这种语法通常只用于禁用的代码。\n1.2 详细内容 1.2.1 注释概述 _注释_是一个词法元素，以//字符开始并运行到行的末尾。我们没有物理行继续的机制，所以尾随的\\不会将注释扩展到后续的行。\n试验: 在引入注释的//字符之前不能有其他文本，除了水平空白。要么整行都是注释，要么一点也不是。\n//后的字符必须是一个空白字符。换行符是一个空白字符，所以只包含//的行是一个有效的注释。文件的结尾也构成空白。\n在形成标记之前，所有注释都被删除。\n示例：\n1 2 3 4 // 这是一个注释，会被忽略。\\ 这不是一个注释。 var Int: x; // 错误，不允许尾随注释 1.2.2 块注释 试验: 不提供块注释的支持。通过注释掉区域中的每一行来注释掉大量的人类可读的文本或代码。\n块注释的理由 对于实现注释的用例，支持块注释的价值不大。我们期望这样的注释通常很短，而在现有的C++代码库中，如果有长的实现注释，通常使用的是行注释而不是块注释。因此，由于我们认为文档用例超出了范围，并且打算通过语言语法解决语法消歧用例，块注释的唯一目的就是禁用代码。块注释可以为行内禁用的代码和多行禁用的代码提供更方便的支持。\n现有的块注释语法不适合禁用代码的用例。C++中的/* ... */块注释不嵌套，并且不能用于可靠地注释掉一个代码块，因为它可以被//注释或字符串字面量中的*/终止。#if 0 ... #endif语法不适合Carbon，因为我们不打算通常有一个预处理器，而且需要文本之间的内容由大部分有效的标记序列组成，不允许某些形式的不完整代码。\n我们应该不情愿地发明新东西：为了禁用代码的短暂和罕见的用例，很难证明引入新的语法的成本是合理的。同样，我们应该不情愿地使用现有的语法与新的语义，如一个/* ... */注释，它标记其内容，以避免对C++开发者的惊讶。\n禁用代码的用例可以用行注释来解决，通过注释掉预期区域中的每一行，并在禁用行内的代码时重新排列或复制行。这可能很麻烦，但不清楚这种负担是否足以证明将另一种形式的注释引入到语言中。通过不提供这样的注释形式，我们的目标是发现结果摩擦是否证明了语言的增加。\n1.2.3 保留的注释 //字符后面不跟随空白的注释是为未来的扩展保留的。预期的可能的扩展是块注释、文档注释和代码折叠区域标记。\n保留的注释的理由 我们预期将来可能会增加其他种类的注释。在注释语法中保留语法空间，以便程序容易避免，允许我们将这样的额外注释作为非破坏性的变更添加。\n1.3 考虑的替代方案 1.3.1 行内注释 我们可以包括一个类似于C风格块注释的功能，作为提供附加到小于一行的程序元素的注释的方式。在C++代码中，这样的注释经常用于注释函数参数名称和类似的语法消歧用例：\n1 render(/*use_world_coords=*/true, /*draw_frame=*/false); 我们期望这些用例将由Carbon的语法扩展来解决，例如通过添加命名参数或注释语法，以允许这样的话语以代码而不是注释的形式表示，所以它们对Carbon程序员和Carbon语言工具都是有意义的。\n我们可以允许在包含其他内容的行上的尾部注释。这样的注释在我们的样本C++语料库中经常用于描述同一行上的实体、标签或闭合括号的含义：\n1 2 3 4 5 6 7 namespace N { int n; // number of hats enum Mode { mode1, // first mode mode2 // second mode }; } // end namespace N 除了最后一种情况，我们期望将注释移到声明之前是合理的。\u0026ldquo;end namespace\u0026quot;注释的情况是另一个语法消歧用例，我们期望通过语法更改来解决。总的来说，我们应该避免任何需要消歧注释的语法，要么通过将这些注释提升到语言语法，要么通过更改语法直到注释不再需要，例如不为描述命名空间和包的内容的大范围提供一个分隔的范围语法。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 这声明了命名空间N，但没有打开一个范围。 namespace N; // 这声明了命名空间N的一个成员。 @\u0026#34;Number of hats.\u0026#34; var Int: N.n; enum N.Mode { @\u0026#34;First mode.\u0026#34; mode1; @\u0026#34;Second mode.\u0026#34; mode2; } 行内注释对于代码格式化工具来说是一个挑战，它们需要理解注释\u0026quot;附加到\u0026quot;什么程序语法上，以便正确地将注释与代码重新排列。这种关注通过要求注释始终在自己的行上被缓解，但并没有完全消除。我们可以通过使用方向标记在注释中来允许行内注释，同时仍然保留一些关于注释如何附加的想法：\n1 2 3 4 match (x) { case .Foo(1, 2, //\u0026gt; either 3 or 4 \u0026gt;// Int: n) =\u0026gt; { ... } case .Foo(2, Int: n //\u0026lt; either 3 or 4 \u0026lt;//, 5) =\u0026gt; { ... } } 即使有了理解注释如何附加的方法，行包装这样的注释也是一个复杂的挑战。例如，在多行上有对齐的尾部注释的情况下，格式化需要特殊处理：\n1 2 3 var Int: quality = 3; // The quality of the widget. It should always // be between 1 and 9. var Int: blueness = 72; // The blueness of the widget, as a percentage. 在这里，一个将blueness重命名为blue_percent的工具可能需要重新排列quality后面的注释以及blueness后面的注释。此外，如果最后一行变得太长，保持注释与变量在同一行可能变得不可行，需要更实质性的重写：\n1 2 // The blueness of the widget, as a percentage. var Int: blue_percent = Floor(ComputeBluenessRatio() * 100); 不支持尾随和行内注释的决定是试验性的，如果我们发现在完整的语言设计的背景下需要这样的注释，应该重新考虑。\n1.3.2 多行文本注释 不提供多行文本注释的支持。相反，这样的注释是通过在每行前加上相同的// 注释标记来表示的。\n要求每行重复注释标记将提高可读性，通过消除非本地状态的来源，并消除了不必要的和不有帮助的注释语法的变化。这种注释的风格在其他语言中很常见，并且得到了编辑器的很好支持。即使在使用/* ... */来注释掉人类可读的文本块的C和C++代码中，也通常在\n每行前加上*或其他标记，以使注释更容易阅读。\n1.3.3 块注释 我们考虑了各种不同的块注释选项。我们的主要目标是允许注释掉大量的Carbon代码，这些代码可能是或可能不是格式良好的（包括包含块注释的代码，这意味着这样的注释需要嵌套）。考虑的替代方案包括：\n完全基于行的块注释，它会删除行，而不考虑它们是否嵌套在字符串字面量中，具有新颖的特性，允许注释掉块字符串字面量的部分内容。这种替代方案的缺点是它会在包含Carbon代码的字符串字面量内部产生令人惊讶的行为。\n完全词法化的块注释，其中开头和结尾注释标记之间的令牌序列会被生成并丢弃，词法规则稍微放宽，以避免拒绝格式不良的代码。这将类似于C和C++的#if 0 \u0026hellip; #endif。这种替代方案的缺点是它无法处理不完整的代码片段，如未终止的块字符串字面量。与非词法化语法相比，处理起来也会有些低效，但考虑到块注释预期是短暂的，这可能在很大程度上是不相关的。\n一种混合方法，使用//\\{和//\\}作为定界符，这些定界符在非原始字符串字面量中是无效的，并且只对原始字符串字面量有缩进要求。这种替代方案的缺点是它在词法规则中引入了额外的复杂性，通过不同地对待不同种类的字符串字面量。\n使用/*和*/作为注释标记。这种替代方案的缺点是它使用与C和C++相似的语法，但语义有所不同，从而增加了混淆的风险。\n然而，考虑到这种注释的有限用例和我们希望最小化我们的创新性，我们在这个提议中没有追求这些选项。\n1.3.4 文档注释 我们可以为文档注释添加一个不同的注释语法，也许将文档注释视为产生真实令牌，而不是由词法分析器剥离。但是，在讨论中，有很大的支持使用不像注释的语法来表示文档。例如，我们可以引入一个属性语法，如使用@ \u0026lt;expression\u0026gt;作为声明的前缀来附加属性。然后，可以将字符串字面量属性视为文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @\u0026#34;Get the size of the thing.\u0026#34; fn GetThingSize() -\u0026gt; Int; @\u0026#34;\u0026#34;\u0026#34; Rate the quality of the widget. Returns a quality factor between 0.0 and 1.0. \u0026#34;\u0026#34;\u0026#34; fn RateQuality( @\u0026#34;The widget to rate.\u0026#34; Widget: w, @\u0026#34;A widget quality database.\u0026#34; QualityDB: db) -\u0026gt; Float; 这个用例将由未来的提议来探索。\n1.3.5 代码折叠注释 一些代码编辑器能够“折叠”源文件的区域，以便于导航。在某些情况下，这些折叠区域可以通过使用注释行来定制。例如，在VS Code中，这是通过包含#region和#endregion的注释来实现的：\n1 2 3 4 // #region 函数 F 和 G fn f() { ... } fn g() { ... } // #endregion 支持这样的标记作为行注释中的正常文本不需要额外的努力。然而，我们可以考虑引入一个特定的Carbon语法用于区域注释，以鼓励在代码编辑器之间使用通用的表示。这个提议没有涵盖这样的支持，但可以通过一种新形式的注释来处理。\n1.4 语言设计 carbon只提供一种注释，它以//开始并运行到行的末尾。在同一行上的注释之前不允许有代码，且引入注释的//后必须跟随空白。\n我们选择了这种注释语法，因为它简单、易于理解、易于实现、易于编辑、易于格式化，并且与其他语言的注释语法相似。\n","permalink":"https://canftin.github.io/posts/tech/p5_compiler_build_4_lang_design/","summary":"1. 注释 在现有的编程语言中，注释有多种用途。主要的用例包括： 文档：为API的用户和未来的维护者提供人类可读的注释，解释其功能以及如何使用它。这","title":"从零构造现代语言编译器(4): 语言设计"},{"content":"1. 什么是诊断 诊断信息（Diagnostics）在编程语言中，通常是编译器用来告诉程序员源代码中存在的问题的消息。这些问题可能包括语法错误、类型错误、未定义的符号、可能的运行时错误等。每种编译器都有自己的方式来显示这些信息。\nGCC（GNU Compiler Collection）：GCC是一个开源的编译器套件，支持C、C++、Java、Fortran等多种语言。当GCC遇到错误时，它会输出错误信息，包含了错误的类型、发生错误的源文件和行号，以及可能的原因。例如：\n1 2 3 4 test.c: In function \u0026#39;main\u0026#39;: test.c:2:5: error: \u0026#39;printf\u0026#39; undeclared (first use in this function) printf(\u0026#34;Hello, World!\\n\u0026#34;); ^~~~~~ 这个错误信息告诉我们在test.c文件的main函数中，第2行第5个字符处使用了未声明的printf（应该是printf）。\nClang：Clang是一个编译器前端，支持C语言、C++、Objective-C和Objective-C++编程语言。Clang的诊断信息相比GCC更为友好和详细，它会以易于理解的方式提供错误的上下文和修复建议。例如：\n1 2 3 4 test.cpp:1:1: error: C++ requires a type specifier for all declarations \u0026#34;Test\u0026#34; ^~~~ int 这个错误信息告诉我们在test.cpp文件的第1行第1个字符处缺少类型说明符，并建议添加int。\nRust：Rust是一种系统编程语言，注重安全、并发和内存效率。Rust编译器的诊断信息非常友好，包含了错误类型、发生错误的源文件和行号、错误的代码片段以及可能的解决方法。例如：\n1 2 3 4 5 error[E0425]: cannot find value `foo` in this scope --\u0026gt; main.rs:2:5 | 2 | foo; | ^^^ not found in this scope 这个错误信息告诉我们在main.rs文件的第2行第5个字符处找不到foo这个值。\n以上都是简单的例子，实际的诊断信息可能会更复杂，包含更多的上下文和建议。\n2. 诊断信息有哪些 Carbon定义了一系列诊断信息，用于在编译或运行时报告错误、警告或其他信息。这些诊断信息通常用于编译器、解释器或其他代码分析工具。诊断信息被分为几个不同的类别：\n1. SourceBuffer diagnostics（源缓冲区诊断） ErrorOpeningFile: 打开文件时出错。 ErrorStattingFile: 获取文件状态时出错。 FileTooLarge: 文件太大。 ErrorReadingFile: 读取文件时出错。 2. Lexer diagnostics（词法分析器诊断） 这部分包含了与词法分析有关的诊断信息，例如无效的数字、字符串未终止等。\nBinaryRealLiteral: 二进制实数字面量有问题，可能是格式错误。 ContentBeforeStringTerminator: 在字符串终结符之前有额外的内容。 DecimalEscapeSequence: 十进制转义序列有问题，可能是格式或值错误。 EmptyDigitSequence: 数字序列为空，例如在一个预期应有数字的地方什么都没有。 HexadecimalEscapeMissingDigits: 十六进制转义序列缺少必需的数字。 InvalidDigit: 无效的数字字符，例如在十进制数中出现了非0-9的字符。 InvalidDigitSeparator: 无效的数字分隔符，例如在数字中使用了不允许的字符作为分隔符。 InvalidHorizontalWhitespaceInString: 在字符串中有无效的水平空白字符。 IrregularDigitSeparators: 数字分隔符使用不规范，例如两个分隔符连续出现。 MismatchedClosing: 不匹配的关闭符号，例如一个括号或引号没有与之匹配的开始符号。 MismatchedIndentInString: 在多行字符串中，缩进不匹配。 MultiLineStringWithDoubleQuotes: 使用双引号在多行字符串中可能是不允许的。 NoWhitespaceAfterCommentIntroducer: 注释引导符（如//或/*）后面没有空白。 TooManyDigits: 数字含有太多的位数，超出了处理能力。 TrailingComment: 有尾随的注释，可能是在不应该出现注释的地方出现了注释。 UnicodeEscapeMissingBracedDigits: Unicode转义序列缺少必需的括在大括号里的数字。 UnicodeEscapeSurrogate: Unicode转义序列是一个代理项，这可能是不允许的。 UnicodeEscapeTooLarge: Unicode转义序列中的值太大。 UnknownBaseSpecifier: 未知的基数说明符，例如在数字前面有一个未知的前缀。 UnknownEscapeSequence: 未知的转义序列，例如\\z。 UnmatchedClosing: 有一个不匹配的关闭符号，没有与之匹配的开始符号。 UnrecognizedCharacters: 有无法识别的字符。 UnterminatedString: 字符串没有正确终止，缺少结束引号。 WrongRealLiteralExponent: 实数字面量的指数部分有误。 3. Parser diagnostics（语法分析器诊断） BinaryOperatorRequiresWhitespace: 二元运算符两侧需要空白字符。 ExpectedArraySemi: 期望在数组定义或初始化中看到一个分号。 ExpectedCloseSymbol: 期望一个关闭符号，如闭括号或闭花括号。 ExpectedCodeBlock: 期望一个代码块，通常由花括号包围。 ExpectedExpression: 期望一个表达式。 ExpectedIdentifierAfterDotOrArrow: 在.或-\u0026gt;后期望一个标识符。 ExpectedParameterName: 期望一个参数名。 ExpectedParenAfter: 在某个元素后期望一个括号。 ExpectedExpressionSemi: 在表达式后期望一个分号。 ExpectedStatementSemi: 在语句后期望一个分号。 ExpectedStructLiteralField: 期望一个结构体字面量字段。 ExpectedVariableDeclaration: 期望一个变量声明。 ExpectedVariableName: 期望一个变量名。 OperatorRequiresParentheses: 运算符需要括号。 StatementOperatorAsSubexpression: 语句运算符用作子表达式。 UnaryOperatorRequiresParentheses: 一元运算符需要括号。 UnaryOperatorHasWhitespace: 一元运算符后有空白。 UnaryOperatorRequiresWhitespace: 一元运算符需要空白。 UnexpectedTokenAfterListElement: 列表元素后出现意外的令牌。 UnrecognizedDeclaration: 无法识别的声明。 包相关诊断（Package-related diagnostics）\nExpectedIdentifierAfterPackage: 在package关键字后期望一个标识符。 ExpectedLibraryName: 期望一个库名。 MissingLibraryKeyword: 缺少library关键字。 ExpectedApiOrImpl: 期望api或impl。 For循环特定诊断（For-specific diagnostics）\nExpectedIn: 在for循环中期望in关键字。 ExpectedInNotColon: 期望in而不是冒号。 If条件特定诊断（If-specific diagnostics）\nExpectedThenAfterIf: 在if后期望then。 ExpectedElseAfterIf: 在if后期望else。 声明诊断（Declaration diagnostics）\nExpectedDeclarationName: 期望一个声明名。 ExpectedDeclarationSemi: 在声明后期望一个分号。 ExpectedDeclarationSemiOrDefinition: 在声明后期望一个分号或定义。 MethodImplNotAllowed: 方法实现不允许。 ParametersRequiredByIntroducer: 引入者需要参数。 ParametersRequiredByDeduced: 由推导出的类型需要参数。 4. Semantics diagnostics（语义诊断） 这部分包含了与代码语义有关的诊断信息，例如类型不匹配、数组越界等。\n这些都是用于在语义分析阶段报告各种类型的错误或警告的诊断标识符。语义分析通常涉及类型检查、作用域解析等。下面是对每个标识符可能代表的含义的解释：\nSemanticsTodo: 一个占位符，用于标记尚未实现的语义检查。 AddressOfEphemeralReference: 尝试获取短暂引用（例如，函数返回值）的地址。 AddressOfNonReference: 尝试获取非引用类型的地址。 ArrayInitFromLiteralArgCountMismatch: 数组从字面量初始化时，参数数量不匹配。 ArrayInitFromExpressionArgCountMismatch: 数组从表达式初始化时，参数数量不匹配。 AssignmentToNonAssignable: 尝试给不可赋值的对象（例如，常量或表达式）赋值。 DereferenceOfNonPointer: 尝试解引用非指针类型。 DereferenceOfType: 尝试解引用一个类型（而不是变量或表达式）。 NameNotFound: 找不到指定的名称（变量、函数等）。 NameDeclarationDuplicate: 名称声明重复。 NameDeclarationPrevious: 名称在之前已经被声明。 CallArgCountMismatch: 函数调用的参数数量不匹配。 InCallToFunction: 在对函数的调用中有问题。 InCallToFunctionParam: 在对函数参数的处理中有问题。 MissingReturnStatement: 缺少返回语句。 RepeatedConst: const关键字被重复使用。 InvalidArrayExpression: 无效的数组表达式。 TypeNotIndexable: 尝试索引一个不可索引的类型。 IndexOutOfBounds: 数组或其他可索引对象的索引越界。 TupleIndexIntegerLiteral: 元组索引必须是整数字面量。 ReturnStatementDisallowExpression: 返回语句中不允许有表达式。 ReturnStatementImplicitNote: 返回语句有隐式的注意事项（可能是类型推断或其他）。 ReturnStatementMissingExpression: 返回语句缺少表达式。 ImplicitAsConversionFailure: 隐式转换失败。 QualifiedDeclarationInNonScope: 在非作用域内有限定声明。 QualifiedDeclarationNonScopeEntity: 限定声明不是作用域实体。 QualifiedExpressionUnsupported: 不支持限定表达式。 QualifiedExpressionNameNotFound: 限定表达式中找不到名称。 UseOfNonExpressionAsValue: 尝试将非表达式用作值。 5. Other diagnostics（其他诊断） COCKTAIL_DIAGNOSTIC_KIND(TestDiagnostic): 仅用于单元测试的诊断。 COCKTAIL_DIAGNOSTIC_KIND(TestDiagnosticNote): 仅用于单元测试的诊断注释。 3. 诊断信息模块构建 责任链模式\n","permalink":"https://canftin.github.io/posts/tech/p4_compiler_build_3_diagnostics/","summary":"1. 什么是诊断 诊断信息（Diagnostics）在编程语言中，通常是编译器用来告诉程序员源代码中存在的问题的消息。这些问题可能包括语法错误、类","title":"从零构造现代语言编译器(3): 诊断信息"},{"content":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做对比分析。\n1. 流 引入工具基类Printable如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /// CRTP基类，用于打印类型，子类必须实现Print接口： /// - auto Print(llvm::raw_ostream\u0026amp; out) -\u0026gt; void; template \u0026lt;typename DerivedT\u0026gt; class Printable { /// 提供给debugger的简单接口， /// `LLVM_DUMP_METHOD` 宏确保只有在调试构建中才会包含这个方法。 LLVM_DUMP_METHOD void Dump() const { static_cast\u0026lt;const DerivedT*\u0026gt;(this)-\u0026gt;Print(llvm::errs()); } /// llvm::raw_ostream输出。 friend auto operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; llvm::raw_ostream\u0026amp; { obj.Print(out); return out; } /// std::ostream输出。 friend auto operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const DerivedT\u0026amp; obj) -\u0026gt; std::ostream\u0026amp; { llvm::raw_os_ostream raw_os(out); obj.Print(raw_os); return out; } friend auto PrintTo(DerivedT* p, std::ostream* out) -\u0026gt; void { *out \u0026lt;\u0026lt; static_cast\u0026lt;const void*\u0026gt;(p); if (p) { *out \u0026lt;\u0026lt; \u0026#34; pointing to \u0026#34; \u0026lt;\u0026lt; *p; } } }; 这里的Printable类被设计为一个基类，用于实现可打印的对象，它期望子类实现一个Print接口。\n1.1 Printable类的用途和功能 类型打印: 通过Print接口，子类可以自定义如何将其内容打印到输出流。 多种输出流支持: 支持llvm::raw_ostream和std::ostream两种输出流。 调试支持: 提供了一个Dump方法，用于在调试时快速查看对象的状态。 假设有一个Person类，我们希望能够打印其信息：\n1 2 3 4 5 6 7 8 9 10 class Person : public Printable\u0026lt;Person\u0026gt; { public: Person(std::string name, int age) : name(name), age(age) {} void Print(llvm::raw_ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;Person { name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; }\u0026#34;; } private: std::string name; int age; } 现在，Person类就可以使用Printable提供的所有功能。\n1 2 3 Person p(\u0026#34;Alice\u0026#34;, 30); llvm::raw_ostream\u0026amp; os = llvm::outs(); os \u0026lt;\u0026lt; p; // 输出：Person { name: Alice, age: 30 } 1.2 介绍CRTP和Mixin CRTP是C++中一种常用的编程模式，全名为“Curiously Recurring Template Pattern”，中文可以翻译为“奇异递归模板模式”。这个模式主要用于实现编译时多态性，也就是在编译时解析多态行为，而不是运行时。\n编译时多态: 由于多态行为在编译时就被解析，因此运行时性能开销小。 代码复用: 可以在基类中实现通用逻辑，减少代码重复。 类型安全: 使用static_cast进行类型转换是安全的，因为基类知道派生类的确切类型。 不适用于运行时多态: CRTP无法实现运行时多态，因为它依赖于编译时类型信息。 代码可读性: 对于不熟悉CRTP的开发者来说，代码可能会显得有些复杂。 在CRTP中，一个模板基类会以其派生类作为模板参数。这样，基类就可以在编译时知道其派生类的类型，基类就可以调用派生类的方法或访问其成员，即使这些方法或成员在基类中并没有被声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实际的实现 } }; 在这个例子中，Base类有一个interface方法，它内部调用了implementation方法。这个implementation方法是在Derived类中定义的，但Base类可以通过static_cast安全地调用它。\nCRTP常用于以下几种场景：\n静态多态: 如上面的例子所示，可以用于实现编译时多态。 Mixin 类: 可以用CRTP实现mixin（混入）功能，即在一个类中混入另一个类的功能。 工具类: 如在问题中的Printable类，用于提供一组通用的接口或实现。 总体来说，CRTP是一种非常强大而灵活的编程模式，尤其适用于需要高性能和代码复用的场景。\nMixin 功能 在 C++ 中，Mixin 是一种编程模式，用于通过组合而非继承来向一个类添加额外的功能或行为。Mixin 类通常是一些小型、可复用的组件，它们定义了特定的行为或功能，但不应该单独使用。通过将多个 Mixin 类组合在一起，你可以创建出具有多种功能的复杂对象。\nMixin 通常与模板编程和多重继承一起使用，以实现更高的灵活性和代码复用。\n假设你有一个 LoggerMixin 类，它提供了日志功能。\n1 2 3 4 5 6 class LoggerMixin { public: void log(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; \u0026#34;[LOG]: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; 再假设你有一个 TimerMixin 类，用于计算代码执行时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;chrono\u0026gt; class TimerMixin { public: void startTimer() { start = std::chrono::high_resolution_clock::now(); } void stopTimer() { auto stop = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(stop - start); std::cout \u0026lt;\u0026lt; \u0026#34;Time taken: \u0026#34; \u0026lt;\u0026lt; duration.count() \u0026lt;\u0026lt; \u0026#34; microseconds\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; }; 现在，你可以创建一个新类，通过多重继承来组合这两个 Mixin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass : public LoggerMixin, public TimerMixin { public: void doSomething() { log(\u0026#34;Starting operation...\u0026#34;); startTimer(); // 执行一些操作 // ... stopTimer(); log(\u0026#34;Operation completed.\u0026#34;); } }; 使用：\n1 2 3 4 5 int main() { MyClass obj; obj.doSomething(); return 0; } 这样，MyClass 就继承了 LoggerMixin 和 TimerMixin 的所有功能，而你不需要在 MyClass 中重新实现这些功能。\n代码复用: 你可以在多个类中重用同一个 Mixin。 解耦: Mixin 使得功能模块与业务逻辑解耦，更易于维护和扩展。 灵活性: 你可以灵活地组合多个 Mixin，以创建具有所需功能的新类。 复杂性: 使用多重继承和模板可能会增加代码复杂性。 名称冲突: 如果两个 Mixin 有相同的成员，可能会导致名称冲突。 1.3 LLVM输出流重载 LLVM是一个编译器基础设施项目，提供了一系列模块化的编译器组件和工具链。它用于开发编译器前端和后端，以及其他代码转换和代码生成工具。其中llvm::raw_ostream是llvm上的原始输出流。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace llvm { /// 注入一个 `operator\u0026lt;\u0026lt;` 重载到 llvm 命名空间， /// 将 LLVM 类型的 `raw_ostream` 重载映射到 `std::ostream` 重载。 template \u0026lt;typename StreamT, typename ClassT, typename = std::enable_if_t\u0026lt; std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;, typename = std::enable_if_t\u0026lt; !std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt;\u0026gt; auto operator\u0026lt;\u0026lt;(StreamT\u0026amp; standard_out, const ClassT\u0026amp; value) -\u0026gt; StreamT\u0026amp; { raw_os_ostream(standard_out) \u0026lt;\u0026lt; value; return standard_out; } } // namespace llvm 这段代码定义了一个模板函数 operator\u0026lt;\u0026lt;，该函数重载了流插入运算符 \u0026lt;\u0026lt;。这个重载函数位于 llvm 命名空间中，并且是为了将 LLVM 的 raw_ostream 类型的重载映射到 C++ 标准库的 std::ostream 类型。其中 StreamT 代表流类型，通常是 std::ostream 或其派生类，ClassT 代表要输出的类的类型。\nstd::enable_if_t\u0026lt;std::is_base_of_v\u0026lt;std::ostream, std::decay_t\u0026lt;StreamT\u0026gt;\u0026gt;\u0026gt;: 这个条件使用SFINAE（替换失败不是错误）确保 StreamT 是 std::ostream 的基类或者就是 std::ostream 本身。\nstd::enable_if_t\u0026lt;!std::is_same_v\u0026lt;std::decay_t\u0026lt;ClassT\u0026gt;, raw_ostream\u0026gt;\u0026gt; 这个条件确保 ClassT 不是 raw_ostream 类型。\nraw_os_ostream(standard_out) \u0026lt;\u0026lt; value; 这里创建了一个 raw_os_ostream 对象，该对象是 LLVM 提供的一个流类，用于将 std::ostream 包装成 raw_ostream。然后，使用 raw_ostream 的 \u0026lt;\u0026lt; 运算符将 value 输出到这个流中。\n这样做的目的是利用 LLVM 已经为 raw_ostream 定义的 \u0026lt;\u0026lt; 运算符重载。这样，任何能够通过 raw_ostream 输出的 ClassT 类型都可以通过这个新的 \u0026lt;\u0026lt; 运算符重载输出到 std::ostream。\nreturn standard_out; 最后，函数返回传入的 std::ostream 引用，以支持链式调用。\n假设 LLVM 已经为一个名为 MyLLVMClass 的类定义了如下的 \u0026lt;\u0026lt; 运算符重载：\n1 2 3 4 llvm::raw_ostream\u0026amp; operator\u0026lt;\u0026lt;(llvm::raw_ostream\u0026amp; out, const MyLLVMClass\u0026amp; obj) { // ... 输出逻辑 return out; } 现在，你可以这样使用新的 \u0026lt;\u0026lt; 运算符重载：\n1 std::cout \u0026lt;\u0026lt; MyLLVMClassInstance; // 这里会调用上面定义的 operator\u0026lt;\u0026lt; 这样，MyLLVMClassInstance 就会被正确地输出到 std::cout，而这一切都是通过 LLVM 的 raw_ostream 完成的。\n总结一下，这段代码的主要目的是为了提供一种机制，使得任何可以通过 LLVM 的 raw_ostream 输出的对象都可以直接通过 C++ 的 std::ostream 输出，从而实现两者之间的重载映射。这样做提高了代码的可复用性和一致性。\n2. EnumBase枚举模版类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// 用CRTP以及X-Macro来生成枚举类的模板类。 template \u0026lt;typename DerivedT, typename EnumT, const llvm::StringLiteral Names[]\u0026gt; class EnumBase : public Printable\u0026lt;DerivedT\u0026gt; { public: using RawEnumType = EnumT; // 用于定义原始的模版类型。 using EnumType = DerivedT; // 派生的枚举类型。 using UnderlyingType = std::underlying_type_t\u0026lt;RawEnumType\u0026gt;; // 原始枚举类型的底层类型。 /// 允许将枚举类转换为原始的枚举类型， constexpr operator RawEnumType() const { return value_; } explicit operator bool() const = delete; /// 返回枚举的名称。 [[nodiscard]] auto name() const -\u0026gt; llvm::StringRef { return Names[AsInt()]; } /// 打印名称，使用于Printable，必须实现。 auto Print(llvm::raw_ostream\u0026amp; out) const -\u0026gt; void { out \u0026lt;\u0026lt; name(); } protected: constexpr EnumBase() = default; /// 从原始枚举器创建类型。 static constexpr auto Create(RawEnumType value) -\u0026gt; EnumType { EnumType result; result.value_ = value; return result; } /// 转换为整数类型。 constexpr auto AsInt() const -\u0026gt; UnderlyingType { return static_cast\u0026lt;UnderlyingType\u0026gt;(value_); } /// 从底层整数类型转换为枚举类型。 static constexpr auto FromInt(UnderlyingType value) -\u0026gt; EnumType { return Create(static_cast\u0026lt;RawEnumType\u0026gt;(value)); } private: RawEnumType value_; }; 这段代码定义了一个用于生成枚举类的模板类 EnumBase，以及一系列用于辅助生成枚举类的宏。这个模板类和宏的组合提供了一种灵活、可复用的方式来创建和操作枚举类。它的设计目的：\n类型安全: 通过使用强类型的枚举（enum class），提供更好的类型安全。 可打印: 通过继承以上的 Printable，使得枚举值可以被打印。 名称获取: 提供了一个 name() 方法，用于获取枚举值的名称。 2.1 主要宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 创造原始枚举类（不涉及名称）。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) \\ namespace Internal { \\ enum class EnumClassName##RawEnum : UnderlyingType; \\ } \\ enum class Internal::EnumClassName##RawEnum : UnderlyingType // 创造原始枚举类。 #define COCKTAIL_DEFINE_RAW_ENUM_CLASS(EnumClassName, UnderlyingType) \\ namespace Internal { \\ extern const llvm::StringLiteral EnumClassName##Names[]; \\ } \\ COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) // 在原始枚举类的定义中生成每个枚举值。 #define COCKTAIL_RAW_ENUM_ENUMERATOR(Name) Name, #define COCKTAIL_ENUM_BASE(EnumClassName) \\ COCKTAIL_ENUM_BASE_CRTP(EnumClassName, EnumClassName, EnumClassName) #define COCKTAIL_ENUM_BASE_CRTP(EnumClassName, LocalTypeNameForEnumClass, \\ EnumClassNameForNames) \\ ::Cocktail::Internal::EnumBase\u0026lt;LocalTypeNameForEnumClass, \\ Internal::EnumClassName##RawEnum, \\ Internal::EnumClassNameForNames##Names\u0026gt; // 枚举类体内生成每个值的命名常量声明。 #define COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) static const EnumType Name; // 枚举类体外定义每个命名常量。 #define COCKTAIL_ENUM_CONSTANT_DEFINITION(EnumClassName, Name) \\ constexpr EnumClassName EnumClassName::Name = \\ EnumClassName::Create(RawEnumType::Name); #define COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION(Name) \\ static constexpr const typename Base::EnumType\u0026amp; Name = \\ Base::Create(Base::RawEnumType::Name); // 在 `.cc` 文件中为枚举类开始定义每个枚举器的常量名数组。 #define COCKTAIL_DEFINE_ENUM_CLASS_NAMES(EnumClassName) \\ constexpr llvm::StringLiteral Internal::EnumClassName##Names[] #define COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #Name, COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES: 定义一个没有名称数组的原始枚举类。 COCKTAIL_DEFINE_RAW_ENUM_CLASS: 定义一个有名称数组的原始枚举类。 COCKTAIL_RAW_ENUM_ENUMERATOR: 在原始枚举类定义中生成每个枚举值。 COCKTAIL_ENUM_BASE: 生成用于派生的 EnumBase 类型。 COCKTAIL_ENUM_CONSTANT_DECLARATION: 在枚举类体内生成每个值的命名常量声明。 COCKTAIL_ENUM_CONSTANT_DEFINITION: 在枚举类体外定义每个命名常量。 COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION: 用于内联定义每个命名常量。 COCKTAIL_DEFINE_ENUM_CLASS_NAMES: 在 .cc 文件中为枚举类开始定义每个枚举器的常量名数组。 COCKTAIL_ENUM_CLASS_NAME_STRING: 用于生成枚举值名称的字符串。 这个 EnumBase 类和相关的宏提供了一种高度可定制和可复用的方式来创建和操作枚举类。它们解决了类型安全、可打印性和名称获取等常见问题，同时也提供了一种简洁、一致的方式来定义和使用枚举类。这样的设计非常适用于大型项目中，特别是那些需要多次定义和使用不同枚举类的项目。\n2.2 什么是X-Macro X-Macro 是一种 C 和 C++ 预处理器技术，用于生成重复或模式化的代码。这种技术通过定义宏来实现，这些宏在不同的上下文中被多次展开，以生成不同的代码片段。X-Macro 主要用于减少代码重复，提高代码的可维护性。\n一个典型的 X-Macro 的使用方式是定义一个宏，该宏接受一个或多个参数，并在不同的上下文中多次展开。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define COLOR_XMACRO \\ X(Red) \\ X(Green) \\ X(Blue) // 定义枚举 enum Color { #define X(name) name, COLOR_XMACRO #undef X }; // 定义字符串数组 const char* ColorNames[] = { #define X(name) #name, COLOR_XMACRO #undef X }; 在这个例子中，COLOR_XMACRO 宏定义了一个颜色列表。然后，通过在不同的上下文中展开 X 宏，我们生成了一个 Color 枚举和一个 ColorNames 字符串数组。\nX-Macro 也可以用于更复杂的代码生成任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define PERSON_XMACRO \\ X(std::string, Name) \\ X(int, Age) \\ X(double, Height) // 定义结构体 struct Person { #define X(type, name) type name; PERSON_XMACRO #undef X }; // 序列化函数 std::string Serialize(const Person\u0026amp; p) { std::string result; #define X(type, name) result += std::to_string(p.name) + \u0026#34; \u0026#34;; PERSON_XMACRO #undef X return result; } // 反序列化函数（简化版） void Deserialize(Person\u0026amp; p, const std::string\u0026amp; s) { std::istringstream iss(s); #define X(type, name) iss \u0026gt;\u0026gt; p.name; PERSON_XMACRO #undef X } 在这个例子中，PERSON_XMACRO 定义了一个 Person 结构体的字段。然后，我们生成了该结构体的定义以及其序列化和反序列化函数。\n减少代码重复: 通过在多个地方展开相同的宏，减少了代码重复。 提高可维护性: 如果需要添加、删除或修改某个元素，只需在一个地方进行更改。 灵活性: 可以在不同的上下文中以不同的方式展开相同的宏。 可读性: 对于不熟悉 X-Macro 的人来说，代码可能难以理解。 调试困难: 预处理器生成的代码可能难以调试。 总体来说，X-Macro 是一种非常强大的代码生成技术，尤其适用于需要生成重复或模式化代码的场景。然而，它也有一些缺点，如可能降低代码的可读性和可调试性。因此，在使用 X-Macro 时，应权衡其优缺点。\n2.3 TokenKind实际使用 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #ifndef COCKTAIL_ENUM_BASE_TEST_KIND #error \u0026#34;Must define the x-macro to use this file.\u0026#34; #endif COCKTAIL_ENUM_BASE_TEST_KIND(Beep) COCKTAIL_ENUM_BASE_TEST_KIND(Boop) COCKTAIL_ENUM_BASE_TEST_KIND(Burr) #undef COCKTAIL_ENUM_BASE_TEST_KIND COCKTAIL_DEFINE_RAW_ENUM_CLASS(TestKind, uint8_t) { #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) COCKTAIL_RAW_ENUM_ENUMERATOR(Name) #include \u0026#34;EnumBase.t.def\u0026#34; }; class TestKind : public COCKTAIL_ENUM_BASE(TestKind) { public: #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) \\ COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) #include \u0026#34;EnumBase.t.def\u0026#34; using EnumBase::AsInt; using EnumBase::FromInt; }; #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) \\ COCKTAIL_ENUM_CONSTANT_DEFINITION(TestKind, Name) #include \u0026#34;EnumBase.t.def\u0026#34; COCKTAIL_DEFINE_ENUM_CLASS_NAMES(TestKind) = { #define COCKTAIL_ENUM_BASE_TEST_KIND(Name) COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #include \u0026#34;EnumBase.t.def\u0026#34; }; 这段代码使用了 X-Macro 和其他预处理器宏来定义一个名为 TestKind 的枚举类，以及与之相关的一些功能。这里的 X-Macro 是 COCKTAIL_ENUM_BASE_TEST_KIND，它被用于定义枚举值（Beep、Boop、Burr）和其他相关的代码。\n宏展开之后的样子:\n定义原始枚举类 1 2 3 4 5 enum class TestKindRawEnum : uint8_t { Beep, Boop, Burr }; 定义派生的枚举类 1 2 3 4 5 6 7 8 9 class TestKind : public EnumBase\u0026lt;TestKind, TestKindRawEnum, TestKindNames\u0026gt; { public: static const TestKind Beep; static const TestKind Boop; static const TestKind Burr; using EnumBase::AsInt; using EnumBase::FromInt; }; 定义命名常量 1 2 3 constexpr TestKind TestKind::Beep = TestKind::Create(TestKindRawEnum::Beep); constexpr TestKind TestKind::Boop = TestKind::Create(TestKindRawEnum::Boop); constexpr TestKind TestKind::Burr = TestKind::Create(TestKindRawEnum::Burr); 定义枚举类名称数组 1 2 3 4 5 constexpr llvm::StringLiteral TestKindNames[] = { \u0026#34;Beep\u0026#34;, \u0026#34;Boop\u0026#34;, \u0026#34;Burr\u0026#34; }; 通过使用 X-Macro 和其他预处理器宏，这段代码成功地定义了一个名为 TestKind 的枚举类，该枚举类具有以下特性：\n它有三个枚举值：Beep、Boop 和 Burr。 它继承自一个模板基类 EnumBase，该基类提供了一些额外的功能，如 AsInt() 和 FromInt() 方法。 它有一个与枚举值对应的名称数组 TestKindNames。 这样的设计提供了一种灵活、可复用的方式来创建和操作枚举类，同时也减少了代码重复和提高了可维护性。\nEnumBase主要用于以复用宏的方式生成Token类型，在词法分析里，过去的TokenKind是这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class TokenKind { enum class KindEnum : uint8_t { #define COCKTAIL_TOKEN(TokenName) TokenName, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; public: #define COCKTAIL_TOKEN(TokenName) \\ static constexpr auto TokenName() -\u0026gt; TokenKind { \\ return TokenKind(KindEnum::TokenName); \\ } #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; TokenKind() = delete; friend auto operator==(const TokenKind\u0026amp; lhs, const TokenKind\u0026amp; rhs) -\u0026gt; bool { return lhs.kind_value_ == rhs.kind_value_; } friend auto operator!=(const TokenKind\u0026amp; lhs, const TokenKind\u0026amp; rhs) -\u0026gt; bool { return lhs.kind_value_ != rhs.kind_value_; } [[nodiscard]] auto Name() const -\u0026gt; llvm::StringRef; [[nodiscard]] auto IsKeyword() const -\u0026gt; bool; [[nodiscard]] auto IsSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsGroupingSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsOpeningSymbol() const -\u0026gt; bool; [[nodiscard]] auto IsClosingSymbol() const -\u0026gt; bool; [[nodiscard]] auto GetOpeningSymbol() const -\u0026gt; TokenKind; [[nodiscard]] auto GetClosingSymbol() const -\u0026gt; TokenKind; [[nodiscard]] auto GetFixedSpelling() const -\u0026gt; llvm::StringRef; [[nodiscard]] auto IsOneOf(std::initializer_list\u0026lt;TokenKind\u0026gt; kinds) const -\u0026gt; bool { for (TokenKind kind : kinds) { if (*this == kind) { return true; } } return false; } [[nodiscard]] auto IsSizedTypeLiteral() const -\u0026gt; bool; constexpr operator KindEnum() const { return kind_value_; } auto Print(llvm::raw_ostream\u0026amp; out) const -\u0026gt; void { out \u0026lt;\u0026lt; GetFixedSpelling(); } private: constexpr explicit TokenKind(KindEnum kind_value) : kind_value_(kind_value) {} KindEnum kind_value_; }; auto TokenKind::Name() const -\u0026gt; llvm::StringRef { static constexpr llvm::StringLiteral Names[] = { #define COCKTAIL_TOKEN(TokenName) #TokenName, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Names[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsKeyword() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_SYMBOL_TOKEN(TokenName, Spelling) true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsGroupingSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ true, #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsOpeningSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsClosingSymbol() const -\u0026gt; bool { static constexpr bool Table[] = { #define COCKTAIL_TOKEN(TokenName) false, #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ true, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } auto TokenKind::IsSizedTypeLiteral() const -\u0026gt; bool { return *this == TokenKind::IntegerTypeLiteral() || *this == TokenKind::UnsignedIntegerTypeLiteral() || *this == TokenKind::FloatingPointTypeLiteral(); } auto TokenKind::GetOpeningSymbol() const -\u0026gt; TokenKind { static constexpr TokenKind Table[] = { #define COCKTAIL_TOKEN(TokenName) Error(), #define COCKTAIL_CLOSING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, OpeningName) \\ OpeningName(), #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; auto result = Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; // COCKTAIL_CHECK(result != Error()) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } auto TokenKind::GetClosingSymbol() const -\u0026gt; TokenKind { static constexpr TokenKind Table[] = { #define COCKTAIL_TOKEN(TokenName) Error(), #define COCKTAIL_OPENING_GROUP_SYMBOL_TOKEN(TokenName, Spelling, ClosingName) \\ ClosingName(), #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; auto result = Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; // COCKTAIL_CHECK(result != Error()) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } auto TokenKind::GetFixedSpelling() const -\u0026gt; llvm::StringRef { static constexpr llvm::StringLiteral Table[] = { #define COCKTAIL_TOKEN(TokenName) \u0026#34;\u0026#34;, #define COCKTAIL_SYMBOL_TOKEN(TokenName, Spelling) Spelling, #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) Spelling, #include \u0026#34;Cocktail/Lexer/TokenRegistry.def\u0026#34; }; return Table[static_cast\u0026lt;int\u0026gt;(kind_value_)]; } 这里会更直观，类型变量存在类中，直接用于所有接口中的底层数据，但可复用性会降低。\n使用EnumBase更新后的TokenKind如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 COCKTAIL_DEFINE_RAW_ENUM_CLASS(TokenKind, uint8_t) { #define COCKTAIL_TOKEN(TokenName) COCKTAIL_RAW_ENUM_ENUMERATOR(TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; }; class TokenKind : public COCKTAIL_ENUM_BASE(TokenKind) { public: #define COCKTAIL_TOKEN(TokenName) COCKTAIL_ENUM_CONSTANT_DECLARATION(TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; /// 所有keyword token。 static const llvm::ArrayRef\u0026lt;TokenKind\u0026gt; KeywordTokens; /// 检查此标记是否为简单的符号序列（如标点符号）。 /// 这些符号可以直接出现在源代码中，并且可以使用starts_with进行词法分析。 [[nodiscard]] auto is_symbol() const -\u0026gt; bool { return IsSymbol[AsInt()]; } /// 检查此标记是否为分组符号（如括号、大括号等），这些符号在标记流中必须匹配。 [[nodiscard]] auto is_grouping_symbol() const -\u0026gt; bool { return IsGroupingSymbol[AsInt()]; } /// 对于结束符号，返回其对应的开头符号。 [[nodiscard]] auto opening_symbol() const -\u0026gt; TokenKind { auto result = OpeningSymbol[AsInt()]; COCKTAIL_CHECK(result != Error) \u0026lt;\u0026lt; \u0026#34;Only closing symbols are valid!\u0026#34;; return result; } /// 检查此标记是否为分组的开头符号。 [[nodiscard]] auto is_opening_symbol() const -\u0026gt; bool { return IsOpeningSymbol[AsInt()]; } /// 对于开头符号，返回其对应的结束符号。 [[nodiscard]] auto closing_symbol() const -\u0026gt; TokenKind { auto result = ClosingSymbol[AsInt()]; COCKTAIL_CHECK(result != Error) \u0026lt;\u0026lt; \u0026#34;Only opening symbol are valid!\u0026#34;; return result; } /// 检查此标记是否为分组的结束符号。 [[nodiscard]] auto is_closing_symbol() const -\u0026gt; bool { return IsClosingSymbol[AsInt()]; } /// 检查此标记是否为单字符符号，且此字符不是其他符号的一部分。 [[nodiscard]] auto is_one_char_symbol() const -\u0026gt; bool { return IsOneCharSymbol[AsInt()]; }; /// 检查此标记是否为关键字。 [[nodiscard]] auto is_keyword() const -\u0026gt; bool { return IsKeyword[AsInt()]; }; /// 检查此标记是否为带有大小的类型字面量（如整数、浮点数类型字面量）。 [[nodiscard]] auto is_sized_type_literal() const -\u0026gt; bool { return *this == TokenKind::IntegerTypeLiteral || *this == TokenKind::UnsignedIntegerTypeLiteral || *this == TokenKind::FloatingPointTypeLiteral; }; /// 如果此标记在源代码中有固定的拼写，则返回它。否则返回空字符串。 [[nodiscard]] auto fixed_spelling() const -\u0026gt; llvm::StringRef { return FixedSpelling[AsInt()]; }; /// 获取此标记所对应的解析树节点的预期数量。 [[nodiscard]] auto expected_parse_tree_size() const -\u0026gt; int { return ExpectedParseTreeSize[AsInt()]; } /// 检查此标记是否在提供的列表中。 [[nodiscard]] auto IsOneOf(std::initializer_list\u0026lt;TokenKind\u0026gt; kinds) const -\u0026gt; bool { for (TokenKind kind : kinds) { if (*this == kind) { return true; } } return false; } private: static const TokenKind KeywordTokensStorage[]; static const bool IsSymbol[]; static const bool IsGroupingSymbol[]; static const bool IsOpeningSymbol[]; static const TokenKind ClosingSymbol[]; static const bool IsClosingSymbol[]; static const TokenKind OpeningSymbol[]; static const bool IsOneCharSymbol[]; static const bool IsKeyword[]; static const llvm::StringLiteral FixedSpelling[]; static const int8_t ExpectedParseTreeSize[]; }; #define COCKTAIL_TOKEN(TokenName) \\ COCKTAIL_ENUM_CONSTANT_DEFINITION(TokenKind, TokenName) #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; constexpr TokenKind TokenKind::KeywordTokensStorage[] = { #define COCKTAIL_KEYWORD_TOKEN(TokenName, Spelling) TokenKind::TokenName, #include \u0026#34;Cocktail/Lex/TokenKind.def\u0026#34; }; constexpr llvm::ArrayRef\u0026lt;TokenKind\u0026gt; TokenKind::KeywordTokens = KeywordTokensStorage; 3. 错误状态 4. commandline // # 命令行参数解析库。 // // 这是一个用于描述简单和相对复杂命令行界面，并基于这些描述解析参数的工具集合。它针对每次执行只解析一次参数的命令行工具进行了优化，特别是那些大量使用子命令样式命令行界面的工具。 // // ## 本库使用的术语 // // 参数 或 arg：命令行的一个解析组件。 // // 选项：一个以 -- 开头的 命名 参数，用于配置工具的某些方面。它们通常有长形式以 -- 开头，还有短形式以 - 开头，可以与其他单字符选项一起捆绑使用。 // // 标志：布尔或二进制选项。它们只能启用或禁用。 // // 位置参数：根据在命令行中出现的顺序而不是名称来识别的参数，其中排除了选项。只有叶子命令可以包含位置参数。 // // 值：提供给参数的值参数。对于选项来说，这是在参数名称后面使用 = 提供的。对于位置参数来说，值就是唯一提供的内容。值的字符串根据参数的类型进行解析，遵循相对简单的规则。有关更多详细信息，请参阅参数构建器。 // // 命令：包含要解析的选项、子命令和位置参数以及成功时要执行的操作的容器。 // // 叶子命令：不包含子命令的命令。这是唯一可以包含位置参数的命令类型。 // // 子命令：嵌套在另一个命令中的命令，并由特定名称标识，该名称结束了基于父命令的参数解析，并切换到基于特定子命令的选项和位置参数解析。具有子命令的命令不能解析位置参数。 // // 操作：一个开放式回调，通常反映正在解析的特定子命令。可以直接执行操作，也可以仅标记所选操作。 // // 元操作：由参数解析完全处理的操作，例如显示帮助、版本信息或完成。 // // 以下是一个示例命令，用于说明不同的组件： // // git \u0026ndash;no-pager clone \u0026ndash;shared \u0026ndash;filter=blob:none my-repo my-directory // // 这个命令分解为： // - git：顶级命令。 // - --no-pager：在顶级命令 (git) 上的否定标志。 // - clone：一个子命令。 // - --shared：子命令 (clone) 的正标志。 // - --filter=blob:none：具有值 blob:none 的选项 filter。 // - my-repo：子命令的第一个位置参数。 // - my-directory：子命令的第二个位置参数。 // // **注意：**虽然示例使用了 git 命令以使其相对熟悉和有文档记录，但该库不支持与 git 相同的标志语法，也不使用与解析的语法重叠的任何内容。此示例仅用于帮助澄清使用的术语，并经过谨慎选择，仅使用与此库解析语法重叠的语法。 // // ## 选项和标志 // // 该库支持的选项语法和行为旨在严格且相对简单，同时仍支持各种预期的用例： // // - 所有选项必须具有唯一的长名称，使用 -- 前缀访问。名称必须由集合 [-a-zA-Z0-9] 中的字符组成，并且不能以 - 或 no- 开头。 // // - 值始终使用名称后面的 = 附加。仅支持少量简单的值格式： // - 任意字符串 // - 由 llvm::StringRef 解析的整数，其值适合于 int。 // - 固定一组字符串之一 // // - 选项可以多次解析，并且行为可以配置： // - 每次可以设置新值，覆盖任何先前的值。 // - 它们可以将值附加到容器。 // - TODO: 它们可以增加计数。 // // - 选项可以具有默认值，即使在解析的命令行中没有出现它们，也将合成该值。 // // - 标志（布尔选项）具有一些特殊规则。 // - 它们可以正常拼写，默认为将该标志设置为 true。 // - 它们还可以接受值，值必须完全是 true 或 false。 // - 它们可以带有 no- 前缀，例如 --no-verbose，这与 --verbose=false 完全等效。 // - 对于默认为 true 值的标志，在帮助中使用 no- 前缀呈现。 // // - 选项还可以具有单个字符的短名称 [a-zA-Z]。 // - 长名称和短名称之间的行为没有区别。 // - 短名称只能指定标志的正值或 true 值。没有短名称的负值形式。 // - 短名称在单个 - 之后解析，例如 -v。 // - 可以在 - 后捆绑任意数量的布尔标志或具有默认值的选项的短名称，例如 `-xyz\n","permalink":"https://canftin.github.io/posts/tech/p3_compiler_build_2_common_lib/","summary":"本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做","title":"从零构造现代语言编译器(2): 公共库"},{"content":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 123、3.14、0xFF、1.23e-4 都可以被视为数值字面量。\n字面量的类型通常根据其格式和位置决定。例如在大多数编程语言[1][2][3]中，带有小数点的数字将被视为浮点数（如 3.14 ），而没有小数点的数字将被视为整数（如 123 ）。\n更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。\n本章将从数值字面量的解析入手，开始进入编译器构造的世界。\nCarbon数值类型介绍 Carbon中数值类型[4][5]有如下几种：\n整数类型\n整数根据进制分为如下类型：十进制（例如 12345 ）、十六进制（例如 0x1FE ）、二进制（例如 0b1010 ）等\n实数类型\n实数类型总是包含 . 符号，实数类型例如基础类型 123.456 以及科学技术法表示 123.456e789、0x1.2p123 等，其中科学技术法表示中的字符 e 及 p 在Carbon中称为指数（对应代码中exponent 字符，实际在幂运算中应为底数），对于一个十进制值 N 来说，e 相当于10±N，而 p 相当于2±N。\n且实数类型字面量 exponent 字符后可跟随 + 或 - 字符，例如 12.34e+56 或 56.34e-12。\n数字分隔符[6]\n数字分隔符由下划线 _ 表示，例如十进制数: 1_23_456_7890、十六进制数: 0x7_F_FF_FFFF、实数: 2_147.48_3648e12_345 或 0x1_00CA.FE_F00Dp+2_4、二进制数: 0b1_000_101_11 等。\n数值字面量词法解析： 首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 _ 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 exponent 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供NumericLiteralToken类的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。\n以下代码参考numeric_literal section1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class NumericLiteralToken { public: auto Text() const -\u0026gt; llvm::StringRef { return text; } static auto Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt;; auto GetRadixPoint() -\u0026gt; int { return radix_point; } auto GetExponent() -\u0026gt; int { return exponent; } private: NumericLiteralToken() {} llvm::StringRef text; // \u0026#39;.\u0026#39;字符的偏移量 int radix_point; // \u0026#39;e\u0026#39;或\u0026#39;p\u0026#39;字符的偏移量 int exponent; }; 其中我们重点关注Lex接口的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 auto NumericLiteralToken::Lex(llvm::StringRef source_text) -\u0026gt; llvm::Optional\u0026lt;NumericLiteralToken\u0026gt; { NumericLiteralToken result; // 判断source_text是否为空以及第一个字符是否为数字 if (source_text.empty() || !IsDecimalDigit(source_text.front())) { return llvm::None; } bool seen_plus_minus = false; bool seen_radix_point = false; bool seen_potential_exponent = false; // 由于之前已经确认过首字符，这里索引从1开始 int i = 1; for (int n = source_text.size(); i != n; ++i) { char c = source_text[i]; if (IsAlnum(c) || c == \u0026#39;_\u0026#39;) { // 只支持小写的 \u0026#39;e\u0026#39;，如果存在该字符且发现点号以及未探索 // 到加减号则记录exponent索引位置，否则继续下一轮循环 if (IsLower(c) \u0026amp;\u0026amp; seen_radix_point \u0026amp;\u0026amp; !seen_plus_minus) { result.exponent = i; seen_potential_exponent = true; } continue; } // 当前字符为 \u0026#39;.\u0026#39; 时，记录radix_point if (c == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1]) \u0026amp;\u0026amp; !seen_radix_point) { result.radix_point = i; seen_radix_point = true; continue; } // 当前字符为 \u0026#39;+\u0026#39; 或 \u0026#39;-\u0026#39; 时，记录seen_plus_minus if ((c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; seen_potential_exponent \u0026amp;\u0026amp; result.exponent == i - 1 \u0026amp;\u0026amp; i + 1 != n \u0026amp;\u0026amp; IsAlnum(source_text[i + 1])) { assert(!seen_plus_minus \u0026amp;\u0026amp; \u0026#34;should only consume one + or -\u0026#34;); seen_plus_minus = true; continue; } break; } // 返回探索到的字符串，以当前i的值为索引切分子串 result.text = source_text.substr(0, i); // 记录 \u0026#39;.\u0026#39; 偏移 if (!seen_radix_point) { result.radix_point = i; } // 记录 \u0026#39;e\u0026#39; 或 \u0026#39;p\u0026#39; 偏移 if (!seen_potential_exponent) { result.exponent = i; } return result; } 以上代码中，source_text用于接受外部传入的数值字符串，该类型为llvm::StringRef类型（StringRef类型分析可参考chapter12_s1.2: LLVM ADT StringRef介绍及使用），首先判断source_text是否为空以及第一个字符是否为数字，如果不满足条件则返回llvm::None，llvm::None实际为一个枚举数值类型，返回值为llvm::Optional（Optional类型分析可参考chapter12_s1.3: LLVM ADT Optional介绍及使用）。\n接下来使用三个变量seen_plus_minus（是否探索到 + 或 - ）、seen_radix_point（是否探索到 . ）、seen_potential_exponent（是否探索到 e 或者 p ）用于后续词法解析的条件判断。\n在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。\n跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。\n数值字面量语法解析 在词法层面我们切分并完成了NumericLiteralToken对象的解析，接下来需要实现数值字面量的解析，实现这一步的目标是在语义上能对不同数值字面量提取更多的信息，其中包括数值字面量的合规性检查、提取数据等，将数值字面量解析拆分为了Tokenizer和Parser两部分，使得每部分过程更为明确和便于后期扩展。\n我们关注numeric_literal代码section2中的友元类Parser实现，将section1中NumericLiteralToken里两个函数GetRadixPoint和GetExponent的能力删除，将提取对应数据的能力移交至Parser，函数返回值改为llvm::APInt（参考阅读什么是APInt链接）。\n以下代码参考numeric_literal section2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class NumericLiteralToken::Parser { public: Parser(NumericLiteralToken literal); auto IsInteger() -\u0026gt; bool { return literal.radix_point == static_cast\u0026lt;int\u0026gt;(literal.Text().size()); } auto GetRadix() const -\u0026gt; int { return radix; } auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; private: NumericLiteralToken literal; // 存储对应字面量 // 基数默认为10，可以为 2 或 10 或 16 int radix = 10; // 词法结构：[radix] int_part [. fract_part [[ep] [+-] exponent_part]] llvm::StringRef int_part; // 整数部分 llvm::StringRef fract_part; // 小数部分 llvm::StringRef exponent_part; // 指数部分 // 对应数据是否需要清除`_`或`.`符号，默认为false bool mantissa_needs_cleaning = false; bool exponent_needs_cleaning = false; // 在`exponent`部分后面发现了`-`符号 bool exponent_is_negative = false; }; 具体看一下Parser的构造函数，构造时传入NumericLiteralToken对象，根据该对象里的radix_point数据进行int_part数据的切分，并对切分结果前两个字符做检查，根据0x或0b首字符判断进制，随即切分fract_part数据以及exponent_part数据，并判断是否在exponent部分后面发现了-符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 NumericLiteralToken::Parser::Parser(NumericLiteralToken literal) : literal(literal) { int_part = literal.text.substr(0, literal.radix_point); if (int_part.consume_front(\u0026#34;0x\u0026#34;)) { radix = 16; } else if (int_part.consume_front(\u0026#34;0b\u0026#34;)) { radix = 2; } fract_part = literal.text.substr(literal.radix_point + 1, literal.exponent - literal.radix_point - 1); exponent_part = literal.text.substr(literal.exponent + 1); if (!exponent_part.consume_front(\u0026#34;+\u0026#34;)) { exponent_is_negative = exponent_part.consume_front(\u0026#34;-\u0026#34;); } } Parser构造函数中构建好数据后，需要提供接口获取对应数据。\n其中包括四个函数接口：\n1 2 3 4 auto IsInteger() -\u0026gt; bool; auto GetRadix() const -\u0026gt; int; auto GetMantissa() -\u0026gt; llvm::APInt; auto GetExponent() -\u0026gt; llvm::APInt; IsInteger()用于判断是否为一个整数，判断方式为小数点位置是否在字符串末尾，字符串显示不存在小数点时，小数点默认在末尾。 GetRadix()用于获取进制。 GetMantissa()用于获取小数部分。 GetExponent()用于获取指数部分。 其中GetMantissa()和GetExponent()都调用了ParseInteger接口，ParseInteger完成获取具体数值的功能，以下为ParseInteger接口代码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static auto ParseInteger(llvm::StringRef digits, int radix, bool needs_cleaning) -\u0026gt; llvm::APInt { llvm::SmallString\u0026lt;32\u0026gt; cleaned; // 预分配32个字节的字符串 if (needs_cleaning) { cleaned.reserve(digits.size()); // 根据目标大小重建长度 std::remove_copy_if(digits.begin(), digits.end(), std::back_inserter(cleaned), [](char c) { return c == \u0026#39;_\u0026#39; || c == \u0026#39;.\u0026#39;; }); digits = cleaned; } llvm::APInt value; if (digits.getAsInteger(radix, value)) { llvm_unreachable(\u0026#34;should never fail\u0026#34;); } return value; } 当解析包含小数点和下划线的字面量时，将忽视这两种字符，例如在解析 123.456e7 字面量时，我们期望获取到小数部分mantissa即(123456)和指数部分exponent(7-3=4)，根据这两个数我们能计算出真实的数据为：1234560000，其中GetMantissa函数如下：\n1 2 3 4 5 6 auto NumericLiteralToken::Parser::GetMantissa() -\u0026gt; llvm::APInt { // 如果为整数从int_part为结尾，否则以fract_part为结尾 const char* end = IsInteger() ? int_part.end() : fract_part.end(); llvm::StringRef digits(int_part.begin(), end - int_part.begin()); return ParseInteger(digits, radix, mantissa_needs_cleaning); } 获取exponent的函数GetExponent如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 auto NumericLiteralToken::Parser::GetExponent() -\u0026gt; llvm::APInt { llvm::APInt exponent(64, 0); // 创建64位值为0的exponent对象。 // 如果存在指数部分，就进入这个分支。 if (!exponent_part.empty()) { // 解析指数部分。这个函数会将字符串形式的指数转换为整数。其中， // 第一个参数是指数部分，第二个参数10是代表十进制，第三个参数 // 表示解析过程中是否需要进行清理。 exponent = ParseInteger(exponent_part, 10, exponent_needs_cleaning); // 检查指数的符号位是否被设置，或者指数的位宽是否小于64。 // 如果满足这些条件之一，就需要扩展指数的位宽。 if (exponent.isSignBitSet() || exponent.getBitWidth() \u0026lt; 64) { // 扩展指数的位宽。新的位宽至少为64，如果原来的位宽+1大于64， // 那么就使用原来的位宽+1。扩展后，新增的位都被设置为0。 exponent = exponent.zext(std::max(64U, exponent.getBitWidth() + 1)); } // 如果指数是负数，就需要取反。 if (exponent_is_negative) { exponent.negate(); // 取反操作。 } } // 计算小数部分的字符数量，这个数量会影响实际的指数大小。 int excess_exponent = fract_part.size(); // 如果基数是16，即如果是十六进制的数，那么每一个小数部 // 分的字符都会减少4个指数（因为一个十六进制的字符等于4个二进制位）。 if (radix == 16) { excess_exponent *= 4; // 将小数部分的字符数量乘以4。 } exponent -= excess_exponent; // 从指数中减去小数部分的字符数量。 // 如果原来的指数是负数，但是计算后的指数变为非负，那么就进入这个分支。 if (exponent_is_negative \u0026amp;\u0026amp; !exponent.isNegative()) { // 扩展指数的位宽，新增的位被设置为0。 exponent = exponent.zext(exponent.getBitWidth() + 1); // 设置指数的符号位，使得指数变为负数。 exponent.setSignBit(); } return exponent; } 从上面我们可以看到mantissa_needs_cleaning和exponent_needs_cleaning永远为false，原因是因为这两个标志位需要在获取数据之前对字面量做检查后进行设置，对传入不满足要求的字面量做预处理检查后才允许提取。\n关于字面量检查部分在下一章Chapter2: 诊断信息中进行说明与分析。\n2. 字符串字面量 // TODO: 1. 讲解字符串字面量代码。 // TODO: 2. 讲解字符串字面量设计。\n// TODO: 3. utf-8讲解。\n// TODO: 4. 单元测试讲解\n// TODO: 4.1 c++中的R字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 auto StringLiteral::Lex(llvm::StringRef source_text) -\u0026gt; std::optional\u0026lt;StringLiteral\u0026gt; { int64_t cursor = 0; const int64_t source_text_size = source_text.size(); // 确定前缀中的#数量。 while (cursor \u0026lt; source_text_size \u0026amp;\u0026amp; source_text[cursor] == \u0026#39;#\u0026#39;) { ++cursor; } const int hash_level = cursor; const std::optional\u0026lt;Introducer\u0026gt; introducer = Introducer::Lex(source_text.substr(hash_level)); if (!introducer) { return std::nullopt; } cursor += introducer-\u0026gt;prefix_size; const int prefix_len = cursor; // 初始化终结符和转义序列标记。 llvm::SmallString\u0026lt;16\u0026gt; terminator(introducer-\u0026gt;terminator); llvm::SmallString\u0026lt;16\u0026gt; escape(\u0026#34;\\\\\u0026#34;); // 整终结符和转义序列的大小。 terminator.resize(terminator.size() + hash_level, \u0026#39;#\u0026#39;); escape.resize(escape.size() + hash_level, \u0026#39;#\u0026#39;); /// TODO: 在找到终结符之前检测多行字符串字面量的缩进/反缩进。 for (; cursor \u0026lt; source_text_size; ++cursor) { // 快速跳过不感兴趣的字符。 static constexpr CharSet InterestingChars = {\u0026#39;\\\\\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;}; if (!InterestingChars[source_text[cursor]]) { continue; } // 多字符的终结符和转义序列都以可预测的字符开始， // 并且不包含嵌入的、未转义的终结符或换行符。 switch (source_text[cursor]) { case \u0026#39;\\\\\u0026#39;: // 处理转义字符。 if (escape.size() == 1 || source_text.substr(cursor + 1).startwith(escape.substr(1))) { cursor += escape.size(); // 单行字符串且转义字符是换行符。 if (cursor \u0026gt;= source_text_size || (introducer-\u0026gt;kind == NotMultiLine \u0026amp;\u0026amp; source_text[cursor] == \u0026#39;\\n\u0026#39;)) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } } break; case \u0026#39;\\n\u0026#39;: // 单行字符串。 if (introducer-\u0026gt;kind == NotMultiLine) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } break; case \u0026#39;\u0026#34;\u0026#39;: case \u0026#39;\\\u0026#39;\u0026#39;: if (source_text.substr(cursor).startswith(terminator)) { llvm::StringRef text = source_text.substr(0, cursor + terminator.size()); llvm::StringRef content = source_text.substr(prefix_len, cursor - prefix_len); return StringLiteral(text, content, hash_level, introducer-\u0026gt;kind, /*is_terminated=*/true); } break; default: // 对于非终结符，不执行任何操作。 break; } } return StringLiteral(source_text, source_text.drop_front(prefix_len), hash_level, introducer-\u0026gt;kind, /*is_terminated=*/false); } 首先，我们需要理解代码的逻辑以构建自动机。这段代码的主要目的是解析字符串字面量，特别是处理多行字符串、转义序列和终结符。\n基于代码的逻辑，我们可以构建以下自动机，以下是自动机图示：\n首先，我们需要理解自动机的基本概念。在计算机科学中，一个自动机是一个抽象的机器，它可以处于有限数量的不同状态之一，且在任何给定时刻只能处于其中一个状态。自动机根据输入序列中的符号进行状态转换。\n现在，让我们详细分析上述自动机的每个部分：\n开始状态 (Start): 这是解析字符串时的初始状态。在这个状态下，我们首先检查字符串的前缀是否包含#字符。\nHashCount: 在这个状态下，我们计算#的数量。这是为了确定多行字符串的终结符需要与开始的#数量匹配。\n多行状态 (MultiLine): 如果字符串以'''或\u0026quot;\u0026quot;\u0026quot;开始，我们进入这个状态。在这个状态下，我们查找与开始匹配的终结符。终结符需要与开始的#数量匹配。\n常规状态 (Regular): 如果字符串以一个双引号\u0026quot;开始，我们进入这个状态。在这个状态下，我们查找另一个双引号或转义序列。\n转义状态 (Escape): 当我们在常规状态下遇到反斜杠\\时，我们进入这个状态。这是因为反斜杠通常用于表示转义序列，例如\\\u0026quot;表示一个双引号字符。在这个状态下，我们查找与转义序列匹配的字符。\n结束状态 (End): 当我们找到与开始匹配的终结符或达到字符串的末尾时，我们进入这个状态。这表示我们已经成功地解析了整个字符串。\n为什么这个自动机是这样设计的？\n这个自动机是基于Carbon语言中字符串字面量的词法规则设计的。这些规则定义了如何从源代码中解析字符串。特别是，这个自动机处理了以下几点：\n#字符的数量，这决定了多行字符串的终结符。 多行字符串和常规字符串的区别。 转义序列，这是在常规字符串中表示特殊字符的方法。 通过这个自动机，我们可以准确地解析Carbon语言中的字符串字面量，无论它们是多行的、常规的还是包含转义序列的。\n字符串解析例子：\n对于输入###'''hello world'''###：\n我们首先计算#的数量为3。 然后，我们确定这是一个多行字符串，并查找与'''###匹配的终结符。 我们成功地找到了终结符并结束了解析。 对于输入\u0026quot;hello \\\\\u0026quot; world\u0026quot;：\n我们确定这是一个常规字符串。 我们继续解析，直到遇到反斜杠\\，然后进入转义状态。 在转义状态下，我们找到另一个反斜杠，并返回常规状态。 我们继续解析，直到找到终结符\u0026quot;并结束解析。 这个自动机提供了一个高层次的视图，描述了如何解析字符串字面量。\nStringLiteral中静态函数的逐行分析 ComputeIndentOfFinalLine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。 static auto ComputeIndentOfFinalLine(llvm::StringRef text) -\u0026gt; llvm::StringRef { int indent_end = text.size(); // 从文本的末尾开始，逐字符向前检查。 for (int i = indent_end - 1; i \u0026gt;= 0; --i) { if (text[i] == \u0026#39;\\n\u0026#39;) { // 如果遇到换行符\\n，则该位置之后的所有字符都是最后一行的缩进。 int indent_start = i + 1; return text.substr(indent_start, indent_end - indent_start); } if (!IsSpace(text[i])) { // 如果遇到非空格字符，则更新缩进的结束位置。 indent_end = i; } } // 如果没有找到换行符，这意味着给定的文本不包含换行符，这是一个错误情况。 llvm_unreachable(\u0026#34;Given text is required to contain a newline.\u0026#34;); } 这段代码定义了一个函数 ComputeIndentOfFinalLine，它的目的是计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。\n让我们逐步分析这段代码：\n函数签名:\n1 static auto ComputeIndentOfFinalLine(llvm::StringRef text) -\u0026gt; llvm::StringRef 这个函数接受一个 llvm::StringRef 类型的参数 text，并返回一个 llvm::StringRef 类型的结果。llvm::StringRef 是一个轻量级的字符串引用，它不拥有其引用的字符串的内存，但提供了对该字符串的高效访问。\n初始化:\n1 int indent_end = text.size(); 初始化 indent_end 为文本的长度。这是因为我们将从文本的末尾开始向前搜索，以找到最后一个换行符。\n查找最后一个换行符:\n1 2 3 4 5 6 7 8 9 for (int i = indent_end - 1; i \u0026gt;= 0; --i) { if (text[i] == \u0026#39;\\n\u0026#39;) { int indent_start = i + 1; return text.substr(indent_start, indent_end - indent_start); } if (!IsSpace(text[i])) { indent_end = i; } } 这个循环从文本的末尾开始，向前搜索直到找到最后一个换行符或到达文本的开始。如果找到一个非空白字符，它会更新 indent_end 的值。当找到换行符时，函数会返回从该换行符之后到 indent_end 之间的子字符串，这就是最后一行的缩进。\n异常情况:\n1 llvm_unreachable(\u0026#34;Given text is required to contain a newline.\u0026#34;); 如果函数没有在文本中找到换行符，它会触发一个不可达的断言，表示这是一个异常情况。这意味着调用此函数的代码应确保提供的文本至少包含一个换行符。\n测试用例:\n基本用例:\n1 2 llvm::StringRef test1 = \u0026#34;Hello\\n World\u0026#34;; assert(ComputeIndentOfFinalLine(test1) == \u0026#34; \u0026#34;); 这个测试用例有两行，最后一行的缩进是两个空格。\n没有缩进的用例:\n1 2 llvm::StringRef test2 = \u0026#34;Hello\\nWorld\u0026#34;; assert(ComputeIndentOfFinalLine(test2) == \u0026#34;\u0026#34;); 这个测试用例的最后一行没有缩进。\n只有一个换行符的用例:\n1 2 llvm::StringRef test3 = \u0026#34;\\n\u0026#34;; assert(ComputeIndentOfFinalLine(test3) == \u0026#34;\u0026#34;); 这个测试用例只有一个换行符，所以最后一行没有缩进。\n异常用例:\n1 2 3 llvm::StringRef test4 = \u0026#34;Hello World\u0026#34;; // This should trigger the llvm_unreachable assertion ComputeIndentOfFinalLine(test4); 这个测试用例没有换行符，所以应该触发不可达的断言。\n注意：在实际使用中，你可能需要确保提供给 ComputeIndentOfFinalLine 的文本至少包含一个换行符，以避免触发异常。\nspec Carbon 支持使用一个双引号(\u0026quot;)的单行简单字面量和使用三个单引号(''')的多行块状字面量。块状字符串字面量在第一个'''后可能有一个文件类型指示器；这对字符串本身没有影响，但可能有助于其他工具。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 简单字符串字面量: var simple: String = \u0026#34;example\u0026#34;; // 块状字符串字面量: var block: String = \u0026#39;\u0026#39;\u0026#39; The winds grow high; so do your stomachs, lords. How irksome is this music to my heart! When such strings jar, what hope of harmony? I pray, my lords, let me compound this strife. -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare \u0026#39;\u0026#39;\u0026#39;; // 块状字符串字面量带有文件类型指示器: var code_block: String = \u0026#39;\u0026#39;\u0026#39;cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\u0026#34;; return 0; } \u0026#39;\u0026#39;\u0026#39; 块状字符串字面量的终止行的缩进从所有前面的行中删除。因此，在上面的code_block示例中，只有std::cout和return在结果字符串中有缩进，每个都是4个空格。\n由反斜杠(\\)引入的转义序列用于表示特殊字符或代码单元序列，例如\\n表示换行符。原始字符串字面量还用一个或多个#进行分隔；这些在\\后需要相同数量的井号符号(#)来表示转义序列。原始字符串字面量用于更容易地在字符串中写入字面量\\。简单和块状字符串字面量都有原始形式。例如：\n1 2 3 4 5 6 7 8 // 带有换行转义序列的原始简单字符串字面量: var newline: String = \u0026#34;line one\\nline two\u0026#34;; // 带有字面量`\\n`的原始简单字符串字面量，不是换行: var raw: String = #\u0026#34;line one\\nstill line one\u0026#34;#; // 带有换行转义序列的原始简单字符串字面量: var raw_newline: String = #\u0026#34;line one\\#nline two\u0026#34;#; 详细信息 简单和块状字符串字面量 简单字符串字面量由以下序列组成：\n除\\和\u0026quot;之外的字符。 在字符串字面量中，只有空格字符(U+0020)是有效的空白。 其他水平空白，包括制表符，是不允许的，但为了错误恢复目的被解析为字符串的一部分。 垂直空白不会被解析为简单字符串字面量的一部分。 转义序列。 每个转义序列都被替换为相应的字符序列或代码单元序列。 与无效的空白类似，无效的转义序列，如\\z，被解析为字符串的一部分。 这个序列被包含在\u0026quot;中。例如，这是一个简单的字符串字面量：\n1 var String: lucius = \u0026#34;The strings, my lord, are false.\u0026#34;; 不允许相邻的字符串字面量，如下所示：\n1 2 // 三个相邻的简单字符串字面量`\u0026#34;\u0026#34;`、`\u0026#34;abc\u0026#34;`和`\u0026#34;\u0026#34;`是无效的。 var String: block = \u0026#34;\u0026#34;\u0026#34;abc\u0026#34;\u0026#34;\u0026#34;; 以三个双引号\u0026quot;\u0026quot;\u0026quot;开始的字符串字面量是相邻的字符串字面量。拒绝并诊断它们是很重要的。\n块状字符串字面量以'''开始。'''后面的同一行上的字符是一个可选的文件类型指示器。字面量在下一个三个单引号的实例结束，其中第一个'不是\\'转义序列的一部分。关闭的'''应该是那一行的第一个非空白字符。开头行和结束行之间的行（不包括）是内容行。内容行不应包含不形成转义序列一部分的\\字符。\n块状字符串字面量的缩进是终止行前的水平空白序列。每个非空内容行都应该以字符串字面量的缩进开始。字面量的内容如下形成：\n从每个非空内容行中删除终止行的缩进。 每行的所有尾随空白，包括行终止符，都被替换为一个换行符(U+000A)。 结果行被连接起来。 每个转义序列都被替换为相应的字符序列或代码单元序列。 如果内容行只包含空白字符，则认为它是空的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 所有块状字符串字面量默认包含一个尾随换行符。 var String: newline_example = \u0026#39;\u0026#39;\u0026#39; This is a block string literal. Its first character is \u0026#39;T\u0026#39; and its last character is a newline. It contains another newline character between \u0026#39;is\u0026#39; and \u0026#39;a\u0026#39;. \u0026#39;\u0026#39;\u0026#39;; // 可以使用转义字符\u0026#39;\\\u0026#39;来抑制换行符 var String: suppressed_newlines = \u0026#39;\u0026#39;\u0026#39; This is another block string literal. The newline character here \\ is suppressed, along with the trailing newline here.\\ \u0026#39;\u0026#39;\u0026#39;; // 这个块状字符串字面量是无效的，因为\u0026#39;closing\u0026#39;后面的\u0026#39;\u0026#39;\u0026#39;终止了字面量，但它不在行的开头。 var String: invalid = \u0026#39;\u0026#39;\u0026#39; error: closing \u0026#39;\u0026#39;\u0026#39; is not on its own line. \u0026#39;\u0026#39;\u0026#39;; 文件类型指示器是除'或#之外的任何非空白字符序列。文件类型指示器对 Carbon 编译器没有语义意义，但某些文件类型指示器被语言工具（例如，语法高亮器，代码格式化器）理解为指示字符串字面量内容的结构。\n1 2 3 4 5 // 这是一个块状字符串字面量。它的前两个字符是空格，它的最后一个字符是换行符。它有一个文件类型为\u0026#39;c++\u0026#39;。 var String: starts_with_whitespace = \u0026#39;\u0026#39;\u0026#39;c++ int x = 1; // 这一行以两个空格开始。 int y = 2; // 这一行以两个空格开始。 \u0026#39;\u0026#39;\u0026#39;; 文件类型指示器可能包含超出文件类型本身的语义信息，例如指示代码格式化器为代码块禁用格式化的指令。\n开放问题： 没有明确的已识别文件类型指示器集。非正式地指定一组众所周知的指示器将是有用的，这样工具就可以对这些指示器的含义有一个共同的理解，也许在最佳实践指南中。\n转义序列 在字符串字面量中，以下转义序列被识别：\n转义 含义 \\t U+0009 字符制表符 \\n U+000A 换行符 \\r U+000D 回车符 \\\u0026quot; U+0022 引号 (\u0026quot;) \\' U+0027 逗号 (') \\\\ U+005C 反斜杠 (\\) \\0 值为0的代码单元 \\0D 无效，为未来的发展保留 \\xHH 值为HH16的代码单元 \\u{HHHH...} Unicode 代码点 U+HHHH\u0026hellip; \\\u0026lt;newline\u0026gt; 无字符串字面量内容产生 (仅限块状字面量) 十六进制字符(H)必须为大写(\\xAA，而不是\\xaa)。\n这包括所有C++转义序列，除了：\n\\?，它在字符串字面量中历史上用于转义三字符组，现在不再有任何用途。 \\ooo 八进制转义，因为Carbon不支持八进制字面量；\\0作为一个特殊情况被保留，这对于C互操作性预计是很重要的。 \\uABCD，被\\u{ABCD}替代。 \\U0010FFFF，被\\u{10FFFF}替代。 \\a (铃声)，\\b (退格)，\\v (垂直制表符)，和\\f (换页)。\\a和\\b已经过时，\\f和\\v基本上已经废弃。如果需要，这些字符可以分别用\\x07、\\x08、\\x0B和\\x0C表示。 注意，这是由Swift和Rust支持的相同的转义序列集，除了与Swift不同，它提供了对\\xHH的支持。\n尽管预计八进制转义序列将继续不被允许（尽管\\0D被保留），但决定不支持\\1..\\7或更一般地\\DDDD是_实验性的_。\n在上表中，H表示任意十六进制字符，0-9或A-F（区分大小写）。与C++不同，但与Python相似，\\x期望恰好两个十六进制数字。与JavaScript、Rust和Swift一样，可以使用\\u{10FFFF}表示法按数字表示Unicode代码点。这接受1到8个十六进制字符。可以用这种方式表示016-D7FF16或E00016-10FFFF16范围内的任何数字代码点。\n开放问题: 一些编程语言（尤其是Python）支持\\N{unicode character name}语法。我们可以添加这样的转义序列。未来考虑添加此类支持的提案应注意C++的Unicode研究小组在此领域的工作。\n转义序列\\0不应该后跟十进制数字。在应该在空字节后跟随十进制数字的情况下，可以使用\\x00代替：\u0026quot;foo\\x00123\u0026quot;。目的是保留将来允许十进制转义序列的可能性。\n反斜杠后跟换行符是一个不产生字符串内容的转\n义序列。这个转义序列是_实验性的_，只能出现在块状字符串字面量中。这个转义序列在替换尾随空白后处理为换行符之后进行处理，所以一个\\后跟水平空白后跟一个行终止符会移除直到并包括行终止符的空白。与Rust不同，但与Swift相似，换行符后的转义新行的前导空白不会被移除，除了与终止'''的缩进匹配的空白。\n以反斜杠开头的字符序列，如果不匹配任何已知的转义序列，则无效。除了空格和块状字符串字面量的新行（可选地前置回车）之外，其他空白字符是不允许的。所有其他字符（包括不可打印字符）都被原样保留。因为所有的Carbon源文件都要求是有效的Unicode字符序列，所以只能通过\\x转义序列产生不是有效的UTF-8的代码单元序列。\n决定在字符串字面量中不允许原始制表符是_实验性的_。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var String: fret = \u0026#34;I would \u0026#39;twere something that would fret the string,\\n\u0026#34; + \u0026#34;The master-cord on\u0026#39;s \\u{2764}\\u{FE0F}!\u0026#34;; // 这个字符串包含两个字符（在编码为UTF-8之前）： // U+1F3F9 (弓和箭) 后跟 U+0032 (数字二) var String: password = \u0026#34;\\u{1F3F9}2\u0026#34;; // 这个字符串不包含换行符。 var String: type_mismatch = \u0026#39;\u0026#39;\u0026#39; Shall I compare thee to a summer\u0026#39;s day? Thou art \\ more lovely and more temperate.\\ \u0026#39;\u0026#39;\u0026#39;; var String: trailing_whitespace = \u0026#39;\u0026#39;\u0026#39; This line ends in a space followed by a newline. \\n\\ This line starts with four spaces. \u0026#39;\u0026#39;\u0026#39;; 原始字符串字面量 为了允许字符串的内容包括\\和\u0026quot;，可以通过在开头的定界符前加上_N_个#字符来自定义字符串字面量的定界符。这样的字符串的关闭定界符只有在后面跟着_N_个#字符时才会被识别，同样地，这样的字符串字面量中的转义序列只有在\\后面也跟着_N_个#字符时才会被识别。一个\\、\u0026quot;或'''后面没有跟着_N_个#字符没有特殊意义。\n开始定界符 转义序列引入符 结束定界符 \u0026quot; / ''' \\ (例如, \\n) \u0026quot; / ''' #\u0026quot; / #''' \\# (例如, \\#n) \u0026quot;# / '''# ##\u0026quot; / ##''' \\## (例如, \\##n) \u0026quot;## / '''## ###\u0026quot; / ###''' \\### (例如, \\###n) \u0026quot;### / '''### \u0026hellip; \u0026hellip; \u0026hellip; 例如：\n1 2 3 4 5 6 7 8 9 var String: x = #\u0026#39;\u0026#39;\u0026#39; 这是字符串的内容。\u0026#39;T\u0026#39;是字符串的第一个字符。 \u0026#39;\u0026#39;\u0026#39; \u0026lt;-- 这不是字符串的结尾。 \u0026#39;\u0026#39;\u0026#39;#; // 但前面的那行确实结束了字符串。 // OK, 最后一个字符是\\ var String: y = #\u0026#34;Hello\\\u0026#34;#; var String: z = ##\u0026#34;Raw strings #\u0026#34;nesting\u0026#34;#\u0026#34;##; var String: w = #\u0026#34;Tab is expressed as \\t. Example: \u0026#39;\\#t\u0026#39;\u0026#34;#; 编码 字符串字面量产生一个8位字节的序列。像Carbon源文件一样，字符串字面量使用UTF-8编码。然而，不能保证字符串是有效的UTF-8，因为可以通过\\xHH转义序列插入任意字节序列。\n这是_实验性的_，如果我们发现直接表示其他编码的字符串字面量的足够动机，应该重新考虑。同样，随着库对字符串类型的支持的发展，我们应该考虑包括字符串字面量语法（也许作为默认值），保证字符串内容是有效的UTF-8编码，这样在类型系统中可以区分有效的UTF-8和任意字符串。在这样的字符串字面量中，我们应该考虑拒绝HH大于7F16的\\xHH转义，如Rust中所做的那样。\n引用 [1] : Floating-point numeric types - C# reference | Microsoft Learn [2] : numeric_literals | MDN Web [3] : json-tutorial | miloyip [4] : numeric_literals | Carbon [5] : proposals 0143 | Carbon [6] : proposals 1983 | Carbon ","permalink":"https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/","summary":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一","title":"从零构造现代语言编译器(1): 词法分析"},{"content":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，预计2-3年内结束实验[2]。\nCarbon官方项目选择Bazel构建工具，一方面是因为Google内部工具链的高可用性，相比于Go语言早期构建方式，作为同样出自Google之手的Carbon语言，避免手搓Makefile的繁琐，选用更加现代的工具链作为构建工具，另一方面也由于Google在LLVM之上的积累和贡献[3]，LLVM目前仓库中Bazel构建方式由Google团队完成及合并（不过经过测试发现，存在年久失修的问题[4]）。\n本项目介绍及依赖安装 本项目基于Carbon，为深入剖析现代编译器前端实现以及LLVM工具链上层使用，一步一步实现名为Cocktail（鸡尾酒）的语言，代码协议遵从官方仓库Lisence[5]，项目按照LLVM仓库主流构建方式和代码结构组织，使用CMake、Google test、Google mock等工具完成。\n本项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试，需要安装的依赖环境参考如下命令：\n1 sudo apt-get install cmake g++ clang bison flex libgtest-dev libgmock-dev make valgrind libbenchmark-dev llvm-15-dev CMake项目结构 首先从0到1构建CMake项目结构，参照clang的项目结构，project_structure代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 . ├── CMakeLists.txt ├── include │ └── Cocktail │ └── Lexer │ └── Basic.h ├── lib │ └── Lexer │ └── Basic.cc └── unittests ├── CMakeLists.txt └── Lexer ├── Basic.t.cc └── CMakeLists.txt 其中include作为Cocktail的头文件目录，lib作为Cocktail的库文件目录，其中C++文件一律以.cc作为后缀，unittests作为Cocktail单元测试文件目录，并且其中单元测试一律以.t.cc作为后缀，单元测试依赖头文件以.t.h为后缀。\n可在该目录下执行如下命令完成构建（make），或自行选用Ninja build：\n1 2 3 4 5 \u0026gt; mkdir build \u0026gt; cd build \u0026gt; cmake .. \u0026gt; make -j$(nproc) \u0026gt; ctest -j$(nproc) cmake构建结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 -- The C compiler identification is GNU 11.3.0 -- The CXX compiler identification is GNU 11.3.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Project: \u0026#39;cocktail\u0026#39; -- Performing Test HAVE_FFI_CALL -- Performing Test HAVE_FFI_CALL - Success -- Found FFI: /usr/lib/x86_64-linux-gnu/libffi.so -- Performing Test Terminfo_LINKABLE -- Performing Test Terminfo_LINKABLE - Success -- Found Terminfo: /usr/lib/x86_64-linux-gnu/libtinfo.so -- Found ZLIB: /usr/lib/x86_64-linux-gnu/libz.so (found version \u0026#34;1.2.11\u0026#34;) -- Found LibXml2: /usr/lib/x86_64-linux-gnu/libxml2.so (found version \u0026#34;2.9.13\u0026#34;) -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success -- Found Threads: TRUE -- unittest files found: Basic.t.cc -- Configuring done -- Generating done -- Build files have been written to: /carbon-blog/code/project_structure/build make构建结果如下：\n1 2 3 4 5 6 [ 25%] Building CXX object CMakeFiles/cocktail.dir/lib/Lexer/Basic.cc.o [ 50%] Linking CXX static library libcocktail.a [ 50%] Built target cocktail [ 75%] Building CXX object unittests/Lexer/CMakeFiles/Basic.t.dir/Basic.t.cc.o [100%] Linking CXX executable Basic.t [100%] Built target Basic.t ctest构建结果如下：\n1 2 3 4 5 6 7 8 9 Test project /carbon-blog/code/project_structure/build Start 1: Basic.t 1/2 Test #1: Basic.t .......................... Passed 0.01 sec Start 2: Basic.t-memory-check 2/2 Test #2: Basic.t-memory-check ............. Passed 0.97 sec 100% tests passed, 0 tests failed out of 2 Total Test time (real) = 0.98 sec 介绍CMake构建文件 在主目录下CMakeList.txt文件中可以看到这条add_compile_options(-fno-rtti)编译选项，这里表明禁用C++的RTTI特性，由于LLVM实现了自己的一套RTTI机制，此处加入该选项禁用。\nset(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm)设置LLVM路径，由于上述使用apt包管理安装llvm-15-dev，LLVM默认CMake路径为/usr/lib/llvm-15/lib/cmake/llvm。\n同时需要加入如下条件使得项目完成LLVM的引入：\n1 2 3 4 find_package(LLVM REQUIRED CONFIG) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) 关于内存泄漏检查，使用valgrind工具，将其加入ctest中，对编译出的二进制目标进行测试：\n1 2 3 4 find_program(CMAKE_MEMORYCHECK_COMMAND valgrind) set(memcheck_command ${CMAKE_MEMORYCHECK_COMMAND} ${CMAKE_MEMORYCHECK_COMMAND_OPTIONS} --error-exitcode=1 --leak-check=full) add_test(${FILE_NAME}-memory-check ${memcheck_command} ./${FILE_NAME}) clang-format使用 clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format[6]配置。\nclang-tidy使用 clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy[7]配置。\n项目调试的前置知识 由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件[8]，得以直观显示LLVM数据结构。\n引用 [1] : “C++的后继语言”\n[2] : 实验\n[3] : 贡献\n[4] : 年久失修的问题\n[5] : 官方仓库Lisence\n[6] : .clang-format\n[7] : .clang-tidy\n[8] : lldbDataFormatters插件\n","permalink":"https://canftin.github.io/posts/tech/p1_compiler_build_0_start/","summary":"carbon-lang介绍 Carbon作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前仍在Google的项目孵化期中，","title":"从零构造现代语言编译器(0): 开始"},{"content":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年我个人陆陆续续整理了一些资料和笔记，但只适合我自己查找回顾，导致思维脉络过于零散，不够系统。 我现在的工作专注于编译器开发，目前工作三年，前两年一直在做一些后端业务型的服务或工具的开发，近一年主要集中在底层语言编译器以及ai编译器开发部分。 重启这个博客，一方面想让自己开始保持一定的知识整理习惯，增强语言输出能力，另一方面也是总结归纳底层系统知识。 最近的一个愿景就是先成体系地输出关于现代语言编译器的构造系列文章，尝试去从源码分析的角度完整剖析语言编译器的构成，希望从这里开始重新投入。\n","permalink":"https://canftin.github.io/posts/tech/p0_restart_blog/","summary":"这个博客从16年开始就在尝试用各种前端构建，期间也经历了WordPress、hexo等工具的使用，一直没有产出多少实质性的文章，虽然这么多年","title":"重启博客"},{"content":"我是矩木，目前专注于编译器开发，我的GitHub。\n","permalink":"https://canftin.github.io/about/","summary":"我是矩木，目前专注于编译器开发，我的GitHub。","title":"关于我"}]