<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从零构造现代语言编译器(0): C++后继语言 | CanftIn's Blog</title><meta name=keywords content><meta name=description content="1. carbon-lang介绍 自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+"><meta name=author content="CanftIn"><link rel=canonical href=https://canftin.github.io/posts/tech/p1_compiler_build_0_start/><link crossorigin=anonymous href=/assets/css/stylesheet.a82955faa917eb088598a3f91ac57597187a910fe8499e3b1c922d4f9cbe56b2.css integrity="sha256-qClV+qkX6wiFmKP5GsV1lxh6kQ/oSZ47HJItT5y+VrI=" rel="preload stylesheet" as=style><link rel=icon href=https://canftin.github.io/img/text_icon.ico><link rel=icon type=image/png sizes=16x16 href=https://canftin.github.io/img/text_icon.ico><link rel=icon type=image/png sizes=32x32 href=https://canftin.github.io/img/text_icon.ico><link rel=apple-touch-icon href=https://canftin.github.io/text_icon.ico><link rel=mask-icon href=https://canftin.github.io/text_icon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="从零构造现代语言编译器(0): C++后继语言"><meta property="og:description" content="1. carbon-lang介绍 自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+"><meta property="og:type" content="article"><meta property="og:url" content="https://canftin.github.io/posts/tech/p1_compiler_build_0_start/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-21T12:33:27+08:00"><meta property="article:modified_time" content="2023-09-21T12:33:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="从零构造现代语言编译器(0): C++后继语言"><meta name=twitter:description content="1. carbon-lang介绍 自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://canftin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://canftin.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"从零构造现代语言编译器(0): C++后继语言","item":"https://canftin.github.io/posts/tech/p1_compiler_build_0_start/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零构造现代语言编译器(0): C++后继语言","name":"从零构造现代语言编译器(0): C\u002b\u002b后继语言","description":"1. carbon-lang介绍 自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+","keywords":[""],"articleBody":"1. carbon-lang介绍 自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+的 star。\nCarbon 作为一个实验性的通用编程语言，旨在成为“C++的后继语言”[1]，目前（2023.10）仍在项目孵化期中，预计2-3年内结束实验[2]，Carbon 由于它的设计和目标，实现编译器会具有非常大难度与挑战性，因而 Chandler 将它作为一个 long-term 的开发项目，预期在2026年发布1.0版本。\n但即使是可能要在比较长的时间后才能看到生产可用的版本，目前的 Carbon 仓库代码也仍然值得学习，包含非常多足够现代的 C++ 实现方式，本系列文章就从 Carbon 开始，介绍并分析一个完整的现代语言编译器的实现过程，以及它背后的设计思想。\nCarbon 官方项目选择 Bazel 构建工具，一方面是因为 Google 内部工具链的高可用性，相比于 Go 语言早期手搓 Makefile 的构建方式，Carbon 语言选用更加现代的工具链作为构建工具，另一方面也由于 Google 在LLVM之上的积累和贡献[3]，LLVM 目前仓库中 Bazel 构建方式由 Google 团队完成及合并（不过存在一些 build 的问题[4]，并且随着 llvm 的版本迭代常需要对 Bazel 进行一些 patch）。\n我提供了一个 Fork 于 Carbon 所修改的仓库：https://github.com/CanftIn/cocktail-lang，为深入剖析现代编译器前端实现，一步一步进行其中的构建，项目按照LLVM仓库主流构建方式和代码结构组织，后续的系列文章也按这个仓库和 Carbon 官方仓库共同进行讲解。\n该项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试。\n2. C++后继语言元年 2022年被称为 C++ 后继语言（successor languages）元年。三种可能的继任者语言在 C++ 的主要会议上的主题演讲中被宣布。\n首先，Dave Abrahams 和 Dimitri Racordon 在 C++ Now 上宣布了 Val 语言（后更名为hylo-lang）。Val 的核心思想是，人们可以使用可变的值语义来构建安全、高效的程序。\n两个月后，Chandler Carruth 在 CppNorth 上宣布了 Carbon 语言。Carbon 语言试图解决 C++ 的几个问题：数十年的技术债务，对向后兼容性的优先考虑以及 C++ 的演变过程。\n再过两个月，在 CppCon 上，Herb Sutter 宣布了 CppFront，作为 C++ 的可能继任者。他的主要目标是“加强 C++ 自身，并双倍重视 C++”，防止用户迁移到其他语言。宣称的目标是使 C++ 更安全50倍，更简单10倍。\n而早在更早之前 github 上的项目 circle 就完成了很多 C++ 之上的现代语言特性。\n为什么 C++ 存在近40年仍然经久不衰？\nC++ 是一种特殊的编程语言，具有多种编程范式。它是最常用的编程语言之一，但也是最受批评的语言之一。热爱 C++ 的人备受喜爱，但更多的人都抱怨这门语言太大、太复杂，既有不必要的功能，又缺乏足够的功能。过于概括地说，C++ 似乎是一系列随机的功能组合，没有一个清晰连贯的主线。\nBjarne Stroustrup 为了辩护这门语言说：“within C++, there is a much smaller and cleaner language struggling to get out”（在 C++ 中，有一个更小、更干净的语言努力地想要脱颖而出）。尽管这句话旨在为 C++ 辩护，但仔细回想后会发现它也是一种隐含的批评：C++ 仍然没有成为人们期望的那种更小、更干净的语言。\nC++ 的标准委员会一直在不断地改进这门语言。但是这也意味着 C++ 积累了大量的技术债务。这部分是因为标准委员会一直在试图修复这门语言的错误，部分是因为技术进步导致了新的需求。为了避免破坏现有的代码，C++ 标准委员会非常重视向后兼容性。这意味着新版本的 C++ 通常不能删除旧的或过时的功能。此外，C++ 标准委员会的工作方式导致了 C++ 形成了一个缓慢的演变过程。新功能必须经过多年的实验和讨论才能被添加到标准中。\n所以，主要的问题是：如何得到一门比现有的C++更简单、更干净，而且在系统编程领域的更好的语言？C++的继任者应该是什么样子的？\n那么什么是后继语言？\n相较于 C++，这是一种具有更少缺陷/错误的语言。 与 C++ 相比，这是一种具有友好特性的语言。 这是一种会比 C++ 更安全、更清晰、更高效的语言。 这是一种与现有 C++ 代码广泛兼容的语言（兼容方式可能是Subset/Superset/Overlap）： 后继语言这个目标对于 C++ 来说是很值得尝试的目标，上面这张图也表示了去实现 C++ 后继语言的方式，新语言作为 C++ 的子集或者超集又或者它们之间互有交叉。\n引发出来的一个问题是，为了实现新语言，发明新的编译器是否富有成效或价值？Carbon 就是这样一个实验性项目，通过发展现有的 C++ 工具链如 LLVM 和 Clang 来实现新语言。Carbon 试图解决 C++ 的几个问题：\n数十年的技术债务 对向后兼容性的优先考虑 C++ 的演变过程 Carbon 还提出了新的目标：\n默认快速：与 C++ 相比，Carbon 代码应该至少同样快。 默认安全：与Rust不同，Carbon 的设计师没有试图创造一个绝对安全的语言。而是创造一个默认安全的语言。 简单：删除了一些已经过时的功能，例如宏、模板、继承和异常，并引入了新的功能，例如类型推导和类型类。 尽管 Carbon 有许多有趣的想法，但它还需要经过时间的考验。特别是其简化 C++ 的目标，这可能是一个很大的挑战，因为 C++ 是一个非常复杂的语言。\nCarbon 作为 C++ 后继语言采用的策略并非上面的 intersection 是 C++ interop，即和现有的 C++ 代码进行交互，Carbon 与 C++ 之间具有互操作能力，类似于 TypeScript 之于 JavaScript、Kotlin 之于 Java、Swift 之于 Object-C，一个新语言的发展离不开一个性能优秀的编译器或解释器，但更重要的是语言之上的生态，为了成功，任何希望替代 C++ 的语言都必须与 C++ 有很好的互操作性，这也是 Carbon 的目标。Carbon 期望能利用现有 C++ 的生态的同时，去实践更多语言上的目标。\n3. Cocktail CMake项目结构 首先从0到1构建CMake项目结构，参照clang的项目结构，初版结构链接：project_structure。\n其中 include 作为Cocktail的头文件目录，lib 作为 Cocktail 的库文件目录，其中 C++ 文件一律以 .cc 作为后缀，unittests 作为 Cocktail 单元测试文件目录，并且其中单元测试一律以 .t.cc 作为后缀，单元测试依赖头文件以 .t.h 为后缀。\n在主目录下 CMakeList.txt 文件中可以看到这条 add_compile_options(-fno-rtti) 编译选项，这里表明禁用 C++ 的 RTTI 特性，由于 LLVM 实现了自己的一套 RTTI 机制，此处加入该选项禁用。\n项目依赖于 LLVM，CMake 中 set(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm) 设置 LLVM 路径，需要按 readme 介绍使用 apt 包管理安装 llvm-15-dev（项目开始暂不手动构建 LLVM），LLVM 默认 CMake 路径为 /usr/lib/llvm-15/lib/cmake/llvm。\n同时需要加入如下条件使得项目完成 LLVM 的引入：\n1 2 3 4 find_package(LLVM REQUIRED CONFIG) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) 关于内存泄漏检查，使用valgrind工具，可将其加入ctest中，对编译出的二进制目标进行测试：\n1 2 3 4 find_program(CMAKE_MEMORYCHECK_COMMAND valgrind) set(memcheck_command ${CMAKE_MEMORYCHECK_COMMAND} ${CMAKE_MEMORYCHECK_COMMAND_OPTIONS} --error-exitcode=1 --leak-check=full) add_test(${FILE_NAME}-memory-check ${memcheck_command} ./${FILE_NAME}) 3.1 clang-format使用 clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format[5]配置。\n3.2 clang-tidy使用 clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy[6]配置。\n3.3 项目调试的前置知识 由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件[7]，得以直观显示LLVM数据结构。\n4. 引用 [1] : “C++的后继语言”\n[2] : 实验\n[3] : 贡献\n[4] : 年久失修的问题\n[5] : .clang-format\n[6] : .clang-tidy\n[7] : lldbDataFormatters插件\n[8] : https://accu.org/journals/overload/30/172/teodorescu/\n","wordCount":"3071","inLanguage":"en","datePublished":"2023-09-21T12:33:27+08:00","dateModified":"2023-09-21T12:33:27+08:00","author":[{"@type":"Person","name":"CanftIn"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://canftin.github.io/posts/tech/p1_compiler_build_0_start/"},"publisher":{"@type":"Organization","name":"CanftIn's Blog","logo":{"@type":"ImageObject","url":"https://canftin.github.io/img/text_icon.ico"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://canftin.github.io/ accesskey=h title="CanftIn's Blog (Alt + H)">CanftIn's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://canftin.github.io/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://canftin.github.io/ title=主页><span>主页</span></a></li><li><a href=https://canftin.github.io/posts title=文章><span>文章</span></a></li><li><a href=https://canftin.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://canftin.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://canftin.github.io/about title=关于><span>关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://canftin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://canftin.github.io/posts/>所有文章</a>&nbsp;»&nbsp;<a href=https://canftin.github.io/posts/tech/>技术</a></div><h1 class=post-title>从零构造现代语言编译器(0): C++后继语言</h1><div class=post-meta><span title='2023-09-21 12:33:27 +0800 CST'>2023-09-21</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;CanftIn<span style=opacity:.8>
<span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-carbon-lang%e4%bb%8b%e7%bb%8d aria-label="1. carbon-lang介绍">1. carbon-lang介绍</a></li><li><a href=#2-c%e5%90%8e%e7%bb%a7%e8%af%ad%e8%a8%80%e5%85%83%e5%b9%b4 aria-label="2. C++后继语言元年">2. C++后继语言元年</a></li><li><a href=#3-cocktail-cmake%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84 aria-label="3. Cocktail CMake项目结构">3. Cocktail CMake项目结构</a><ul><li><a href=#31-clang-format%e4%bd%bf%e7%94%a8 aria-label="3.1 clang-format使用">3.1 clang-format使用</a></li><li><a href=#32-clang-tidy%e4%bd%bf%e7%94%a8 aria-label="3.2 clang-tidy使用">3.2 clang-tidy使用</a></li><li><a href=#33-%e9%a1%b9%e7%9b%ae%e8%b0%83%e8%af%95%e7%9a%84%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86 aria-label="3.3 项目调试的前置知识">3.3 项目调试的前置知识</a></li></ul></li><li><a href=#4-%e5%bc%95%e7%94%a8 aria-label="4. 引用">4. 引用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-carbon-lang介绍>1. carbon-lang介绍<a hidden class=anchor aria-hidden=true href=#1-carbon-lang介绍>#</a></h2><p>自去年（2020.7）Chandler Carruth 作为 Google 的 tech leader 官方宣布 Carbon 语言，这个项目在 github 上热度一度飙升，至今已有30k+的 star。</p><p>Carbon 作为一个实验性的通用编程语言，旨在成为“C++的后继语言”<sup>[<a href=#references-anchor>1</a>]</sup>，目前（2023.10）仍在项目孵化期中，预计2-3年内结束实验<sup>[<a href=#references-anchor>2</a>]</sup>，Carbon 由于它的设计和目标，实现编译器会具有非常大难度与挑战性，因而 Chandler 将它作为一个 long-term 的开发项目，预期在2026年发布1.0版本。</p><p>但即使是可能要在比较长的时间后才能看到生产可用的版本，目前的 Carbon 仓库代码也仍然值得学习，包含非常多足够现代的 C++ 实现方式，本系列文章就从 Carbon 开始，介绍并分析一个完整的现代语言编译器的实现过程，以及它背后的设计思想。</p><p>Carbon 官方项目选择 Bazel 构建工具，一方面是因为 Google 内部工具链的高可用性，相比于 Go 语言早期手搓 Makefile 的构建方式，Carbon 语言选用更加现代的工具链作为构建工具，另一方面也由于 Google 在LLVM之上的积累和贡献<sup>[<a href=#references-anchor>3</a>]</sup>，LLVM 目前仓库中 Bazel 构建方式由 Google 团队完成及合并（不过存在一些 build 的问题<sup>[<a href=#references-anchor>4</a>]</sup>，并且随着 llvm 的版本迭代常需要对 Bazel 进行一些 patch）。</p><p>我提供了一个 Fork 于 Carbon 所修改的仓库：<a href=https://github.com/CanftIn/cocktail-lang>https://github.com/CanftIn/cocktail-lang</a>，为深入剖析现代编译器前端实现，一步一步进行其中的构建，项目按照LLVM仓库主流构建方式和代码结构组织，后续的系列文章也按这个仓库和 Carbon 官方仓库共同进行讲解。</p><p>该项目在Ubuntu 22.04系统环境下测试完成，其他环境暂未测试。</p><h2 id=2-c后继语言元年>2. C++后继语言元年<a hidden class=anchor aria-hidden=true href=#2-c后继语言元年>#</a></h2><p>2022年被称为 C++ 后继语言（successor languages）元年。三种可能的继任者语言在 C++ 的主要会议上的主题演讲中被宣布。</p><p>首先，Dave Abrahams 和 Dimitri Racordon 在 C++ Now 上宣布了 Val 语言（后更名为hylo-lang）。Val 的核心思想是，人们可以使用可变的值语义来构建安全、高效的程序。</p><p>两个月后，Chandler Carruth 在 CppNorth 上宣布了 Carbon 语言。Carbon 语言试图解决 C++ 的几个问题：数十年的技术债务，对向后兼容性的优先考虑以及 C++ 的演变过程。</p><p>再过两个月，在 CppCon 上，Herb Sutter 宣布了 CppFront，作为 C++ 的可能继任者。他的主要目标是“加强 C++ 自身，并双倍重视 C++”，防止用户迁移到其他语言。宣称的目标是使 C++ 更安全50倍，更简单10倍。</p><p>而早在更早之前 github 上的项目 circle 就完成了很多 C++ 之上的现代语言特性。</p><p><strong>为什么 C++ 存在近40年仍然经久不衰？</strong></p><p>C++ 是一种特殊的编程语言，具有多种编程范式。它是最常用的编程语言之一，但也是最受批评的语言之一。热爱 C++ 的人备受喜爱，但更多的人都抱怨这门语言太大、太复杂，既有不必要的功能，又缺乏足够的功能。过于概括地说，C++ 似乎是一系列随机的功能组合，没有一个清晰连贯的主线。</p><p>Bjarne Stroustrup 为了辩护这门语言说：&ldquo;within C++, there is a much smaller and cleaner language struggling to get out&rdquo;（在 C++ 中，有一个更小、更干净的语言努力地想要脱颖而出）。尽管这句话旨在为 C++ 辩护，但仔细回想后会发现它也是一种隐含的批评：C++ 仍然没有成为人们期望的那种更小、更干净的语言。</p><p>C++ 的标准委员会一直在不断地改进这门语言。但是这也意味着 C++ 积累了大量的技术债务。这部分是因为标准委员会一直在试图修复这门语言的错误，部分是因为技术进步导致了新的需求。为了避免破坏现有的代码，C++ 标准委员会非常重视向后兼容性。这意味着新版本的 C++ 通常不能删除旧的或过时的功能。此外，C++ 标准委员会的工作方式导致了 C++ 形成了一个缓慢的演变过程。新功能必须经过多年的实验和讨论才能被添加到标准中。</p><p>所以，主要的问题是：如何得到一门比现有的C++更简单、更干净，而且在系统编程领域的更好的语言？C++的继任者应该是什么样子的？</p><p><strong>那么什么是后继语言？</strong></p><ul><li>相较于 C++，这是一种具有更少缺陷/错误的语言。</li><li>与 C++ 相比，这是一种具有友好特性的语言。</li><li>这是一种会比 C++ 更安全、更清晰、更高效的语言。</li><li>这是一种与现有 C++ 代码广泛兼容的语言（兼容方式可能是Subset/Superset/Overlap）：</li></ul><p><img loading=lazy src=/img/post_pic/p1_cpp_intersection.png alt=p1_cpp_intersection></p><p>后继语言这个目标对于 C++ 来说是很值得尝试的目标，上面这张图也表示了去实现 C++ 后继语言的方式，新语言作为 C++ 的子集或者超集又或者它们之间互有交叉。</p><p>引发出来的一个问题是，为了实现新语言，发明新的编译器是否富有成效或价值？Carbon 就是这样一个实验性项目，通过发展现有的 C++ 工具链如 LLVM 和 Clang 来实现新语言。Carbon 试图解决 C++ 的几个问题：</p><ul><li>数十年的技术债务</li><li>对向后兼容性的优先考虑</li><li>C++ 的演变过程</li></ul><p>Carbon 还提出了新的目标：</p><ul><li>默认快速：与 C++ 相比，Carbon 代码应该至少同样快。</li><li>默认安全：与Rust不同，Carbon 的设计师没有试图创造一个绝对安全的语言。而是创造一个默认安全的语言。</li><li>简单：删除了一些已经过时的功能，例如宏、模板、继承和异常，并引入了新的功能，例如类型推导和类型类。</li></ul><p>尽管 Carbon 有许多有趣的想法，但它还需要经过时间的考验。特别是其简化 C++ 的目标，这可能是一个很大的挑战，因为 C++ 是一个非常复杂的语言。</p><p>Carbon 作为 C++ 后继语言采用的策略并非上面的 intersection 是 C++ interop，即和现有的 C++ 代码进行交互，Carbon 与 C++ 之间具有互操作能力，类似于 TypeScript 之于 JavaScript、Kotlin 之于 Java、Swift 之于 Object-C，一个新语言的发展离不开一个性能优秀的编译器或解释器，但更重要的是语言之上的生态，为了成功，任何希望替代 C++ 的语言都必须与 C++ 有很好的互操作性，这也是 Carbon 的目标。Carbon 期望能利用现有 C++ 的生态的同时，去实践更多语言上的目标。</p><p><img loading=lazy src=/img/post_pic/p1_cpp_interop.png alt=p1_cpp_interop></p><h2 id=3-cocktail-cmake项目结构>3. Cocktail CMake项目结构<a hidden class=anchor aria-hidden=true href=#3-cocktail-cmake项目结构>#</a></h2><p>首先从0到1构建CMake项目结构，参照clang的项目结构，初版结构链接：<a href=https://github.com/CanftIn/carbon-blog/tree/master/code/project_structure/section1>project_structure</a>。</p><p>其中 include 作为Cocktail的头文件目录，lib 作为 Cocktail 的库文件目录，其中 C++ 文件一律以 <code>.cc</code> 作为后缀，unittests 作为 Cocktail 单元测试文件目录，并且其中单元测试一律以 <code>.t.cc</code> 作为后缀，单元测试依赖头文件以 <code>.t.h</code> 为后缀。</p><p>在主目录下 <code>CMakeList.txt</code> 文件中可以看到这条 <code>add_compile_options(-fno-rtti)</code> 编译选项，这里表明禁用 C++ 的 RTTI 特性，由于 LLVM 实现了自己的一套 RTTI 机制，此处加入该选项禁用。</p><p>项目依赖于 LLVM，CMake 中 <code>set(LLVM_DIR /usr/lib/llvm-15/lib/cmake/llvm)</code> 设置 LLVM 路径，需要按 readme 介绍使用 apt 包管理安装 <code>llvm-15-dev</code>（项目开始暂不手动构建 LLVM），LLVM 默认 CMake 路径为 <code>/usr/lib/llvm-15/lib/cmake/llvm</code>。</p><p>同时需要加入如下条件使得项目完成 LLVM 的引入：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CMake data-lang=CMake><span style=display:flex><span>find_package(<span style=color:#e6db74>LLVM</span> <span style=color:#e6db74>REQUIRED</span> <span style=color:#e6db74>CONFIG</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>include_directories(<span style=color:#f92672>${</span>LLVM_INCLUDE_DIRS<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>add_definitions(<span style=color:#f92672>${</span>LLVM_DEFINITIONS<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></td></tr></table></div></div><p>关于内存泄漏检查，使用valgrind工具，可将其加入ctest中，对编译出的二进制目标进行测试：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CMake data-lang=CMake><span style=display:flex><span>find_program(<span style=color:#e6db74>CMAKE_MEMORYCHECK_COMMAND</span> <span style=color:#e6db74>valgrind</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>set(<span style=color:#e6db74>memcheck_command</span> <span style=color:#f92672>${</span>CMAKE_MEMORYCHECK_COMMAND<span style=color:#f92672>}</span> <span style=color:#f92672>${</span>CMAKE_MEMORYCHECK_COMMAND_OPTIONS<span style=color:#f92672>}</span> <span style=color:#e6db74>--error-exitcode=1</span> <span style=color:#e6db74>--leak-check=full</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>add_test(<span style=color:#f92672>${</span>FILE_NAME<span style=color:#f92672>}</span><span style=color:#e6db74>-memory-check</span> <span style=color:#f92672>${</span>memcheck_command<span style=color:#f92672>}</span> <span style=color:#e6db74>./</span><span style=color:#f92672>${</span>FILE_NAME<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=31-clang-format使用>3.1 clang-format使用<a hidden class=anchor aria-hidden=true href=#31-clang-format使用>#</a></h3><p>clang-format作为LLVM官方提供的自动格式化工具，能够格式化排版C++代码，统一代码样式，本仓库代码一律使用官方.clang-format<sup>[<a href=#references-anchor>5</a>]</sup>配置。</p><h3 id=32-clang-tidy使用>3.2 clang-tidy使用<a hidden class=anchor aria-hidden=true href=#32-clang-tidy使用>#</a></h3><p>clang-tidy作为C++的静态检查工具，因为它基于AST，比基于正则表达式的静态检查工具更为精准。本仓库代码一律使用官方.clang-tidy<sup>[<a href=#references-anchor>6</a>]</sup>配置。</p><h3 id=33-项目调试的前置知识>3.3 项目调试的前置知识<a hidden class=anchor aria-hidden=true href=#33-项目调试的前置知识>#</a></h3><p>由于本项目基于LLVM，需要用到诸如StringRef、SmallVector等LLVM基础工具，在使用lldb vscode前端调试时存在难以打印的问题，这里需要引入LLVM官方仓库中lldbDataFormatters插件<sup>[<a href=#references-anchor>7</a>]</sup>，得以直观显示LLVM数据结构。</p><div id=references-anchor></div><h2 id=4-引用>4. 引用<a hidden class=anchor aria-hidden=true href=#4-引用>#</a></h2><ul><li><p>[1] : <a href=https://en.wikipedia.org/wiki/Carbon_(programming_language)>“C++的后继语言”</a></p></li><li><p>[2] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/roadmap.md>实验</a></p></li><li><p>[3] : <a href=https://github.com/google/llvm-bazel>贡献</a></p></li><li><p>[4] : <a href=https://github.com/llvm/llvm-project/issues/62360>年久失修的问题</a></p></li><li><p>[5] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/.clang-format>.clang-format</a></p></li><li><p>[6] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/.clang-tidy>.clang-tidy</a></p></li><li><p>[7] : <a href=https://github.com/llvm/llvm-project/blob/main/llvm/utils/lldbDataFormatters.py>lldbDataFormatters插件</a></p></li><li><p>[8] : <a href=https://accu.org/journals/overload/30/172/teodorescu/>https://accu.org/journals/overload/30/172/teodorescu/</a></p></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/><span class=title>« Prev</span><br><span>从零构造现代语言编译器(1): 词法分析</span></a>
<a class=next href=https://canftin.github.io/posts/tech/p0_restart_blog/><span class=title>Next »</span><br><span>重启博客</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
2016-2023
<a href=https://github.com/canftin style=color:#939393>CanftIn</a>
, 许可协议：<a class=link href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-ND 4.0</a>,</span>
<span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function n(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)})})</script></body></html>