<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从零构造现代语言编译器(1): 词法分析 | CanftIn's Blog</title><meta name=keywords content><meta name=description content="1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一"><meta name=author content="CanftIn"><link rel=canonical href=https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/><link crossorigin=anonymous href=/assets/css/stylesheet.a82955faa917eb088598a3f91ac57597187a910fe8499e3b1c922d4f9cbe56b2.css integrity="sha256-qClV+qkX6wiFmKP5GsV1lxh6kQ/oSZ47HJItT5y+VrI=" rel="preload stylesheet" as=style><link rel=icon href=https://canftin.github.io/img/text_icon.ico><link rel=icon type=image/png sizes=16x16 href=https://canftin.github.io/img/text_icon.ico><link rel=icon type=image/png sizes=32x32 href=https://canftin.github.io/img/text_icon.ico><link rel=apple-touch-icon href=https://canftin.github.io/text_icon.ico><link rel=mask-icon href=https://canftin.github.io/text_icon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script>
<script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="从零构造现代语言编译器(1): 词法分析"><meta property="og:description" content="1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一"><meta property="og:type" content="article"><meta property="og:url" content="https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-21T14:51:58+08:00"><meta property="article:modified_time" content="2023-09-21T14:51:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="从零构造现代语言编译器(1): 词法分析"><meta name=twitter:description content="1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://canftin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"技术","item":"https://canftin.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"从零构造现代语言编译器(1): 词法分析","item":"https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零构造现代语言编译器(1): 词法分析","name":"从零构造现代语言编译器(1): 词法分析","description":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一","keywords":[""],"articleBody":"1. 什么是数值字面量 数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 123、3.14、0xFF、1.23e-4 都可以被视为数值字面量。\n字面量的类型通常根据其格式和位置决定。例如在大多数编程语言[1][2][3]中，带有小数点的数字将被视为浮点数（如 3.14 ），而没有小数点的数字将被视为整数（如 123 ）。\n更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。\n本章将从数值字面量的解析入手，开始进入编译器构造的世界。\nCarbon数值类型介绍 Carbon中数值类型[4][5]有如下几种：\n整数类型\n整数根据进制分为如下类型：十进制（例如 12345 ）、十六进制（例如 0x1FE ）、二进制（例如 0b1010 ）等\n实数类型\n实数类型总是包含 . 符号，实数类型例如基础类型 123.456 以及科学技术法表示 123.456e789、0x1.2p123 等，其中科学技术法表示中的字符 e 及 p 在Carbon中称为指数（对应代码中exponent 字符，实际在幂运算中应为底数），对于一个十进制值 N 来说，e 相当于10±N，而 p 相当于2±N。\n且实数类型字面量 exponent 字符后可跟随 + 或 - 字符，例如 12.34e+56 或 56.34e-12。\n数字分隔符[6]\n数字分隔符由下划线 _ 表示，例如十进制数: 1_23_456_7890、十六进制数: 0x7_F_FF_FFFF、实数: 2_147.48_3648e12_345 或 0x1_00CA.FE_F00Dp+2_4、二进制数: 0b1_000_101_11 等。\n数值字面量词法解析： 首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 _ 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 exponent 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供NumericLiteralToken类的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。\n以下代码参考numeric_literal section1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class NumericLiteralToken { public: auto Text() const -\u003e llvm::StringRef { return text; } static auto Lex(llvm::StringRef source_text) -\u003e llvm::Optional\u003cNumericLiteralToken\u003e; auto GetRadixPoint() -\u003e int { return radix_point; } auto GetExponent() -\u003e int { return exponent; } private: NumericLiteralToken() {} llvm::StringRef text; // '.'字符的偏移量 int radix_point; // 'e'或'p'字符的偏移量 int exponent; }; 其中我们重点关注Lex接口的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 auto NumericLiteralToken::Lex(llvm::StringRef source_text) -\u003e llvm::Optional\u003cNumericLiteralToken\u003e { NumericLiteralToken result; // 判断source_text是否为空以及第一个字符是否为数字 if (source_text.empty() || !IsDecimalDigit(source_text.front())) { return llvm::None; } bool seen_plus_minus = false; bool seen_radix_point = false; bool seen_potential_exponent = false; // 由于之前已经确认过首字符，这里索引从1开始 int i = 1; for (int n = source_text.size(); i != n; ++i) { char c = source_text[i]; if (IsAlnum(c) || c == '_') { // 只支持小写的 'e'，如果存在该字符且发现点号以及未探索 // 到加减号则记录exponent索引位置，否则继续下一轮循环 if (IsLower(c) \u0026\u0026 seen_radix_point \u0026\u0026 !seen_plus_minus) { result.exponent = i; seen_potential_exponent = true; } continue; } // 当前字符为 '.' 时，记录radix_point if (c == '.' \u0026\u0026 i + 1 != n \u0026\u0026 IsAlnum(source_text[i + 1]) \u0026\u0026 !seen_radix_point) { result.radix_point = i; seen_radix_point = true; continue; } // 当前字符为 '+' 或 '-' 时，记录seen_plus_minus if ((c == '+' || c == '-') \u0026\u0026 seen_potential_exponent \u0026\u0026 result.exponent == i - 1 \u0026\u0026 i + 1 != n \u0026\u0026 IsAlnum(source_text[i + 1])) { assert(!seen_plus_minus \u0026\u0026 \"should only consume one + or -\"); seen_plus_minus = true; continue; } break; } // 返回探索到的字符串，以当前i的值为索引切分子串 result.text = source_text.substr(0, i); // 记录 '.' 偏移 if (!seen_radix_point) { result.radix_point = i; } // 记录 'e' 或 'p' 偏移 if (!seen_potential_exponent) { result.exponent = i; } return result; } 以上代码中，source_text用于接受外部传入的数值字符串，该类型为llvm::StringRef类型（StringRef类型分析可参考chapter12_s1.2: LLVM ADT StringRef介绍及使用），首先判断source_text是否为空以及第一个字符是否为数字，如果不满足条件则返回llvm::None，llvm::None实际为一个枚举数值类型，返回值为llvm::Optional（Optional类型分析可参考chapter12_s1.3: LLVM ADT Optional介绍及使用）。\n接下来使用三个变量seen_plus_minus（是否探索到 + 或 - ）、seen_radix_point（是否探索到 . ）、seen_potential_exponent（是否探索到 e 或者 p ）用于后续词法解析的条件判断。\n在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。\n跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。\n数值字面量语法解析 在词法层面我们切分并完成了NumericLiteralToken对象的解析，接下来需要实现数值字面量的解析，实现这一步的目标是在语义上能对不同数值字面量提取更多的信息，其中包括数值字面量的合规性检查、提取数据等，将数值字面量解析拆分为了Tokenizer和Parser两部分，使得每部分过程更为明确和便于后期扩展。\n我们关注numeric_literal代码section2中的友元类Parser实现，将section1中NumericLiteralToken里两个函数GetRadixPoint和GetExponent的能力删除，将提取对应数据的能力移交至Parser，函数返回值改为llvm::APInt（参考阅读什么是APInt链接）。\n以下代码参考numeric_literal section2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class NumericLiteralToken::Parser { public: Parser(NumericLiteralToken literal); auto IsInteger() -\u003e bool { return literal.radix_point == static_cast\u003cint\u003e(literal.Text().size()); } auto GetRadix() const -\u003e int { return radix; } auto GetMantissa() -\u003e llvm::APInt; auto GetExponent() -\u003e llvm::APInt; private: NumericLiteralToken literal; // 存储对应字面量 // 基数默认为10，可以为 2 或 10 或 16 int radix = 10; // 词法结构：[radix] int_part [. fract_part [[ep] [+-] exponent_part]] llvm::StringRef int_part; // 整数部分 llvm::StringRef fract_part; // 小数部分 llvm::StringRef exponent_part; // 指数部分 // 对应数据是否需要清除`_`或`.`符号，默认为false bool mantissa_needs_cleaning = false; bool exponent_needs_cleaning = false; // 在`exponent`部分后面发现了`-`符号 bool exponent_is_negative = false; }; 具体看一下Parser的构造函数，构造时传入NumericLiteralToken对象，根据该对象里的radix_point数据进行int_part数据的切分，并对切分结果前两个字符做检查，根据0x或0b首字符判断进制，随即切分fract_part数据以及exponent_part数据，并判断是否在exponent部分后面发现了-符号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 NumericLiteralToken::Parser::Parser(NumericLiteralToken literal) : literal(literal) { int_part = literal.text.substr(0, literal.radix_point); if (int_part.consume_front(\"0x\")) { radix = 16; } else if (int_part.consume_front(\"0b\")) { radix = 2; } fract_part = literal.text.substr(literal.radix_point + 1, literal.exponent - literal.radix_point - 1); exponent_part = literal.text.substr(literal.exponent + 1); if (!exponent_part.consume_front(\"+\")) { exponent_is_negative = exponent_part.consume_front(\"-\"); } } Parser构造函数中构建好数据后，需要提供接口获取对应数据。\n其中包括四个函数接口：\n1 2 3 4 auto IsInteger() -\u003e bool; auto GetRadix() const -\u003e int; auto GetMantissa() -\u003e llvm::APInt; auto GetExponent() -\u003e llvm::APInt; IsInteger()用于判断是否为一个整数，判断方式为小数点位置是否在字符串末尾，字符串显示不存在小数点时，小数点默认在末尾。 GetRadix()用于获取进制。 GetMantissa()用于获取小数部分。 GetExponent()用于获取指数部分。 其中GetMantissa()和GetExponent()都调用了ParseInteger接口，ParseInteger完成获取具体数值的功能，以下为ParseInteger接口代码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static auto ParseInteger(llvm::StringRef digits, int radix, bool needs_cleaning) -\u003e llvm::APInt { llvm::SmallString\u003c32\u003e cleaned; // 预分配32个字节的字符串 if (needs_cleaning) { cleaned.reserve(digits.size()); // 根据目标大小重建长度 std::remove_copy_if(digits.begin(), digits.end(), std::back_inserter(cleaned), [](char c) { return c == '_' || c == '.'; }); digits = cleaned; } llvm::APInt value; if (digits.getAsInteger(radix, value)) { llvm_unreachable(\"should never fail\"); } return value; } 当解析包含小数点和下划线的字面量时，将忽视这两种字符，例如在解析 123.456e7 字面量时，我们期望获取到小数部分mantissa即(123456)和指数部分exponent(7-3=4)，根据这两个数我们能计算出真实的数据为：1234560000，其中GetMantissa函数如下：\n1 2 3 4 5 6 auto NumericLiteralToken::Parser::GetMantissa() -\u003e llvm::APInt { // 如果为整数从int_part为结尾，否则以fract_part为结尾 const char* end = IsInteger() ? int_part.end() : fract_part.end(); llvm::StringRef digits(int_part.begin(), end - int_part.begin()); return ParseInteger(digits, radix, mantissa_needs_cleaning); } 获取exponent的函数GetExponent如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 auto NumericLiteralToken::Parser::GetExponent() -\u003e llvm::APInt { llvm::APInt exponent(64, 0); // 创建64位值为0的exponent对象。 // 如果存在指数部分，就进入这个分支。 if (!exponent_part.empty()) { // 解析指数部分。这个函数会将字符串形式的指数转换为整数。其中， // 第一个参数是指数部分，第二个参数10是代表十进制，第三个参数 // 表示解析过程中是否需要进行清理。 exponent = ParseInteger(exponent_part, 10, exponent_needs_cleaning); // 检查指数的符号位是否被设置，或者指数的位宽是否小于64。 // 如果满足这些条件之一，就需要扩展指数的位宽。 if (exponent.isSignBitSet() || exponent.getBitWidth() \u003c 64) { // 扩展指数的位宽。新的位宽至少为64，如果原来的位宽+1大于64， // 那么就使用原来的位宽+1。扩展后，新增的位都被设置为0。 exponent = exponent.zext(std::max(64U, exponent.getBitWidth() + 1)); } // 如果指数是负数，就需要取反。 if (exponent_is_negative) { exponent.negate(); // 取反操作。 } } // 计算小数部分的字符数量，这个数量会影响实际的指数大小。 int excess_exponent = fract_part.size(); // 如果基数是16，即如果是十六进制的数，那么每一个小数部 // 分的字符都会减少4个指数（因为一个十六进制的字符等于4个二进制位）。 if (radix == 16) { excess_exponent *= 4; // 将小数部分的字符数量乘以4。 } exponent -= excess_exponent; // 从指数中减去小数部分的字符数量。 // 如果原来的指数是负数，但是计算后的指数变为非负，那么就进入这个分支。 if (exponent_is_negative \u0026\u0026 !exponent.isNegative()) { // 扩展指数的位宽，新增的位被设置为0。 exponent = exponent.zext(exponent.getBitWidth() + 1); // 设置指数的符号位，使得指数变为负数。 exponent.setSignBit(); } return exponent; } 从上面我们可以看到mantissa_needs_cleaning和exponent_needs_cleaning永远为false，原因是因为这两个标志位需要在获取数据之前对字面量做检查后进行设置，对传入不满足要求的字面量做预处理检查后才允许提取。\n关于字面量检查部分在下一章Chapter2: 诊断信息中进行说明与分析。\n2. 字符串字面量 // TODO: 1. 讲解字符串字面量代码。 // TODO: 2. 讲解字符串字面量设计。\n// TODO: 3. utf-8讲解。\n// TODO: 4. 单元测试讲解\n// TODO: 4.1 c++中的R字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 auto StringLiteral::Lex(llvm::StringRef source_text) -\u003e std::optional\u003cStringLiteral\u003e { int64_t cursor = 0; const int64_t source_text_size = source_text.size(); // 确定前缀中的#数量。 while (cursor \u003c source_text_size \u0026\u0026 source_text[cursor] == '#') { ++cursor; } const int hash_level = cursor; const std::optional\u003cIntroducer\u003e introducer = Introducer::Lex(source_text.substr(hash_level)); if (!introducer) { return std::nullopt; } cursor += introducer-\u003eprefix_size; const int prefix_len = cursor; // 初始化终结符和转义序列标记。 llvm::SmallString\u003c16\u003e terminator(introducer-\u003eterminator); llvm::SmallString\u003c16\u003e escape(\"\\\\\"); // 整终结符和转义序列的大小。 terminator.resize(terminator.size() + hash_level, '#'); escape.resize(escape.size() + hash_level, '#'); /// TODO: 在找到终结符之前检测多行字符串字面量的缩进/反缩进。 for (; cursor \u003c source_text_size; ++cursor) { // 快速跳过不感兴趣的字符。 static constexpr CharSet InterestingChars = {'\\\\', '\\n', '\"', '\\''}; if (!InterestingChars[source_text[cursor]]) { continue; } // 多字符的终结符和转义序列都以可预测的字符开始， // 并且不包含嵌入的、未转义的终结符或换行符。 switch (source_text[cursor]) { case '\\\\': // 处理转义字符。 if (escape.size() == 1 || source_text.substr(cursor + 1).startwith(escape.substr(1))) { cursor += escape.size(); // 单行字符串且转义字符是换行符。 if (cursor \u003e= source_text_size || (introducer-\u003ekind == NotMultiLine \u0026\u0026 source_text[cursor] == '\\n')) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u003ekind, /*is_terminated=*/false); } } break; case '\\n': // 单行字符串。 if (introducer-\u003ekind == NotMultiLine) { llvm::StringRef text = source_text.take_front(cursor); return StringLiteral(text, text.drop_front(prefix_len), hash_level, introducer-\u003ekind, /*is_terminated=*/false); } break; case '\"': case '\\'': if (source_text.substr(cursor).startswith(terminator)) { llvm::StringRef text = source_text.substr(0, cursor + terminator.size()); llvm::StringRef content = source_text.substr(prefix_len, cursor - prefix_len); return StringLiteral(text, content, hash_level, introducer-\u003ekind, /*is_terminated=*/true); } break; default: // 对于非终结符，不执行任何操作。 break; } } return StringLiteral(source_text, source_text.drop_front(prefix_len), hash_level, introducer-\u003ekind, /*is_terminated=*/false); } 首先，我们需要理解代码的逻辑以构建自动机。这段代码的主要目的是解析字符串字面量，特别是处理多行字符串、转义序列和终结符。\n基于代码的逻辑，我们可以构建以下自动机，以下是自动机图示：\n首先，我们需要理解自动机的基本概念。在计算机科学中，一个自动机是一个抽象的机器，它可以处于有限数量的不同状态之一，且在任何给定时刻只能处于其中一个状态。自动机根据输入序列中的符号进行状态转换。\n现在，让我们详细分析上述自动机的每个部分：\n开始状态 (Start): 这是解析字符串时的初始状态。在这个状态下，我们首先检查字符串的前缀是否包含#字符。\nHashCount: 在这个状态下，我们计算#的数量。这是为了确定多行字符串的终结符需要与开始的#数量匹配。\n多行状态 (MultiLine): 如果字符串以'''或\"\"\"开始，我们进入这个状态。在这个状态下，我们查找与开始匹配的终结符。终结符需要与开始的#数量匹配。\n常规状态 (Regular): 如果字符串以一个双引号\"开始，我们进入这个状态。在这个状态下，我们查找另一个双引号或转义序列。\n转义状态 (Escape): 当我们在常规状态下遇到反斜杠\\时，我们进入这个状态。这是因为反斜杠通常用于表示转义序列，例如\\\"表示一个双引号字符。在这个状态下，我们查找与转义序列匹配的字符。\n结束状态 (End): 当我们找到与开始匹配的终结符或达到字符串的末尾时，我们进入这个状态。这表示我们已经成功地解析了整个字符串。\n为什么这个自动机是这样设计的？\n这个自动机是基于Carbon语言中字符串字面量的词法规则设计的。这些规则定义了如何从源代码中解析字符串。特别是，这个自动机处理了以下几点：\n#字符的数量，这决定了多行字符串的终结符。 多行字符串和常规字符串的区别。 转义序列，这是在常规字符串中表示特殊字符的方法。 通过这个自动机，我们可以准确地解析Carbon语言中的字符串字面量，无论它们是多行的、常规的还是包含转义序列的。\n字符串解析例子：\n对于输入###'''hello world'''###：\n我们首先计算#的数量为3。 然后，我们确定这是一个多行字符串，并查找与'''###匹配的终结符。 我们成功地找到了终结符并结束了解析。 对于输入\"hello \\\\\" world\"：\n我们确定这是一个常规字符串。 我们继续解析，直到遇到反斜杠\\，然后进入转义状态。 在转义状态下，我们找到另一个反斜杠，并返回常规状态。 我们继续解析，直到找到终结符\"并结束解析。 这个自动机提供了一个高层次的视图，描述了如何解析字符串字面量。\nStringLiteral中静态函数的逐行分析 ComputeIndentOfFinalLine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。 static auto ComputeIndentOfFinalLine(llvm::StringRef text) -\u003e llvm::StringRef { int indent_end = text.size(); // 从文本的末尾开始，逐字符向前检查。 for (int i = indent_end - 1; i \u003e= 0; --i) { if (text[i] == '\\n') { // 如果遇到换行符\\n，则该位置之后的所有字符都是最后一行的缩进。 int indent_start = i + 1; return text.substr(indent_start, indent_end - indent_start); } if (!IsSpace(text[i])) { // 如果遇到非空格字符，则更新缩进的结束位置。 indent_end = i; } } // 如果没有找到换行符，这意味着给定的文本不包含换行符，这是一个错误情况。 llvm_unreachable(\"Given text is required to contain a newline.\"); } 这段代码定义了一个函数 ComputeIndentOfFinalLine，它的目的是计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。\n让我们逐步分析这段代码：\n函数签名:\n1 static auto ComputeIndentOfFinalLine(llvm::StringRef text) -\u003e llvm::StringRef 这个函数接受一个 llvm::StringRef 类型的参数 text，并返回一个 llvm::StringRef 类型的结果。llvm::StringRef 是一个轻量级的字符串引用，它不拥有其引用的字符串的内存，但提供了对该字符串的高效访问。\n初始化:\n1 int indent_end = text.size(); 初始化 indent_end 为文本的长度。这是因为我们将从文本的末尾开始向前搜索，以找到最后一个换行符。\n查找最后一个换行符:\n1 2 3 4 5 6 7 8 9 for (int i = indent_end - 1; i \u003e= 0; --i) { if (text[i] == '\\n') { int indent_start = i + 1; return text.substr(indent_start, indent_end - indent_start); } if (!IsSpace(text[i])) { indent_end = i; } } 这个循环从文本的末尾开始，向前搜索直到找到最后一个换行符或到达文本的开始。如果找到一个非空白字符，它会更新 indent_end 的值。当找到换行符时，函数会返回从该换行符之后到 indent_end 之间的子字符串，这就是最后一行的缩进。\n异常情况:\n1 llvm_unreachable(\"Given text is required to contain a newline.\"); 如果函数没有在文本中找到换行符，它会触发一个不可达的断言，表示这是一个异常情况。这意味着调用此函数的代码应确保提供的文本至少包含一个换行符。\n测试用例:\n基本用例:\n1 2 llvm::StringRef test1 = \"Hello\\n World\"; assert(ComputeIndentOfFinalLine(test1) == \" \"); 这个测试用例有两行，最后一行的缩进是两个空格。\n没有缩进的用例:\n1 2 llvm::StringRef test2 = \"Hello\\nWorld\"; assert(ComputeIndentOfFinalLine(test2) == \"\"); 这个测试用例的最后一行没有缩进。\n只有一个换行符的用例:\n1 2 llvm::StringRef test3 = \"\\n\"; assert(ComputeIndentOfFinalLine(test3) == \"\"); 这个测试用例只有一个换行符，所以最后一行没有缩进。\n异常用例:\n1 2 3 llvm::StringRef test4 = \"Hello World\"; // This should trigger the llvm_unreachable assertion ComputeIndentOfFinalLine(test4); 这个测试用例没有换行符，所以应该触发不可达的断言。\n注意：在实际使用中，你可能需要确保提供给 ComputeIndentOfFinalLine 的文本至少包含一个换行符，以避免触发异常。\nspec Carbon 支持使用一个双引号(\")的单行简单字面量和使用三个单引号(''')的多行块状字面量。块状字符串字面量在第一个'''后可能有一个文件类型指示器；这对字符串本身没有影响，但可能有助于其他工具。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 简单字符串字面量: var simple: String = \"example\"; // 块状字符串字面量: var block: String = ''' The winds grow high; so do your stomachs, lords. How irksome is this music to my heart! When such strings jar, what hope of harmony? I pray, my lords, let me compound this strife. -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare '''; // 块状字符串字面量带有文件类型指示器: var code_block: String = '''cpp #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello world!\"; return 0; } ''' 块状字符串字面量的终止行的缩进从所有前面的行中删除。因此，在上面的code_block示例中，只有std::cout和return在结果字符串中有缩进，每个都是4个空格。\n由反斜杠(\\)引入的转义序列用于表示特殊字符或代码单元序列，例如\\n表示换行符。原始字符串字面量还用一个或多个#进行分隔；这些在\\后需要相同数量的井号符号(#)来表示转义序列。原始字符串字面量用于更容易地在字符串中写入字面量\\。简单和块状字符串字面量都有原始形式。例如：\n1 2 3 4 5 6 7 8 // 带有换行转义序列的原始简单字符串字面量: var newline: String = \"line one\\nline two\"; // 带有字面量`\\n`的原始简单字符串字面量，不是换行: var raw: String = #\"line one\\nstill line one\"#; // 带有换行转义序列的原始简单字符串字面量: var raw_newline: String = #\"line one\\#nline two\"#; 详细信息 简单和块状字符串字面量 简单字符串字面量由以下序列组成：\n除\\和\"之外的字符。 在字符串字面量中，只有空格字符(U+0020)是有效的空白。 其他水平空白，包括制表符，是不允许的，但为了错误恢复目的被解析为字符串的一部分。 垂直空白不会被解析为简单字符串字面量的一部分。 转义序列。 每个转义序列都被替换为相应的字符序列或代码单元序列。 与无效的空白类似，无效的转义序列，如\\z，被解析为字符串的一部分。 这个序列被包含在\"中。例如，这是一个简单的字符串字面量：\n1 var String: lucius = \"The strings, my lord, are false.\"; 不允许相邻的字符串字面量，如下所示：\n1 2 // 三个相邻的简单字符串字面量`\"\"`、`\"abc\"`和`\"\"`是无效的。 var String: block = \"\"\"abc\"\"\"; 以三个双引号\"\"\"开始的字符串字面量是相邻的字符串字面量。拒绝并诊断它们是很重要的。\n块状字符串字面量以'''开始。'''后面的同一行上的字符是一个可选的文件类型指示器。字面量在下一个三个单引号的实例结束，其中第一个'不是\\'转义序列的一部分。关闭的'''应该是那一行的第一个非空白字符。开头行和结束行之间的行（不包括）是内容行。内容行不应包含不形成转义序列一部分的\\字符。\n块状字符串字面量的缩进是终止行前的水平空白序列。每个非空内容行都应该以字符串字面量的缩进开始。字面量的内容如下形成：\n从每个非空内容行中删除终止行的缩进。 每行的所有尾随空白，包括行终止符，都被替换为一个换行符(U+000A)。 结果行被连接起来。 每个转义序列都被替换为相应的字符序列或代码单元序列。 如果内容行只包含空白字符，则认为它是空的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 所有块状字符串字面量默认包含一个尾随换行符。 var String: newline_example = ''' This is a block string literal. Its first character is 'T' and its last character is a newline. It contains another newline character between 'is' and 'a'. '''; // 可以使用转义字符'\\'来抑制换行符 var String: suppressed_newlines = ''' This is another block string literal. The newline character here \\ is suppressed, along with the trailing newline here.\\ '''; // 这个块状字符串字面量是无效的，因为'closing'后面的'''终止了字面量，但它不在行的开头。 var String: invalid = ''' error: closing ''' is not on its own line. '''; 文件类型指示器是除'或#之外的任何非空白字符序列。文件类型指示器对 Carbon 编译器没有语义意义，但某些文件类型指示器被语言工具（例如，语法高亮器，代码格式化器）理解为指示字符串字面量内容的结构。\n1 2 3 4 5 // 这是一个块状字符串字面量。它的前两个字符是空格，它的最后一个字符是换行符。它有一个文件类型为'c++'。 var String: starts_with_whitespace = '''c++ int x = 1; // 这一行以两个空格开始。 int y = 2; // 这一行以两个空格开始。 '''; 文件类型指示器可能包含超出文件类型本身的语义信息，例如指示代码格式化器为代码块禁用格式化的指令。\n开放问题： 没有明确的已识别文件类型指示器集。非正式地指定一组众所周知的指示器将是有用的，这样工具就可以对这些指示器的含义有一个共同的理解，也许在最佳实践指南中。\n转义序列 在字符串字面量中，以下转义序列被识别：\n转义 含义 \\t U+0009 字符制表符 \\n U+000A 换行符 \\r U+000D 回车符 \\\" U+0022 引号 (\") \\' U+0027 逗号 (') \\\\ U+005C 反斜杠 (\\) \\0 值为0的代码单元 \\0D 无效，为未来的发展保留 \\xHH 值为HH16的代码单元 \\u{HHHH...} Unicode 代码点 U+HHHH… \\ 无字符串字面量内容产生 (仅限块状字面量) 十六进制字符(H)必须为大写(\\xAA，而不是\\xaa)。\n这包括所有C++转义序列，除了：\n\\?，它在字符串字面量中历史上用于转义三字符组，现在不再有任何用途。 \\ooo 八进制转义，因为Carbon不支持八进制字面量；\\0作为一个特殊情况被保留，这对于C互操作性预计是很重要的。 \\uABCD，被\\u{ABCD}替代。 \\U0010FFFF，被\\u{10FFFF}替代。 \\a (铃声)，\\b (退格)，\\v (垂直制表符)，和\\f (换页)。\\a和\\b已经过时，\\f和\\v基本上已经废弃。如果需要，这些字符可以分别用\\x07、\\x08、\\x0B和\\x0C表示。 注意，这是由Swift和Rust支持的相同的转义序列集，除了与Swift不同，它提供了对\\xHH的支持。\n尽管预计八进制转义序列将继续不被允许（尽管\\0D被保留），但决定不支持\\1..\\7或更一般地\\DDDD是_实验性的_。\n在上表中，H表示任意十六进制字符，0-9或A-F（区分大小写）。与C++不同，但与Python相似，\\x期望恰好两个十六进制数字。与JavaScript、Rust和Swift一样，可以使用\\u{10FFFF}表示法按数字表示Unicode代码点。这接受1到8个十六进制字符。可以用这种方式表示016-D7FF16或E00016-10FFFF16范围内的任何数字代码点。\n开放问题: 一些编程语言（尤其是Python）支持\\N{unicode character name}语法。我们可以添加这样的转义序列。未来考虑添加此类支持的提案应注意C++的Unicode研究小组在此领域的工作。\n转义序列\\0不应该后跟十进制数字。在应该在空字节后跟随十进制数字的情况下，可以使用\\x00代替：\"foo\\x00123\"。目的是保留将来允许十进制转义序列的可能性。\n反斜杠后跟换行符是一个不产生字符串内容的转\n义序列。这个转义序列是_实验性的_，只能出现在块状字符串字面量中。这个转义序列在替换尾随空白后处理为换行符之后进行处理，所以一个\\后跟水平空白后跟一个行终止符会移除直到并包括行终止符的空白。与Rust不同，但与Swift相似，换行符后的转义新行的前导空白不会被移除，除了与终止'''的缩进匹配的空白。\n以反斜杠开头的字符序列，如果不匹配任何已知的转义序列，则无效。除了空格和块状字符串字面量的新行（可选地前置回车）之外，其他空白字符是不允许的。所有其他字符（包括不可打印字符）都被原样保留。因为所有的Carbon源文件都要求是有效的Unicode字符序列，所以只能通过\\x转义序列产生不是有效的UTF-8的代码单元序列。\n决定在字符串字面量中不允许原始制表符是_实验性的_。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var String: fret = \"I would 'twere something that would fret the string,\\n\" + \"The master-cord on's \\u{2764}\\u{FE0F}!\"; // 这个字符串包含两个字符（在编码为UTF-8之前）： // U+1F3F9 (弓和箭) 后跟 U+0032 (数字二) var String: password = \"\\u{1F3F9}2\"; // 这个字符串不包含换行符。 var String: type_mismatch = ''' Shall I compare thee to a summer's day? Thou art \\ more lovely and more temperate.\\ '''; var String: trailing_whitespace = ''' This line ends in a space followed by a newline. \\n\\ This line starts with four spaces. '''; 原始字符串字面量 为了允许字符串的内容包括\\和\"，可以通过在开头的定界符前加上_N_个#字符来自定义字符串字面量的定界符。这样的字符串的关闭定界符只有在后面跟着_N_个#字符时才会被识别，同样地，这样的字符串字面量中的转义序列只有在\\后面也跟着_N_个#字符时才会被识别。一个\\、\"或'''后面没有跟着_N_个#字符没有特殊意义。\n开始定界符 转义序列引入符 结束定界符 \" / ''' \\ (例如, \\n) \" / ''' #\" / #''' \\# (例如, \\#n) \"# / '''# ##\" / ##''' \\## (例如, \\##n) \"## / '''## ###\" / ###''' \\### (例如, \\###n) \"### / '''### … … … 例如：\n1 2 3 4 5 6 7 8 9 var String: x = #''' 这是字符串的内容。'T'是字符串的第一个字符。 ''' \u003c-- 这不是字符串的结尾。 '''#; // 但前面的那行确实结束了字符串。 // OK, 最后一个字符是\\ var String: y = #\"Hello\\\"#; var String: z = ##\"Raw strings #\"nesting\"#\"##; var String: w = #\"Tab is expressed as \\t. Example: '\\#t'\"#; 编码 字符串字面量产生一个8位字节的序列。像Carbon源文件一样，字符串字面量使用UTF-8编码。然而，不能保证字符串是有效的UTF-8，因为可以通过\\xHH转义序列插入任意字节序列。\n这是_实验性的_，如果我们发现直接表示其他编码的字符串字面量的足够动机，应该重新考虑。同样，随着库对字符串类型的支持的发展，我们应该考虑包括字符串字面量语法（也许作为默认值），保证字符串内容是有效的UTF-8编码，这样在类型系统中可以区分有效的UTF-8和任意字符串。在这样的字符串字面量中，我们应该考虑拒绝HH大于7F16的\\xHH转义，如Rust中所做的那样。\n引用 [1] : Floating-point numeric types - C# reference | Microsoft Learn [2] : numeric_literals | MDN Web [3] : json-tutorial | miloyip [4] : numeric_literals | Carbon [5] : proposals 0143 | Carbon [6] : proposals 1983 | Carbon ","wordCount":"10234","inLanguage":"en","datePublished":"2023-09-21T14:51:58+08:00","dateModified":"2023-09-21T14:51:58+08:00","author":[{"@type":"Person","name":"CanftIn"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://canftin.github.io/posts/tech/p2_compiler_build_1_lexer/"},"publisher":{"@type":"Organization","name":"CanftIn's Blog","logo":{"@type":"ImageObject","url":"https://canftin.github.io/img/text_icon.ico"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://canftin.github.io/ accesskey=h title="CanftIn's Blog (Alt + H)">CanftIn's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://canftin.github.io/search title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://canftin.github.io/ title=主页><span>主页</span></a></li><li><a href=https://canftin.github.io/posts title=文章><span>文章</span></a></li><li><a href=https://canftin.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://canftin.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://canftin.github.io/about title=关于><span>关于</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://canftin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://canftin.github.io/posts/>所有文章</a>&nbsp;»&nbsp;<a href=https://canftin.github.io/posts/tech/>技术</a></div><h1 class=post-title>从零构造现代语言编译器(1): 词法分析</h1><div class=post-meta><span title='2023-09-21 14:51:58 +0800 CST'>2023-09-21</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;CanftIn<span style=opacity:.8>
<span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;</span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e5%80%bc%e5%ad%97%e9%9d%a2%e9%87%8f aria-label="1. 什么是数值字面量">1. 什么是数值字面量</a></li><li><a href=#carbon%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b%e4%bb%8b%e7%bb%8d aria-label=Carbon数值类型介绍>Carbon数值类型介绍</a></li><li><a href=#%e6%95%b0%e5%80%bc%e5%ad%97%e9%9d%a2%e9%87%8f%e8%af%8d%e6%b3%95%e8%a7%a3%e6%9e%90 aria-label=数值字面量词法解析：>数值字面量词法解析：</a></li><li><a href=#%e6%95%b0%e5%80%bc%e5%ad%97%e9%9d%a2%e9%87%8f%e8%af%ad%e6%b3%95%e8%a7%a3%e6%9e%90 aria-label=数值字面量语法解析>数值字面量语法解析</a></li><li><a href=#2-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e9%87%8f aria-label="2. 字符串字面量">2. 字符串字面量</a><ul><li><a href=#stringliteral%e4%b8%ad%e9%9d%99%e6%80%81%e5%87%bd%e6%95%b0%e7%9a%84%e9%80%90%e8%a1%8c%e5%88%86%e6%9e%90 aria-label=StringLiteral中静态函数的逐行分析>StringLiteral中静态函数的逐行分析</a></li><li><a href=#spec aria-label=spec>spec</a><ul><li><a href=#%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af aria-label=详细信息>详细信息</a><ul><li><a href=#%e7%ae%80%e5%8d%95%e5%92%8c%e5%9d%97%e7%8a%b6%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e9%87%8f aria-label=简单和块状字符串字面量>简单和块状字符串字面量</a></li><li><a href=#%e8%bd%ac%e4%b9%89%e5%ba%8f%e5%88%97 aria-label=转义序列>转义序列</a></li></ul></li><li><a href=#%e5%8e%9f%e5%a7%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e9%87%8f aria-label=原始字符串字面量>原始字符串字面量</a></li><li><a href=#%e7%bc%96%e7%a0%81 aria-label=编码>编码</a></li></ul></li></ul></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-什么是数值字面量>1. 什么是数值字面量<a hidden class=anchor aria-hidden=true href=#1-什么是数值字面量>#</a></h2><p>数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 <code>123</code>、<code>3.14</code>、<code>0xFF</code>、<code>1.23e-4</code> 都可以被视为数值字面量。</p><p>字面量的类型通常根据其格式和位置决定。例如在大多数编程语言<sup>[<a href=#references-anchor>1</a>]</sup><sup>[<a href=#references-anchor>2</a>]</sup><sup>[<a href=#references-anchor>3</a>]</sup>中，带有小数点的数字将被视为浮点数（如 <code>3.14</code> ），而没有小数点的数字将被视为整数（如 <code>123</code> ）。</p><p>更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。</p><p>本章将从数值字面量的解析入手，开始进入编译器构造的世界。</p><h2 id=carbon数值类型介绍>Carbon数值类型介绍<a hidden class=anchor aria-hidden=true href=#carbon数值类型介绍>#</a></h2><p>Carbon中数值类型<sup>[<a href=#references-anchor>4</a>]</sup><sup>[<a href=#references-anchor>5</a>]</sup>有如下几种：</p><ul><li><p>整数类型</p><p>整数根据进制分为如下类型：十进制（例如 <code>12345</code> ）、十六进制（例如 <code>0x1FE</code> ）、二进制（例如 <code>0b1010</code> ）等</p></li><li><p>实数类型</p><p>实数类型总是包含 <code>.</code> 符号，实数类型例如基础类型 <code>123.456</code> 以及科学技术法表示 <code>123.456e789</code>、<code>0x1.2p123</code> 等，其中科学技术法表示中的字符 <code>e</code> 及 <code>p</code> 在Carbon中称为指数（对应代码中<code>exponent</code> 字符，实际在幂运算中应为底数），对于一个十进制值 <em>N</em> 来说，<code>e</code> 相当于10<sup>±<em>N</em></sup>，而 <code>p</code> 相当于2<sup>±<em>N</em></sup>。</p><p>且实数类型字面量 <code>exponent</code> 字符后可跟随 <code>+</code> 或 <code>-</code> 字符，例如 <code>12.34e+56</code> 或 <code>56.34e-12</code>。</p></li><li><p>数字分隔符<sup>[<a href=#references-anchor>6</a>]</sup></p><p>数字分隔符由下划线 <code>_</code> 表示，例如十进制数: <code>1_23_456_7890</code>、十六进制数: <code>0x7_F_FF_FFFF</code>、实数: <code>2_147.48_3648e12_345</code> 或 <code>0x1_00CA.FE_F00Dp+2_4</code>、二进制数: <code>0b1_000_101_11</code> 等。</p></li></ul><h2 id=数值字面量词法解析>数值字面量词法解析：<a hidden class=anchor aria-hidden=true href=#数值字面量词法解析>#</a></h2><p>首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 <code>_</code> 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 <code>exponent</code> 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供<code>NumericLiteralToken</code>类的抽象，需要存储的数据有：字符数据（<code>text</code>）、小数点字符位置（<code>radix_point</code>）、指数幂字符位置（<code>exponent</code>）。</p><p>以下代码参考<a href=/code/numeric_literal/section1>numeric_literal section1</a></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumericLiteralToken</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> Text() <span style=color:#66d9ef>const</span> <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>StringRef { <span style=color:#66d9ef>return</span> text; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>Lex</span>(llvm<span style=color:#f92672>::</span>StringRef source_text)
</span></span><span style=display:flex><span>      <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>Optional<span style=color:#f92672>&lt;</span>NumericLiteralToken<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetRadixPoint</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> { <span style=color:#66d9ef>return</span> radix_point; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetExponent</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> { <span style=color:#66d9ef>return</span> exponent; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  NumericLiteralToken() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>StringRef text;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// &#39;.&#39;字符的偏移量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> radix_point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// &#39;e&#39;或&#39;p&#39;字符的偏移量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> exponent;
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>其中我们重点关注Lex接口的实现：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>auto</span> NumericLiteralToken<span style=color:#f92672>::</span>Lex(llvm<span style=color:#f92672>::</span>StringRef source_text)
</span></span><span style=display:flex><span>    <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>Optional<span style=color:#f92672>&lt;</span>NumericLiteralToken<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  NumericLiteralToken result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 判断source_text是否为空以及第一个字符是否为数字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (source_text.empty() <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>IsDecimalDigit(source_text.front())) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> llvm<span style=color:#f92672>::</span>None;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> seen_plus_minus <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> seen_radix_point <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> seen_potential_exponent <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 由于之前已经确认过首字符，这里索引从1开始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> source_text.size(); i <span style=color:#f92672>!=</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> source_text[i];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (IsAlnum(c) <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;_&#39;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 只支持小写的 &#39;e&#39;，如果存在该字符且发现点号以及未探索
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 到加减号则记录exponent索引位置，否则继续下一轮循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (IsLower(c) <span style=color:#f92672>&amp;&amp;</span> seen_radix_point <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>seen_plus_minus) {
</span></span><span style=display:flex><span>        result.exponent <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        seen_potential_exponent <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当前字符为 &#39;.&#39; 时，记录radix_point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> n <span style=color:#f92672>&amp;&amp;</span> IsAlnum(source_text[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>seen_radix_point) {
</span></span><span style=display:flex><span>      result.radix_point <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>      seen_radix_point <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当前字符为 &#39;+&#39; 或 &#39;-&#39; 时，记录seen_plus_minus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;+&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;-&#39;</span>) <span style=color:#f92672>&amp;&amp;</span> seen_potential_exponent <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        result.exponent <span style=color:#f92672>==</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> n <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        IsAlnum(source_text[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])) {
</span></span><span style=display:flex><span>      assert(<span style=color:#f92672>!</span>seen_plus_minus <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;should only consume one + or -&#34;</span>);
</span></span><span style=display:flex><span>      seen_plus_minus <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 返回探索到的字符串，以当前i的值为索引切分子串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  result.text <span style=color:#f92672>=</span> source_text.substr(<span style=color:#ae81ff>0</span>, i);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 记录 &#39;.&#39; 偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>seen_radix_point) {
</span></span><span style=display:flex><span>    result.radix_point <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 记录 &#39;e&#39; 或 &#39;p&#39; 偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>seen_potential_exponent) {
</span></span><span style=display:flex><span>    result.exponent <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>以上代码中，<code>source_text</code>用于接受外部传入的数值字符串，该类型为<code>llvm::StringRef</code>类型（StringRef类型分析可参考<a href=/blog/chapter12/llvm/section1.2_LLVM_ADT_StringRef%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8.md>chapter12_s1.2: LLVM ADT StringRef介绍及使用</a>），首先判断<code>source_text</code>是否为空以及第一个字符是否为数字，如果不满足条件则返回<code>llvm::None</code>，<code>llvm::None</code>实际为一个枚举数值类型，返回值为<code>llvm::Optional</code>（Optional类型分析可参考<a href=/blog/chapter12/llvm/section1.3_LLVM_ADT_Optional%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8.md>chapter12_s1.3: LLVM ADT Optional介绍及使用</a>）。</p><p>接下来使用三个变量<code>seen_plus_minus</code>（是否探索到 <code>+</code> 或 <code>-</code> ）、<code>seen_radix_point</code>（是否探索到 <code>.</code> ）、<code>seen_potential_exponent</code>（是否探索到 <code>e</code> 或者 <code>p</code> ）用于后续词法解析的条件判断。</p><p>在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。</p><p>跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。</p><h2 id=数值字面量语法解析>数值字面量语法解析<a hidden class=anchor aria-hidden=true href=#数值字面量语法解析>#</a></h2><p>在词法层面我们切分并完成了NumericLiteralToken对象的解析，接下来需要实现数值字面量的解析，实现这一步的目标是在语义上能对不同数值字面量提取更多的信息，其中包括数值字面量的合规性检查、提取数据等，将数值字面量解析拆分为了Tokenizer和Parser两部分，使得每部分过程更为明确和便于后期扩展。</p><p>我们关注numeric_literal代码section2中的友元类Parser实现，将section1中NumericLiteralToken里两个函数<code>GetRadixPoint</code>和<code>GetExponent</code>的能力删除，将提取对应数据的能力移交至Parser，函数返回值改为<code>llvm::APInt</code>（参考阅读<a href=/blog/chapter12/llvm/section1.1_LLVM_ADT_APInt%E4%BB%8B%E7%BB%8D.md>什么是APInt</a>链接）。</p><p>以下代码参考<a href=/code/numeric_literal/section2>numeric_literal section2</a></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumericLiteralToken</span><span style=color:#f92672>::</span>Parser {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  Parser(NumericLiteralToken literal);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>IsInteger</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> literal.radix_point <span style=color:#f92672>==</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(literal.Text().size());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetRadix</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span> { <span style=color:#66d9ef>return</span> radix; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetMantissa</span>() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetExponent</span>() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  NumericLiteralToken literal; <span style=color:#75715e>// 存储对应字面量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 基数默认为10，可以为 2 或 10 或 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> radix <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 词法结构：[radix] int_part [. fract_part [[ep] [+-] exponent_part]]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  llvm<span style=color:#f92672>::</span>StringRef int_part; <span style=color:#75715e>// 整数部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  llvm<span style=color:#f92672>::</span>StringRef fract_part; <span style=color:#75715e>// 小数部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  llvm<span style=color:#f92672>::</span>StringRef exponent_part; <span style=color:#75715e>// 指数部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 对应数据是否需要清除`_`或`.`符号，默认为false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> mantissa_needs_cleaning <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> exponent_needs_cleaning <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在`exponent`部分后面发现了`-`符号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> exponent_is_negative <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>具体看一下<code>Parser</code>的构造函数，构造时传入<code>NumericLiteralToken</code>对象，根据该对象里的<code>radix_point</code>数据进行<code>int_part</code>数据的切分，并对切分结果前两个字符做检查，根据<code>0x</code>或<code>0b</code>首字符判断进制，随即切分<code>fract_part</code>数据以及<code>exponent_part</code>数据，并判断是否在<code>exponent</code>部分后面发现了<code>-</code>符号。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>NumericLiteralToken<span style=color:#f92672>::</span>Parser<span style=color:#f92672>::</span>Parser(NumericLiteralToken literal)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> literal(literal) {
</span></span><span style=display:flex><span>  int_part <span style=color:#f92672>=</span> literal.text.substr(<span style=color:#ae81ff>0</span>, literal.radix_point);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (int_part.consume_front(<span style=color:#e6db74>&#34;0x&#34;</span>)) {
</span></span><span style=display:flex><span>    radix <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (int_part.consume_front(<span style=color:#e6db74>&#34;0b&#34;</span>)) {
</span></span><span style=display:flex><span>    radix <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fract_part <span style=color:#f92672>=</span> literal.text.substr(literal.radix_point <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                                   literal.exponent <span style=color:#f92672>-</span> literal.radix_point <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  exponent_part <span style=color:#f92672>=</span> literal.text.substr(literal.exponent <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>exponent_part.consume_front(<span style=color:#e6db74>&#34;+&#34;</span>)) {
</span></span><span style=display:flex><span>    exponent_is_negative <span style=color:#f92672>=</span> exponent_part.consume_front(<span style=color:#e6db74>&#34;-&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Parser构造函数中构建好数据后，需要提供接口获取对应数据。</p><p>其中包括四个函数接口：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>IsInteger</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetRadix</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetMantissa</span>() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>GetExponent</span>() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt;
</span></span></code></pre></td></tr></table></div></div><ul><li><code>IsInteger()</code>用于判断是否为一个整数，判断方式为小数点位置是否在字符串末尾，字符串显示不存在小数点时，小数点默认在末尾。</li><li><code>GetRadix()</code>用于获取进制。</li><li><code>GetMantissa()</code>用于获取小数部分。</li><li><code>GetExponent()</code>用于获取指数部分。</li></ul><p>其中<code>GetMantissa()</code>和<code>GetExponent()</code>都调用了<code>ParseInteger</code>接口，<code>ParseInteger</code>完成获取具体数值的功能，以下为<code>ParseInteger</code>接口代码分析：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>ParseInteger</span>(llvm<span style=color:#f92672>::</span>StringRef digits, <span style=color:#66d9ef>int</span> radix, <span style=color:#66d9ef>bool</span> needs_cleaning)
</span></span><span style=display:flex><span>    <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt {
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>SmallString<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span><span style=color:#f92672>&gt;</span> cleaned; <span style=color:#75715e>// 预分配32个字节的字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (needs_cleaning) {
</span></span><span style=display:flex><span>    cleaned.reserve(digits.size()); <span style=color:#75715e>// 根据目标大小重建长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>remove_copy_if(digits.begin(), digits.end(),
</span></span><span style=display:flex><span>                        std<span style=color:#f92672>::</span>back_inserter(cleaned),
</span></span><span style=display:flex><span>                        [](<span style=color:#66d9ef>char</span> c) { <span style=color:#66d9ef>return</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;_&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>; });
</span></span><span style=display:flex><span>    digits <span style=color:#f92672>=</span> cleaned;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>APInt value;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (digits.getAsInteger(radix, value)) {
</span></span><span style=display:flex><span>    llvm_unreachable(<span style=color:#e6db74>&#34;should never fail&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>当解析包含小数点和下划线的字面量时，将忽视这两种字符，例如在解析 <code>123.456e7</code> 字面量时，我们期望获取到小数部分mantissa即(123456)和指数部分exponent(7-3=4)，根据这两个数我们能计算出真实的数据为：<code>1234560000</code>，其中<code>GetMantissa</code>函数如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>auto</span> NumericLiteralToken<span style=color:#f92672>::</span>Parser<span style=color:#f92672>::</span>GetMantissa() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果为整数从int_part为结尾，否则以fract_part为结尾
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> end <span style=color:#f92672>=</span> IsInteger() <span style=color:#f92672>?</span> int_part.end() <span style=color:#f92672>:</span> fract_part.end();
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>StringRef digits(int_part.begin(), end <span style=color:#f92672>-</span> int_part.begin());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ParseInteger</span>(digits, radix, mantissa_needs_cleaning);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>获取exponent的函数<code>GetExponent</code>如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>auto</span> NumericLiteralToken<span style=color:#f92672>::</span>Parser<span style=color:#f92672>::</span>GetExponent() <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>APInt {
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>APInt exponent(<span style=color:#ae81ff>64</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 创建64位值为0的exponent对象。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 如果存在指数部分，就进入这个分支。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>exponent_part.empty()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解析指数部分。这个函数会将字符串形式的指数转换为整数。其中，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 第一个参数是指数部分，第二个参数10是代表十进制，第三个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 表示解析过程中是否需要进行清理。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exponent <span style=color:#f92672>=</span> ParseInteger(exponent_part, <span style=color:#ae81ff>10</span>, exponent_needs_cleaning);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查指数的符号位是否被设置，或者指数的位宽是否小于64。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 如果满足这些条件之一，就需要扩展指数的位宽。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (exponent.isSignBitSet() <span style=color:#f92672>||</span> exponent.getBitWidth() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>64</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 扩展指数的位宽。新的位宽至少为64，如果原来的位宽+1大于64，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 那么就使用原来的位宽+1。扩展后，新增的位都被设置为0。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      exponent <span style=color:#f92672>=</span> exponent.zext(std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>64U</span>, exponent.getBitWidth() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果指数是负数，就需要取反。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (exponent_is_negative) {
</span></span><span style=display:flex><span>      exponent.negate(); <span style=color:#75715e>// 取反操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 计算小数部分的字符数量，这个数量会影响实际的指数大小。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> excess_exponent <span style=color:#f92672>=</span> fract_part.size();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果基数是16，即如果是十六进制的数，那么每一个小数部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 分的字符都会减少4个指数（因为一个十六进制的字符等于4个二进制位）。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (radix <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>) {
</span></span><span style=display:flex><span>    excess_exponent <span style=color:#f92672>*=</span> <span style=color:#ae81ff>4</span>; <span style=color:#75715e>// 将小数部分的字符数量乘以4。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  exponent <span style=color:#f92672>-=</span> excess_exponent; <span style=color:#75715e>// 从指数中减去小数部分的字符数量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 如果原来的指数是负数，但是计算后的指数变为非负，那么就进入这个分支。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (exponent_is_negative <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>exponent.isNegative()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 扩展指数的位宽，新增的位被设置为0。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exponent <span style=color:#f92672>=</span> exponent.zext(exponent.getBitWidth() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置指数的符号位，使得指数变为负数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exponent.setSignBit();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> exponent;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>从上面我们可以看到<code>mantissa_needs_cleaning</code>和<code>exponent_needs_cleaning</code>永远为false，原因是因为这两个标志位需要在获取数据之前对字面量做检查后进行设置，对传入不满足要求的字面量做预处理检查后才允许提取。</p><p>关于字面量检查部分在下一章<a href=/blog/chapter2/diagnostic/%E8%AF%8A%E6%96%AD%E4%BF%A1%E6%81%AF.md>Chapter2: 诊断信息</a>中进行说明与分析。</p><h2 id=2-字符串字面量>2. 字符串字面量<a hidden class=anchor aria-hidden=true href=#2-字符串字面量>#</a></h2><font color=red>// TODO: 1. 讲解字符串字面量代码。<p>// TODO: 2. 讲解字符串字面量设计。</p><p>// TODO: 3. utf-8讲解。</p><p>// TODO: 4. 单元测试讲解</p><p>// TODO: 4.1 c++中的R字符串</font></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> StringLiteral<span style=color:#f92672>::</span>Lex(llvm<span style=color:#f92672>::</span>StringRef source_text)
</span></span><span style=display:flex><span>    <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span>StringLiteral<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int64_t</span> cursor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int64_t</span> source_text_size <span style=color:#f92672>=</span> source_text.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 确定前缀中的#数量。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (cursor <span style=color:#f92672>&lt;</span> source_text_size <span style=color:#f92672>&amp;&amp;</span> source_text[cursor] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>++</span>cursor;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> hash_level <span style=color:#f92672>=</span> cursor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>optional<span style=color:#f92672>&lt;</span>Introducer<span style=color:#f92672>&gt;</span> introducer <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      Introducer<span style=color:#f92672>::</span>Lex(source_text.substr(hash_level));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>introducer) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>nullopt;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cursor <span style=color:#f92672>+=</span> introducer<span style=color:#f92672>-&gt;</span>prefix_size;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> prefix_len <span style=color:#f92672>=</span> cursor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化终结符和转义序列标记。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  llvm<span style=color:#f92672>::</span>SmallString<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>16</span><span style=color:#f92672>&gt;</span> terminator(introducer<span style=color:#f92672>-&gt;</span>terminator);
</span></span><span style=display:flex><span>  llvm<span style=color:#f92672>::</span>SmallString<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>16</span><span style=color:#f92672>&gt;</span> escape(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 整终结符和转义序列的大小。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  terminator.resize(terminator.size() <span style=color:#f92672>+</span> hash_level, <span style=color:#e6db74>&#39;#&#39;</span>);
</span></span><span style=display:flex><span>  escape.resize(escape.size() <span style=color:#f92672>+</span> hash_level, <span style=color:#e6db74>&#39;#&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// TODO: 在找到终结符之前检测多行字符串字面量的缩进/反缩进。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (; cursor <span style=color:#f92672>&lt;</span> source_text_size; <span style=color:#f92672>++</span>cursor) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 快速跳过不感兴趣的字符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> CharSet InterestingChars <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;\\&#39;</span>, <span style=color:#e6db74>&#39;\n&#39;</span>, <span style=color:#e6db74>&#39;&#34;&#39;</span>, <span style=color:#e6db74>&#39;\&#39;&#39;</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>InterestingChars[source_text[cursor]]) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 多字符的终结符和转义序列都以可预测的字符开始，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 并且不包含嵌入的、未转义的终结符或换行符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>switch</span> (source_text[cursor]) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;\\&#39;</span><span style=color:#f92672>:</span>  <span style=color:#75715e>// 处理转义字符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (escape.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            source_text.substr(cursor <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>).startwith(escape.substr(<span style=color:#ae81ff>1</span>))) {
</span></span><span style=display:flex><span>          cursor <span style=color:#f92672>+=</span> escape.size();
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 单行字符串且转义字符是换行符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#66d9ef>if</span> (cursor <span style=color:#f92672>&gt;=</span> source_text_size <span style=color:#f92672>||</span> (introducer<span style=color:#f92672>-&gt;</span>kind <span style=color:#f92672>==</span> NotMultiLine <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                                             source_text[cursor] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>)) {
</span></span><span style=display:flex><span>            llvm<span style=color:#f92672>::</span>StringRef text <span style=color:#f92672>=</span> source_text.take_front(cursor);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>StringLiteral</span>(text, text.drop_front(prefix_len), hash_level,
</span></span><span style=display:flex><span>                                 introducer<span style=color:#f92672>-&gt;</span>kind,
</span></span><span style=display:flex><span>                                 <span style=color:#75715e>/*is_terminated=*/</span>false);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;\n&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 单行字符串。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (introducer<span style=color:#f92672>-&gt;</span>kind <span style=color:#f92672>==</span> NotMultiLine) {
</span></span><span style=display:flex><span>          llvm<span style=color:#f92672>::</span>StringRef text <span style=color:#f92672>=</span> source_text.take_front(cursor);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>StringLiteral</span>(text, text.drop_front(prefix_len), hash_level,
</span></span><span style=display:flex><span>                               introducer<span style=color:#f92672>-&gt;</span>kind,
</span></span><span style=display:flex><span>                               <span style=color:#75715e>/*is_terminated=*/</span>false);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;&#34;&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;\&#39;&#39;</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (source_text.substr(cursor).startswith(terminator)) {
</span></span><span style=display:flex><span>          llvm<span style=color:#f92672>::</span>StringRef text <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              source_text.substr(<span style=color:#ae81ff>0</span>, cursor <span style=color:#f92672>+</span> terminator.size());
</span></span><span style=display:flex><span>          llvm<span style=color:#f92672>::</span>StringRef content <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>              source_text.substr(prefix_len, cursor <span style=color:#f92672>-</span> prefix_len);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>StringLiteral</span>(text, content, hash_level, introducer<span style=color:#f92672>-&gt;</span>kind,
</span></span><span style=display:flex><span>                               <span style=color:#75715e>/*is_terminated=*/</span>true);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于非终结符，不执行任何操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>StringLiteral</span>(source_text, source_text.drop_front(prefix_len),
</span></span><span style=display:flex><span>                       hash_level, introducer<span style=color:#f92672>-&gt;</span>kind,
</span></span><span style=display:flex><span>                       <span style=color:#75715e>/*is_terminated=*/</span>false);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>首先，我们需要理解代码的逻辑以构建自动机。这段代码的主要目的是解析字符串字面量，特别是处理多行字符串、转义序列和终结符。</p><p>基于代码的逻辑，我们可以构建以下自动机，以下是自动机图示：</p><p><img loading=lazy src=/img/post_pic/p2_string_literal_automaton.png alt=p2_string_literal_automaton></p><p>首先，我们需要理解自动机的基本概念。在计算机科学中，一个自动机是一个抽象的机器，它可以处于有限数量的不同状态之一，且在任何给定时刻只能处于其中一个状态。自动机根据输入序列中的符号进行状态转换。</p><p>现在，让我们详细分析上述自动机的每个部分：</p><ol><li><p><strong>开始状态 (Start)</strong>: 这是解析字符串时的初始状态。在这个状态下，我们首先检查字符串的前缀是否包含<code>#</code>字符。</p></li><li><p><strong>HashCount</strong>: 在这个状态下，我们计算<code>#</code>的数量。这是为了确定多行字符串的终结符需要与开始的<code>#</code>数量匹配。</p></li><li><p><strong>多行状态 (MultiLine)</strong>: 如果字符串以<code>'''</code>或<code>"""</code>开始，我们进入这个状态。在这个状态下，我们查找与开始匹配的终结符。终结符需要与开始的<code>#</code>数量匹配。</p></li><li><p><strong>常规状态 (Regular)</strong>: 如果字符串以一个双引号<code>"</code>开始，我们进入这个状态。在这个状态下，我们查找另一个双引号或转义序列。</p></li><li><p><strong>转义状态 (Escape)</strong>: 当我们在常规状态下遇到反斜杠<code>\</code>时，我们进入这个状态。这是因为反斜杠通常用于表示转义序列，例如<code>\"</code>表示一个双引号字符。在这个状态下，我们查找与转义序列匹配的字符。</p></li><li><p><strong>结束状态 (End)</strong>: 当我们找到与开始匹配的终结符或达到字符串的末尾时，我们进入这个状态。这表示我们已经成功地解析了整个字符串。</p></li></ol><p><strong>为什么这个自动机是这样设计的？</strong></p><p>这个自动机是基于Carbon语言中字符串字面量的词法规则设计的。这些规则定义了如何从源代码中解析字符串。特别是，这个自动机处理了以下几点：</p><ul><li><code>#</code>字符的数量，这决定了多行字符串的终结符。</li><li>多行字符串和常规字符串的区别。</li><li>转义序列，这是在常规字符串中表示特殊字符的方法。</li></ul><p>通过这个自动机，我们可以准确地解析Carbon语言中的字符串字面量，无论它们是多行的、常规的还是包含转义序列的。</p><p><strong>字符串解析例子</strong>：</p><ol><li><p>对于输入<code>###'''hello world'''###</code>：</p><ul><li>我们首先计算<code>#</code>的数量为3。</li><li>然后，我们确定这是一个多行字符串，并查找与<code>'''###</code>匹配的终结符。</li><li>我们成功地找到了终结符并结束了解析。</li></ul></li><li><p>对于输入<code>"hello \\" world"</code>：</p><ul><li>我们确定这是一个常规字符串。</li><li>我们继续解析，直到遇到反斜杠<code>\</code>，然后进入转义状态。</li><li>在转义状态下，我们找到另一个反斜杠，并返回常规状态。</li><li>我们继续解析，直到找到终结符<code>"</code>并结束解析。</li></ul></li></ol><p>这个自动机提供了一个高层次的视图，描述了如何解析字符串字面量。</p><h3 id=stringliteral中静态函数的逐行分析>StringLiteral中静态函数的逐行分析<a hidden class=anchor aria-hidden=true href=#stringliteral中静态函数的逐行分析>#</a></h3><ol><li>ComputeIndentOfFinalLine</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>ComputeIndentOfFinalLine</span>(llvm<span style=color:#f92672>::</span>StringRef text) <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>StringRef {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> indent_end <span style=color:#f92672>=</span> text.size(); <span style=color:#75715e>// 从文本的末尾开始，逐字符向前检查。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> indent_end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (text[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>) { <span style=color:#75715e>// 如果遇到换行符\n，则该位置之后的所有字符都是最后一行的缩进。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> indent_start <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> text.substr(indent_start, indent_end <span style=color:#f92672>-</span> indent_start);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>IsSpace(text[i])) { <span style=color:#75715e>// 如果遇到非空格字符，则更新缩进的结束位置。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      indent_end <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果没有找到换行符，这意味着给定的文本不包含换行符，这是一个错误情况。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  llvm_unreachable(<span style=color:#e6db74>&#34;Given text is required to contain a newline.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>这段代码定义了一个函数 <code>ComputeIndentOfFinalLine</code>，它的目的是计算给定文本中最后一行的缩进（即最后一行前面的水平空白字符序列）。</p><p>让我们逐步分析这段代码：</p><ol><li><p><strong>函数签名</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>auto</span> ComputeIndentOfFinalLine(llvm<span style=color:#f92672>::</span>StringRef text) <span style=color:#f92672>-&gt;</span> llvm<span style=color:#f92672>::</span>StringRef
</span></span></code></pre></td></tr></table></div></div><p>这个函数接受一个 <code>llvm::StringRef</code> 类型的参数 <code>text</code>，并返回一个 <code>llvm::StringRef</code> 类型的结果。<code>llvm::StringRef</code> 是一个轻量级的字符串引用，它不拥有其引用的字符串的内存，但提供了对该字符串的高效访问。</p></li><li><p><strong>初始化</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> indent_end <span style=color:#f92672>=</span> text.size();
</span></span></code></pre></td></tr></table></div></div><p>初始化 <code>indent_end</code> 为文本的长度。这是因为我们将从文本的末尾开始向前搜索，以找到最后一个换行符。</p></li><li><p><strong>查找最后一个换行符</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> indent_end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (text[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> indent_start <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> text.substr(indent_start, indent_end <span style=color:#f92672>-</span> indent_start);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>IsSpace(text[i])) {
</span></span><span style=display:flex><span>        indent_end <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>这个循环从文本的末尾开始，向前搜索直到找到最后一个换行符或到达文本的开始。如果找到一个非空白字符，它会更新 <code>indent_end</code> 的值。当找到换行符时，函数会返回从该换行符之后到 <code>indent_end</code> 之间的子字符串，这就是最后一行的缩进。</p></li><li><p><strong>异常情况</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>llvm_unreachable(<span style=color:#e6db74>&#34;Given text is required to contain a newline.&#34;</span>);
</span></span></code></pre></td></tr></table></div></div><p>如果函数没有在文本中找到换行符，它会触发一个不可达的断言，表示这是一个异常情况。这意味着调用此函数的代码应确保提供的文本至少包含一个换行符。</p></li></ol><p><strong>测试用例</strong>:</p><ol><li><p><strong>基本用例</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>llvm<span style=color:#f92672>::</span>StringRef test1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>  World&#34;</span>;
</span></span><span style=display:flex><span>assert(ComputeIndentOfFinalLine(test1) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;  &#34;</span>);
</span></span></code></pre></td></tr></table></div></div><p>这个测试用例有两行，最后一行的缩进是两个空格。</p></li><li><p><strong>没有缩进的用例</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>llvm<span style=color:#f92672>::</span>StringRef test2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>World&#34;</span>;
</span></span><span style=display:flex><span>assert(ComputeIndentOfFinalLine(test2) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span></code></pre></td></tr></table></div></div><p>这个测试用例的最后一行没有缩进。</p></li><li><p><strong>只有一个换行符的用例</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>llvm<span style=color:#f92672>::</span>StringRef test3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>assert(ComputeIndentOfFinalLine(test3) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span></code></pre></td></tr></table></div></div><p>这个测试用例只有一个换行符，所以最后一行没有缩进。</p></li><li><p><strong>异常用例</strong>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>llvm<span style=color:#f92672>::</span>StringRef test4 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// This should trigger the llvm_unreachable assertion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ComputeIndentOfFinalLine(test4);
</span></span></code></pre></td></tr></table></div></div><p>这个测试用例没有换行符，所以应该触发不可达的断言。</p></li></ol><p>注意：在实际使用中，你可能需要确保提供给 <code>ComputeIndentOfFinalLine</code> 的文本至少包含一个换行符，以避免触发异常。</p><h3 id=spec>spec<a hidden class=anchor aria-hidden=true href=#spec>#</a></h3><p>Carbon 支持使用一个双引号(<code>"</code>)的单行简单字面量和使用三个单引号(<code>'''</code>)的多行块状字面量。块状字符串字面量在第一个<code>'''</code>后可能有一个文件类型指示器；这对字符串本身没有影响，但可能有助于其他工具。例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 简单字符串字面量:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var simple: String <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;example&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 块状字符串字面量:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var block: String <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>    The winds grow high; so <span style=color:#66d9ef>do</span> your stomachs, lords.
</span></span><span style=display:flex><span>    How irksome is this music to my heart<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>    When such strings jar, what hope of harmony<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>    I pray, my lords, <span style=color:#66d9ef>let</span> me compound this strife.
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span> History of Henry <span style=color:#66d9ef>VI</span>, Part <span style=color:#66d9ef>II</span>, Act <span style=color:#66d9ef>II</span>, Scene <span style=color:#ae81ff>1</span>, W. Shakespeare
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 块状字符串字面量带有文件类型指示器:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var code_block: String <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>cpp
</span></span><span style=display:flex><span>    #include <span style=color:#f92672>&lt;</span>iostream<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    int main() {
</span></span><span style=display:flex><span>        std::cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello world!&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>块状字符串字面量的终止行的缩进从所有前面的行中删除。因此，在上面的<code>code_block</code>示例中，只有<code>std::cout</code>和<code>return</code>在结果字符串中有缩进，每个都是4个空格。</p><p>由反斜杠(<code>\</code>)引入的转义序列用于表示特殊字符或代码单元序列，例如<code>\n</code>表示换行符。原始字符串字面量还用一个或多个<code>#</code>进行分隔；这些在<code>\</code>后需要相同数量的井号符号(<code>#</code>)来表示转义序列。原始字符串字面量用于更容易地在字符串中写入字面量<code>\</code>。简单和块状字符串字面量都有原始形式。例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 带有换行转义序列的原始简单字符串字面量:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var newline: String <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;line one</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>line two&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 带有字面量`\n`的原始简单字符串字面量，不是换行:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var raw: String <span style=color:#f92672>=</span> #<span style=color:#e6db74>&#34;line one</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>still line one&#34;</span>#;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 带有换行转义序列的原始简单字符串字面量:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var raw_newline: String <span style=color:#f92672>=</span> #<span style=color:#e6db74>&#34;line one\#nline two&#34;</span>#;
</span></span></code></pre></td></tr></table></div></div><h4 id=详细信息>详细信息<a hidden class=anchor aria-hidden=true href=#详细信息>#</a></h4><h5 id=简单和块状字符串字面量>简单和块状字符串字面量<a hidden class=anchor aria-hidden=true href=#简单和块状字符串字面量>#</a></h5><p>简单字符串字面量由以下序列组成：</p><ul><li>除<code>\</code>和<code>"</code>之外的字符。<ul><li>在字符串字面量中，只有空格字符(U+0020)是有效的空白。</li><li>其他<a href=whitespace.md>水平空白</a>，包括制表符，是不允许的，但为了错误恢复目的被解析为字符串的一部分。</li><li>垂直空白不会被解析为简单字符串字面量的一部分。</li></ul></li><li><a href=#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97>转义序列</a>。<ul><li>每个转义序列都被替换为相应的字符序列或代码单元序列。</li><li>与无效的空白类似，无效的转义序列，如<code>\z</code>，被解析为字符串的一部分。</li></ul></li></ul><p>这个序列被包含在<code>"</code>中。例如，这是一个简单的字符串字面量：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>var String: <span style=color:#a6e22e>lucius</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;The strings, my lord, are false.&#34;</span>;
</span></span></code></pre></td></tr></table></div></div><p>不允许相邻的字符串字面量，如下所示：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 三个相邻的简单字符串字面量`&#34;&#34;`、`&#34;abc&#34;`和`&#34;&#34;`是无效的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>block</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;abc&#34;&#34;&#34;</span>;
</span></span></code></pre></td></tr></table></div></div><p>以三个双引号<code>"""</code>开始的字符串字面量是相邻的字符串字面量。拒绝并诊断它们是很重要的。</p><p>块状字符串字面量以<code>'''</code>开始。<code>'''</code>后面的同一行上的字符是一个可选的文件类型指示器。字面量在下一个三个单引号的实例结束，其中第一个<code>'</code>不是<code>\'</code>转义序列的一部分。关闭的<code>'''</code>应该是那一行的第一个非空白字符。开头行和结束行之间的行（不包括）是内容行。内容行不应包含不形成转义序列一部分的<code>\</code>字符。</p><p>块状字符串字面量的缩进是终止行前的水平空白序列。每个非空内容行都应该以字符串字面量的缩进开始。字面量的内容如下形成：</p><ul><li>从每个非空内容行中删除终止行的缩进。</li><li>每行的所有尾随空白，包括行终止符，都被替换为一个换行符(U+000A)。</li><li>结果行被连接起来。</li><li>每个<a href=#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97>转义序列</a>都被替换为相应的字符序列或代码单元序列。</li></ul><p>如果内容行只包含空白字符，则认为它是空的。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 所有块状字符串字面量默认包含一个尾随换行符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>newline_example</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  This is a block string literal. Its first character is <span style=color:#e6db74>&#39;T&#39;</span> and its last character is
</span></span><span style=display:flex><span>  a newline. It contains another newline character between <span style=color:#a6e22e>&#39;is&#39;</span> and <span style=color:#e6db74>&#39;a&#39;</span>.
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 可以使用转义字符&#39;\&#39;来抑制换行符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>suppressed_newlines</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  This is another block string literal. The newline character here <span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  is suppressed, along with the trailing newline here.<span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这个块状字符串字面量是无效的，因为&#39;closing&#39;后面的&#39;&#39;&#39;终止了字面量，但它不在行的开头。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>invalid</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  error: <span style=color:#a6e22e>closing</span> <span style=color:#e6db74>&#39;&#39;&#39;</span> is not on its own line.
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span></code></pre></td></tr></table></div></div><p>文件类型指示器是除<code>'</code>或<code>#</code>之外的任何非空白字符序列。文件类型指示器对 Carbon 编译器没有语义意义，但某些文件类型指示器被语言工具（例如，语法高亮器，代码格式化器）理解为指示字符串字面量内容的结构。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 这是一个块状字符串字面量。它的前两个字符是空格，它的最后一个字符是换行符。它有一个文件类型为&#39;c++&#39;。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>starts_with_whitespace</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>c<span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    int x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 这一行以两个空格开始。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    int y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// 这一行以两个空格开始。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span></code></pre></td></tr></table></div></div><p>文件类型指示器可能包含超出文件类型本身的语义信息，例如指示代码格式化器为代码块禁用格式化的指令。</p><p><strong>开放问题：</strong> 没有明确的已识别文件类型指示器集。非正式地指定一组众所周知的指示器将是有用的，这样工具就可以对这些指示器的含义有一个共同的理解，也许在最佳实践指南中。</p><h5 id=转义序列>转义序列<a hidden class=anchor aria-hidden=true href=#转义序列>#</a></h5><p>在字符串字面量中，以下转义序列被识别：</p><table><thead><tr><th>转义</th><th>含义</th></tr></thead><tbody><tr><td><code>\t</code></td><td>U+0009 字符制表符</td></tr><tr><td><code>\n</code></td><td>U+000A 换行符</td></tr><tr><td><code>\r</code></td><td>U+000D 回车符</td></tr><tr><td><code>\"</code></td><td>U+0022 引号 (<code>"</code>)</td></tr><tr><td><code>\'</code></td><td>U+0027 逗号 (<code>'</code>)</td></tr><tr><td><code>\\</code></td><td>U+005C 反斜杠 (<code>\</code>)</td></tr><tr><td><code>\0</code></td><td>值为0的代码单元</td></tr><tr><td><code>\0D</code></td><td>无效，为未来的发展保留</td></tr><tr><td><code>\xHH</code></td><td>值为HH<sub>16</sub>的代码单元</td></tr><tr><td><code>\u{HHHH...}</code></td><td>Unicode 代码点 U+HHHH&mldr;</td></tr><tr><td><code>\&lt;newline></code></td><td>无字符串字面量内容产生 (仅限块状字面量)</td></tr></tbody></table><p>十六进制字符(<code>H</code>)必须为大写(<code>\xAA</code>，而不是<code>\xaa</code>)。</p><p>这包括所有C++转义序列，除了：</p><ul><li><code>\?</code>，它在字符串字面量中历史上用于转义三字符组，现在不再有任何用途。</li><li><code>\ooo</code> 八进制转义，因为Carbon不支持八进制字面量；<code>\0</code>作为一个特殊情况被保留，这对于C互操作性预计是很重要的。</li><li><code>\uABCD</code>，被<code>\u{ABCD}</code>替代。</li><li><code>\U0010FFFF</code>，被<code>\u{10FFFF}</code>替代。</li><li><code>\a</code> (铃声)，<code>\b</code> (退格)，<code>\v</code> (垂直制表符)，和<code>\f</code> (换页)。<code>\a</code>和<code>\b</code>已经过时，<code>\f</code>和<code>\v</code>基本上已经废弃。如果需要，这些字符可以分别用<code>\x07</code>、<code>\x08</code>、<code>\x0B</code>和<code>\x0C</code>表示。</li></ul><p>注意，这是由<a href=https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID295>Swift</a>和<a href=https://doc.rust-lang.org/reference/tokens.html>Rust</a>支持的相同的转义序列集，除了与Swift不同，它提供了对<code>\xHH</code>的支持。</p><p>尽管预计八进制转义序列将继续不被允许（尽管<code>\0D</code>被保留），但决定不支持<code>\1</code>..<code>\7</code>或更一般地<code>\DDDD</code>是_实验性的_。</p><p>在上表中，<code>H</code>表示任意十六进制字符，<code>0</code>-<code>9</code>或<code>A</code>-<code>F</code>（区分大小写）。与C++不同，但与Python相似，<code>\x</code>期望恰好两个十六进制数字。与JavaScript、Rust和Swift一样，可以使用<code>\u{10FFFF}</code>表示法按数字表示Unicode代码点。这接受1到8个十六进制字符。可以用这种方式表示0<sub>16</sub>-D7FF<sub>16</sub>或E000<sub>16</sub>-10FFFF<sub>16</sub>范围内的任何数字代码点。</p><p><em>开放问题:</em> 一些编程语言（尤其是Python）支持<code>\N{unicode character name}</code>语法。我们可以添加这样的转义序列。未来考虑添加此类支持的提案应注意C++的Unicode研究小组在此领域的工作。</p><p>转义序列<code>\0</code>不应该后跟十进制数字。在应该在空字节后跟随十进制数字的情况下，可以使用<code>\x00</code>代替：<code>"foo\x00123"</code>。目的是保留将来允许十进制转义序列的可能性。</p><p>反斜杠后跟换行符是一个不产生字符串内容的转</p><p>义序列。这个转义序列是_实验性的_，只能出现在块状字符串字面量中。这个转义序列在替换尾随空白后处理为换行符之后进行处理，所以一个<code>\</code>后跟水平空白后跟一个行终止符会移除直到并包括行终止符的空白。与Rust不同，但与Swift相似，换行符后的转义新行的前导空白不会被移除，除了与终止<code>'''</code>的缩进匹配的空白。</p><p>以反斜杠开头的字符序列，如果不匹配任何已知的转义序列，则无效。除了空格和块状字符串字面量的新行（可选地前置回车）之外，其他空白字符是不允许的。所有其他字符（包括不可打印字符）都被原样保留。因为所有的Carbon源文件都要求是有效的Unicode字符序列，所以只能通过<code>\x</code>转义序列产生不是有效的UTF-8的代码单元序列。</p><p>决定在字符串字面量中不允许原始制表符是_实验性的_。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>var String: <span style=color:#a6e22e>fret</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;I would &#39;twere something that would fret the string,</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#34;The master-cord on&#39;s </span><span style=color:#ae81ff>\u{2764}\u{FE0F}</span><span style=color:#e6db74>!&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这个字符串包含两个字符（在编码为UTF-8之前）：
</span></span></span><span style=display:flex><span><span style=color:#75715e>// U+1F3F9 (弓和箭) 后跟 U+0032 (数字二)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>password</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\u{1F3F9}</span><span style=color:#e6db74>2&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这个字符串不包含换行符。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>type_mismatch</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  Shall I compare thee to a summer<span style=color:#a6e22e>&#39;s</span> day<span style=color:#f92672>?</span> Thou art <span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  more lovely and more temperate.<span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var String: <span style=color:#a6e22e>trailing_whitespace</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  This line ends <span style=color:#66d9ef>in</span> a space followed by a newline. <span style=color:#960050;background-color:#1e0010>\</span>n<span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>      This line starts with four spaces.
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>;
</span></span></code></pre></td></tr></table></div></div><h4 id=原始字符串字面量>原始字符串字面量<a hidden class=anchor aria-hidden=true href=#原始字符串字面量>#</a></h4><p>为了允许字符串的内容包括<code>\</code>和<code>"</code>，可以通过在开头的定界符前加上_N_个<code>#</code>字符来自定义字符串字面量的定界符。这样的字符串的关闭定界符只有在后面跟着_N_个<code>#</code>字符时才会被识别，同样地，这样的字符串字面量中的转义序列只有在<code>\</code>后面也跟着_N_个<code>#</code>字符时才会被识别。一个<code>\</code>、<code>"</code>或<code>'''</code>后面没有跟着_N_个<code>#</code>字符没有特殊意义。</p><table><thead><tr><th>开始定界符</th><th>转义序列引入符</th><th>结束定界符</th></tr></thead><tbody><tr><td><code>"</code> / <code>'''</code></td><td><code>\</code> (例如, <code>\n</code>)</td><td><code>"</code> / <code>'''</code></td></tr><tr><td><code>#"</code> / <code>#'''</code></td><td><code>\#</code> (例如, <code>\#n</code>)</td><td><code>"#</code> / <code>'''#</code></td></tr><tr><td><code>##"</code> / <code>##'''</code></td><td><code>\##</code> (例如, <code>\##n</code>)</td><td><code>"##</code> / <code>'''##</code></td></tr><tr><td><code>###"</code> / <code>###'''</code></td><td><code>\###</code> (例如, <code>\###n</code>)</td><td><code>"###</code> / <code>'''###</code></td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p>例如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>var String: <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> #<span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>这是字符串的内容。</span><span style=color:#e6db74>&#39;T&#39;</span><span style=color:#960050;background-color:#1e0010>是字符串的第一个字符。</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span> <span style=color:#f92672>&lt;--</span> <span style=color:#960050;background-color:#1e0010>这不是字符串的结尾。</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;&#39;&#39;</span>#;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 但前面的那行确实结束了字符串。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// OK, 最后一个字符是\
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>var String: <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> #<span style=color:#e6db74>&#34;Hello</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>#;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var String: z = ##&#34;</span>Raw strings #<span style=color:#e6db74>&#34;nesting&#34;</span>#<span style=color:#e6db74>&#34;##;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>var String: w = #&#34;</span>Tab is expressed <span style=color:#66d9ef>as</span> <span style=color:#960050;background-color:#1e0010>\</span>t. Example: <span style=color:#a6e22e>&#39;</span><span style=color:#960050;background-color:#1e0010>\</span>#t<span style=color:#a6e22e>&#39;</span><span style=color:#e6db74>&#34;#;
</span></span></span></code></pre></td></tr></table></div></div><h4 id=编码>编码<a hidden class=anchor aria-hidden=true href=#编码>#</a></h4><p>字符串字面量产生一个8位字节的序列。像Carbon源文件一样，字符串字面量使用UTF-8编码。然而，不能保证字符串是有效的UTF-8，因为可以通过<code>\xHH</code>转义序列插入任意字节序列。</p><p>这是_实验性的_，如果我们发现直接表示其他编码的字符串字面量的足够动机，应该重新考虑。同样，随着库对字符串类型的支持的发展，我们应该考虑包括字符串字面量语法（也许作为默认值），保证字符串内容是有效的UTF-8编码，这样在类型系统中可以区分有效的UTF-8和任意字符串。在这样的字符串字面量中，我们应该考虑拒绝HH大于7F<sub>16</sub>的<code>\xHH</code>转义，如Rust中所做的那样。</p><div id=references-anchor></div><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><ul><li>[1] : <a href=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types>Floating-point numeric types - C# reference | Microsoft Learn</a></li><li>[2] : <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#numeric_literals>numeric_literals | MDN Web</a></li><li>[3] : <a href=https://github.com/miloyip/json-tutorial/blob/master/tutorial02/tutorial02.md>json-tutorial | miloyip</a></li><li>[4] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/lexical_conventions/numeric_literals.md>numeric_literals | Carbon</a></li><li>[5] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0143.md>proposals 0143 | Carbon</a></li><li>[6] : <a href=https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p1983.md>proposals 1983 | Carbon</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://canftin.github.io/posts/tech/p3_compiler_build_2_common_lib/><span class=title>« Prev</span><br><span>从零构造现代语言编译器(2): 公共库</span></a>
<a class=next href=https://canftin.github.io/posts/tech/p1_compiler_build_0_start/><span class=title>Next »</span><br><span>从零构造现代语言编译器(0): C++后继语言</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
2016-2023
<a href=https://github.com/canftin style=color:#939393>CanftIn</a>
, 许可协议：<a class=link href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-ND 4.0</a>,</span>
<span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span></span></a>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function n(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)})})</script></body></html>