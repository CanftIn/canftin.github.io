<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>Free Monads in C++</title>
	<meta name="description" content="A blog by CanftIn">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/assets/css/code.css">
	
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/feeds.xml">
	<!-- PUBLIC RESOURCE BEGIN -->
	<!-- <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> -->
	<link href="https://fonts.googleapis.com/css?family=Merriweather|Montserrat" rel="stylesheet"> 
	<!-- PUBLIC RESOURCE END -->
	<link rel="shortcut icon" href="../favicon.png">
	<link rel="author" href="https://github.com/CanftIn">
	<meta name="twitter:site" content="CanftIn">
	<!-- <\!--/*404 THINGS*/[if lt IE 9]> -->
	<!-- <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script> -->
	<!-- <!/**/[endif]-\-> -->
	<!-- <\!--[if lt IE 9]-\-> -->
	<!-- <script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"></script> -->
	<!-- <\!--[endif]-\-> -->
	<meta property="og:title" content="CanftIn.com">
	<meta property="og:type" content="website">
	<meta property="og:url" content="">
	<meta property="og:site_name" content="CanftIn.com">
	<meta property="og:description" content="A blog by CanftIn">
	<script>
	(adsbygoogle = window.adsbygoogle || []).push({
		google_ad_client: "ca-pub-4120677882232967",
		enable_page_level_ads: true
	});
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110017464-1"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());gtag('config', 'UA-110017464-1');
</script>


	<link rel="canonical" href="http://localhost:4000/2020/04-07-free-monads-in-cpp.html">
</head>

<body>
<header id="top">
	<nav>
		<ul>
			<!-- <li><a href="https://github.com/CanftIn"> -->
			<!-- 	<img src="/assets/svg/mark-github.svg" /><span>GitHub</span></a></li> -->
			<li><a href="/pages/about.html">
				<img src="/assets/svg/mention.svg"/><span>About</span></a></li>
			<!-- <li><a href="/lagda/"> -->
			<!-- 	<img src="/assets/svg/law.svg"/><span>LAgda</span></a></li> -->
			<!-- <li><a href="/gists/"> -->
			<!-- 	<img src="/assets/svg/file-code.svg"/><span>Gists</span></a></li> -->
			<!-- <li><a href="/languages/"> -->
			<!-- 	<img src="/assets/svg/terminal.svg"/><span>Langs</span></a></li> -->
			<!-- <li><a href="/projects/"> -->
			<!-- 	<img src="/assets/svg/repo.svg"/><span>Projects</span></a></li> -->
			<!-- <li><a href="/pages/cn.html"> -->
        <!-- <img src="/assets/svg/tag.svg"/><span>Chinese</span></a></li> -->
			<li><a href="/JDK/index.html">
				<img src="/assets/svg/java.svg"/><span>JDKAnalysis</span></a></li>
			<li><a href="/CharacterMap/index.html">
				<img src="/assets/svg/font.svg"/><span>CharacterMap</span></a></li>
			<li><a href="/">
				<img src="/assets/svg/home.svg"/><span>Home</span></a></li>
		</ul>
	</nav>
</header>

<div style="border-bottom: 1px solid #000"></div>

<section class="container" itemscope itemtype="http://schema.org/Blog">
	<h1 class="big" itemprop="name">Free Monads in C++</h1>
	<p class="date">
		<span itemprop="datePublished" content="2020-04-07 00:00:00 +0800">2020, Apr 7</span>
		by <span itemprop="author">CanftIn</span>
	</p>
	<article itemprop="articleBody">
		<p>I present a way to use modern C++ metaprogramming techniques to represent
Functors and Monads in a way that is analogous to the way it is done in Haskell.
I show how a generic free monad can be written such that any Functor has a
corresponding free monad.</p>

<p>Practical applications of this technique are left as an exercise for the reader.</p>

<h2 id="introduction">Introduction</h2>

<p>Haskell’s powerful type system and syntactic sugar for composing monadic values
allow for some impressive abstraction. Inspired by a <a href="https://github.com/chrisbarrett/free-monads-talk">talk</a> given by Chris
Barrett at the <a href="https://www.meetup.com/Functional-Programming-Auckland/">Functional Programming Auckland</a> meetup on 2016-09-13, in
which he presented the use of a Free Monad in the construction of a
domain-specific language embedded in Haskell, I decided to see if the type
system of C++ could be used to allow a similar abstraction to be built.</p>

<p>The bulk of this article is taken directly from the source files in the
accompanying <a href="https://github.com/toby-allsopp/free-monads-in-cpp">library</a>.</p>

<h2 id="implementation">Implementation</h2>

<blockquote>
  <p>Functor.h</p>
</blockquote>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="cp">#include &lt;utility&gt;
</span></code></pre></div></div>

<h3 id="functors">Functors</h3>

<p>A “Functor” is something very precise in category theory, but you can think of
it as something that somehow contains values with some structure and allows
you to transform the contained values in a way that preserves the structure.</p>

<p>In Haskell, it is defined like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>This just says that a type <em>f</em> is a Functor if it supports the <code class="highlighter-rouge">fmap</code>
function, which takes:</p>

<ul>
  <li>a function that operates on each value of type <em>a</em> contained in the Functor,
returning a value of type <em>b</em> and</li>
  <li>a value of type <em>f a</em>, being a particular value of our Functor containing
values of type <em>a</em></li>
</ul>

<p>and produces a value of type <em>f b</em>, being a particular value o four Functor
containing values of type <em>b</em>.</p>

<p>In C++, we will define a Functor as any class template with a single type
parameter for which a valid specialization of the <code class="highlighter-rouge">Functor</code> class template
exists.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Functor</span> <span class="p">{</span>
</code></pre></div></div>

<p>The default specialization of <code class="highlighter-rouge">Functor</code> is undefined; this will cause a
compile-time error (or substitution failure when used in certain template
contexts) if it is used.</p>

<p>The first template parameter is the class template to be considered a
Functor. The second template parameter is there to enable partial
specializations to use SFINAE-based techniques.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span><span class="p">;</span>
</code></pre></div></div>

<p>It is very useful to have a concise way to query, at compile-time, whether a
given class template has a valid <code class="highlighter-rouge">Functor</code> specialization. This is a perfect
application of “Concepts” but as we wish to remain compatible with C++14
compilers we have to do it the old-fashioned way, i.e. using partial
template specialization and SFINAE.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
</code></pre></div></div>

<p>Note that MS Visual C++ doesn’t properly support expression SFINAE as of
VS2015 update 3, so we just assume everything is a Functor there.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef _MSC_VER
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">IsFunctorT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">;</span>
<span class="cp">#else
</span></code></pre></div></div>

<p>In the usual C++ template metaprogramming fashion, we define a class
template with the default case and then use partial specialization to
change it for specific cases. Another common idiom is the use of an extra,
defaulted template parameter that partial specializations can use to
SFINAE themselves away.</p>

<p>The default case is that any given class template is not a Functor.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span><span class="err">,</span> <span class="nc">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">IsFunctorT</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>
</code></pre></div></div>

<p>Then we essentially say that any class template <code class="highlighter-rouge">T</code> is a Functor if a call to
<code class="highlighter-rouge">Functor&lt;T&gt;::fmap</code> compiles and has the correct result type.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">dummy1</span> <span class="p">{};</span>
    <span class="k">struct</span> <span class="n">dummy2</span> <span class="p">{};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">IsFunctorT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span>
                          <span class="n">T</span><span class="o">&lt;</span><span class="n">dummy2</span><span class="o">&gt;</span><span class="p">,</span>
                          <span class="k">decltype</span><span class="p">(</span><span class="n">Functor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">fmap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">dummy2</span><span class="p">(</span><span class="n">dummy1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(),</span>
                                                    <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&lt;</span><span class="n">dummy1</span><span class="o">&gt;&gt;</span><span class="p">()))</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
        <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
<span class="cp">#endif
</span>  <span class="err">}</span>
</code></pre></div></div>

<p>Using the <code class="highlighter-rouge">IsFunctorT</code> class template is little bit inconvenient, so we hide
it away in the <code class="highlighter-rouge">detail</code> namespace and instead expose a <code class="highlighter-rouge">constexpr</code> variable
template. An example of the use of this is coming up in the definition of <code class="highlighter-rouge">fmap</code>,
below.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">IsFunctor</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">IsFunctorT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</code></pre></div></div>

<p>To make using the <code class="highlighter-rouge">fmap</code> function on a Functor value more convenient, we
define a free function that wraps it. Using this allows the Functor template
argument to be deduced.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">A</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">Fun</span><span class="p">,</span>
            <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">IsFunctor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;&gt;</span>
  <span class="n">F</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">fmap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">),</span> <span class="n">f</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>It is useful for testing purposes to have a very basic Functor—we call
this <code class="highlighter-rouge">NullFunctor</code>. It contains exactly zero values, each of the requisite
type.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">NullFunctor</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">IsFunctor</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">"NullFunctor must be a Functor"</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<blockquote>
  <p>Monad.h</p>
</blockquote>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="cp">#include "Functor.h"
#include "void_t.h"
</span></code></pre></div></div>

<h3 id="monads">Monads</h3>

<p>The concept of a Monad comes from category theory, but the defintion I’m using
is that of its practical application in Haskell.</p>

<p>In Haskell, <code class="highlighter-rouge">Monad</code> is a typeclass, defined something like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">bind</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>There are some additional laws that Monads are supposed to obey but for now I’m
just going to focus on the type signatures.</p>

<p>In C++, we can treat the type variable <code class="highlighter-rouge">m</code> as a class template with a class
template template parameter and define a class template <code class="highlighter-rouge">Monad</code> that we will
specialize for each class template <code class="highlighter-rouge">M</code> that we want to treat as a Monad.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Monad</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Enable</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Monad</span><span class="p">;</span>
</code></pre></div></div>

<p>C++ doesn’t provide a neat way to define the members that we expect
specializations of the <code class="highlighter-rouge">Monad</code> template to have, but we can write a type-level
predicate that uses SFINAE to check.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Enable</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">IsMonadT</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>
</code></pre></div></div>

<p>At the moment we just have a very basic check—is there a specialization
of Monad for the template and is the template a Functor.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">IsMonadT</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span> <span class="n">void_t</span><span class="o">&lt;</span><span class="n">Monad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">::</span><span class="n">IsFunctor</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;&gt;&gt;</span>
        <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
  <span class="err">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">IsMonad</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">IsMonadT</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</code></pre></div></div>

<p>Now that we can tell (approximately) whether a class template is a Monad, we
can define the Monad operations as free functions so that the template
arguments can be deduced in at least some cases.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// pure :: (Monad m) =&gt; a -&gt; m a</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">A</span><span class="p">,</span>
            <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;&gt;</span>
  <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pure</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Monad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">pure</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// bind :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">A</span><span class="p">,</span>
            <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">bind</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Monad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">bind</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>It is common in Haskell to use the infix (»=) operator as a synonym for
<em>bind</em>; this reduces the need for parentheses. We can do the same thing in
C++, allowing us to write <code class="highlighter-rouge">m &gt;&gt;= [](){}</code> instead of <code class="highlighter-rouge">bind(m, [](){})</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">A</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">F</span><span class="p">,</span>
          <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">Monad</span><span class="o">::</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">&gt;&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Monad</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The (») operator is also commonly used in Haskell. It just throws away the
result of evaluating the first argument and returns the second argument
instead.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">A</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">B</span><span class="p">,</span>
          <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">Monad</span><span class="o">::</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;&gt;</span>
<span class="n">M</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Monad</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>List.h</p>
</blockquote>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="cp">#include "Functor.h"
#include "Monad.h"
</span>
<span class="cp">#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;ostream&gt;
#include &lt;vector&gt;
</span></code></pre></div></div>

<h2 id="the-list-monad">The List Monad</h2>

<p>We introduce a special kind of vector that we call List. We could use vector
directly but this allows us to avoid making every vector a Monad.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">List</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">vector</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>It is useful to be able to print out Lists for testing and debugging.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span><span class="p">;</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"]"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="making-list-a-functor">Making List a Functor</h3>

<p>First, we need to make <code class="highlighter-rouge">List</code> a Functor by partially specializing <code class="highlighter-rouge">Functor</code> and
defining <code class="highlighter-rouge">fmap</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Functor</span> <span class="p">{</span>
  <span class="c1">// instance Functor List where</span>
  <span class="k">template</span> <span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// fmap :: (a -&gt; b) -&gt; List a -&gt; List b</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Fun</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">fmap</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span>
          <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">IsFunctor</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">"List should be a Functor"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="making-list-a-monad">Making List a Monad</h3>

<p>Then we can make <code class="highlighter-rouge">List</code> a Monad by partially specializing <code class="highlighter-rouge">Monad</code> and defining
<code class="highlighter-rouge">pure</code> and <code class="highlighter-rouge">bind</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Monad</span> <span class="p">{</span>
  <span class="c1">// instance Monad List where</span>
  <span class="k">template</span> <span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="n">Monad</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// pure :: a -&gt; List a</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pure</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">({</span><span class="n">x</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// bind :: List a -&gt; (a -&gt; List b) -&gt; List b</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ListB</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;&gt;</span>
    <span class="k">static</span> <span class="n">ListB</span> <span class="n">bind</span><span class="p">(</span><span class="k">const</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ListB</span> <span class="n">result</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">subresult</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">subresult</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">subresult</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">"List should be a Monad"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Free.h</p>
</blockquote>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="cp">#include "Functor.h"
#include "Monad.h"
</span></code></pre></div></div>

<h3 id="free-monads">Free Monads</h3>

<p>Every type <em>f</em> that is a Functor has a “Free” Monad. A Free Monad is some
category theory gobbledygook but it’s basically the simplest possible Monad
that doesn’t throw any information away.</p>

<p>In Haskell, this is defined quite simply:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data Free f a = Return a | Bind (f (Free f a))

instance (Functor f) =&gt; Monad (Free f) where
...
</code></pre></div></div>

<p>This is a bit complicated to express in C++ due to the lack of algebraic data
types, in particular the lack of a sum type (<code class="highlighter-rouge">tuple</code> and <code class="highlighter-rouge">struct</code> provide
product types). In C++17 we will get <code class="highlighter-rouge">variant</code> which plugs the gap acceptably
and in the meantime we can use <code class="highlighter-rouge">boost::variant</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;boost/variant.hpp&gt;
</span></code></pre></div></div>

<p>To define something like the Haskell <code class="highlighter-rouge">data</code> with two cases, we define a type
for each case and then combine them into a <code class="highlighter-rouge">variant</code>. Because the <code class="highlighter-rouge">Bind</code>
case is recursive we need to forward-declare them and use
<code class="highlighter-rouge">recursive_wrapper</code> to define the <code class="highlighter-rouge">variant</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Free</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Return</span><span class="p">;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Bind</span><span class="p">;</span>
</code></pre></div></div>

<p>We wrap the <code class="highlighter-rouge">variant</code> in a <code class="highlighter-rouge">struct</code> so we have somewhere to hang a couple of
type aliases that we will need later to be able to write down the type
signatures for some functions.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Free</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">ContainedType</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span>    <span class="o">=</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">recursive_wrapper</span><span class="o">&lt;</span><span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                   <span class="n">boost</span><span class="o">::</span><span class="n">recursive_wrapper</span><span class="o">&lt;</span><span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&gt;&gt;</span>
        <span class="n">v</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div>

<p>Now we can define the individual cases, quite analogously to the Haskell
definition. The only difference (apart from the syntax) is that we need to
name the members something.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Return</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Bind</span> <span class="p">{</span>
    <span class="n">F</span><span class="o">&lt;</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div></div>

<p>For our convenience, we define some helper function templates that handle
wrapping things up in the <code class="highlighter-rouge">Free</code> struct and allow some of the template
arguments to be deduced.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// This one is for when you know the Functor template argument - it can deduce</span>
  <span class="c1">// the contained type.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">make_return</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">{</span><span class="n">x</span><span class="p">}};</span>
  <span class="p">}</span>

  <span class="c1">// This one is for when you know the resulting Free type but not the template</span>
  <span class="c1">// arguments.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">FA</span><span class="o">&gt;</span>
  <span class="n">FA</span> <span class="nf">make_return</span><span class="p">(</span><span class="k">const</span> <span class="k">typename</span> <span class="n">FA</span><span class="o">::</span><span class="n">ContainedType</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="k">typename</span> <span class="n">FA</span><span class="o">::</span><span class="n">ReturnType</span><span class="p">{</span><span class="n">x</span><span class="p">}};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">make_bind</span><span class="p">(</span><span class="k">const</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">{</span><span class="n">x</span><span class="p">}};</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>It can be helpful while testing to be able to print out a value of <code class="highlighter-rouge">Free</code>,
so we define an overload of the left shift^W^Wstream out operator. This also
demonstrates how to get values out of the <code class="highlighter-rouge">variant</code> in a type-safe way—by
using a visitor.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">free</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Visitor</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"Return{"</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"}"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"Bind{"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"}"</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">Visitor</span> <span class="n">v</span><span class="p">{</span><span class="n">os</span><span class="p">};</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">free</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Now we implement the Functor functions. We don’t actually create the
specialization of the Functor template here because that has to be done in
the Functor namespace but it is more convenient to write the functions in
the Free namespace.</p>

<p>The Functor instance for Free is hilariously short and to-the-point in
Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">fun</span> <span class="p">(</span><span class="kt">Return</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Return</span> <span class="p">(</span><span class="n">fun</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">fun</span> <span class="p">(</span><span class="kt">Bind</span> <span class="n">x</span><span class="p">)</span>   <span class="o">=</span> <span class="kt">Bind</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">fun</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>We assume that any user that wants to use the Functor instance of Free for a
specific Functor F will create a wrapper type like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename A&gt;
struct Wrapper : Free&lt;F, A&gt; {};
</code></pre></div></div>

<p>This is needed so that the template parameters match up correctly - all the
Functor-related functions expect to deal with a template with a single
parameter, whereas <code class="highlighter-rouge">Free</code> has two.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">FunctorImpl</span> <span class="p">{</span>

    <span class="c1">// The visitor struct can't be defined inside the fmap function because it</span>
    <span class="c1">// contains member function templates, which we use to get the compiler to</span>
    <span class="c1">// tell us what the template F is in the Free&lt;F, A&gt; inside the wrapper.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fn</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Visitor</span> <span class="p">{</span>
      <span class="n">Fn</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">;</span>
      <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
      <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">make_return</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">a</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
      <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">Functor</span><span class="o">::</span><span class="n">fmap</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">make_bind</span><span class="p">(</span><span class="n">fmap</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fmap</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span> <span class="p">},</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// fmap :: (a -&gt; b) -&gt; Free f a -&gt; Free f b</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fn</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="k">const</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">Visitor</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Fn</span><span class="o">&gt;</span><span class="p">{</span><span class="n">fun</span><span class="p">},</span> <span class="n">f</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></div>

<p>Now that we have a way to make <code class="highlighter-rouge">Wrapper&lt;A&gt;</code>, aka <code class="highlighter-rouge">Free&lt;F, A&gt;</code>, a Functor, we
can also make it a Monad. Once again, the instance in Haskell is
embarrassingly short:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="kt">Return</span>
  <span class="p">(</span><span class="kt">Bind</span> <span class="n">x</span><span class="p">)</span>   <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Bind</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">Return</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">r</span>
</code></pre></div></div>

<p>Again, we’re not actually specializing the <code class="highlighter-rouge">Monad</code> class template here
because that has to be done in the <code class="highlighter-rouge">Monad</code> namespace and it’s more
convenient to write this stuff in the <code class="highlighter-rouge">Free</code> namespace.</p>

<p>Also again, we require the user to wrap their Functor to be Freed into
something with a single template parameter, as <code class="highlighter-rouge">Free&lt;F, A&gt;</code> doesn’t work
directly. We make an additional assumption about the wrapper class
template—it must have a type alias member named <code class="highlighter-rouge">WrappedFree</code> that is an
alias for the <code class="highlighter-rouge">Free&lt;F, A&gt;</code> type that is being wrapped, e.g.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename A&gt;
struct Wrapper : Free&lt;F, A&gt; {
  using WrappedType = Free&lt;F, A&gt;;
};
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">MonadImpl</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// pure :: a -&gt; m a</span>
    <span class="c1">// pure :: a -&gt; Free&lt;F&gt;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pure</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">make_return</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">WrappedFree</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// bind :: Free f a -&gt; (a -&gt; Free f b) -&gt; Free f b</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fn</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">BindVisitor</span> <span class="p">{</span>
      <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">B</span>           <span class="o">=</span> <span class="k">typename</span> <span class="n">result_type</span><span class="o">::</span><span class="n">ContainedType</span><span class="p">;</span>
      <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">,</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
      <span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">;</span>

      <span class="c1">// bind (Bind x) f = Bind (fmap (\m -&gt; bind m f) x)</span>
      <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
      <span class="n">result_type</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">f</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">make_bind</span><span class="p">(</span><span class="n">Functor</span><span class="o">::</span><span class="n">fmap</span><span class="p">(</span>
            <span class="p">[</span><span class="n">f</span><span class="p">](</span><span class="k">const</span> <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">Monad</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">f</span><span class="p">));</span>
            <span class="p">},</span>
            <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="c1">// bind (Return r) f = f r</span>
      <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span>
      <span class="n">result_type</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fn</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">bind</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">BindVisitor</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Fn</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">)};</span>
      <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></div>

<p>It is traditional to provide some helpers to make working with free monads
more convenient. The first of these is “liftFree”, which is used to “lift” a
functor F into a free monad.</p>

<p>The implementation looks like so in Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftFree</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">liftFree</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Bind</span> <span class="p">(</span><span class="n">fmap</span> <span class="kt">Return</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>In C++ this looks very similar, yay! A few extra type annotations are
required to help the compiler but it’s not too bad.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">liftFree</span><span class="p">(</span><span class="k">const</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_bind</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Functor</span><span class="o">::</span><span class="n">fmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">make_return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">x</span><span class="p">));</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>The other helper is really the whole point of the exercise; it allows you to
take a value of <code class="highlighter-rouge">Free&lt;F, A&gt;</code> and “evaluate” it in some way to yield another
monadic value.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldFree</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">x</span> <span class="o">.</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">foldFree</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Return</span> <span class="n">a</span><span class="p">)</span>  <span class="o">=</span> <span class="n">return</span> <span class="n">a</span>
<span class="n">foldFree</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Bind</span> <span class="n">as</span><span class="p">)</span>   <span class="o">=</span> <span class="n">f</span> <span class="n">as</span> <span class="o">&gt;&gt;=</span> <span class="n">foldFree</span> <span class="n">f</span>
</code></pre></div></div>

<p>Because we want to be totally generic with regards to the callable object
that is passed in, it’s not possible to deduce the resulting Monad template,
so the caller has to specify it. The other template parameters can be
deduced, however.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">M</span><span class="p">,</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">F</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">Fun</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">M</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">foldFree</span><span class="p">(</span><span class="n">Fun</span> <span class="n">fun</span><span class="p">,</span> <span class="k">const</span> <span class="n">Free</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">free</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Visitor</span> <span class="p">{</span>
      <span class="n">Fun</span> <span class="n">fun</span><span class="p">;</span>

      <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Monad</span><span class="o">::</span><span class="n">pure</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">a</span><span class="p">);</span> <span class="p">}</span>
      <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Bind</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">foldFree</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">Visitor</span> <span class="n">v</span><span class="p">{</span><span class="n">fun</span><span class="p">};</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">free</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>All that remains to be done is to actually make <code class="highlighter-rouge">Free&lt;F&gt;</code> a Functor and a
Monad. Recall that <code class="highlighter-rouge">Free</code> actually has two template parameters but the
<code class="highlighter-rouge">Functor</code> and <code class="highlighter-rouge">Monad</code> class templates expect a template with one parameter as
their template argument. So, we require a wrapper class template that has only
one template parameter.</p>

<p>Given a class template <code class="highlighter-rouge">Wrapper</code> whose instantiations <code class="highlighter-rouge">Wrapper&lt;A&gt;</code> have
<code class="highlighter-rouge">Free&lt;F, A&gt;</code> as a base and a type alias template member <code class="highlighter-rouge">WrappedFree</code> equal to
<code class="highlighter-rouge">Free&lt;F, A&gt;</code>, we can create a partial speciailization of both <code class="highlighter-rouge">Functor</code> and
<code class="highlighter-rouge">Monad</code>.</p>

<p>The below speciailizations are not quite as constrained as I would like
because they don’t actually mention <code class="highlighter-rouge">Free</code> anywhere, so they apply to any
class template that inherits from the class named by its <code class="highlighter-rouge">WrappedFree</code> member.
The reason for this is that I haven’t been able to figure out how to get the
<code class="highlighter-rouge">F</code> out in order to write <code class="highlighter-rouge">Free&lt;F, void&gt;</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Functor</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">WrappedFree</span><span class="p">,</span>
                                                  <span class="n">Wrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
      <span class="o">:</span> <span class="n">Free</span><span class="o">::</span><span class="n">FunctorImpl</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Monad</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Monad</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="p">,</span>
               <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">WrappedFree</span><span class="p">,</span>
                                                <span class="n">Wrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
      <span class="o">:</span> <span class="n">Free</span><span class="o">::</span><span class="n">MonadImpl</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To finish things off, we do some compile-time verification that these partial
specializations work as we expect by wrapping <code class="highlighter-rouge">NullFunctor</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Free</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">NullFreeWrapper</span> <span class="o">:</span> <span class="n">Free</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">::</span><span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="k">using</span> <span class="n">WrappedFree</span> <span class="o">=</span> <span class="n">Free</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">::</span><span class="n">Test</span><span class="o">::</span><span class="n">NullFunctor</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">Functor</span><span class="o">::</span><span class="n">IsFunctor</span><span class="o">&lt;</span><span class="n">NullFreeWrapper</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="s">"Functor speciailization for Free wrappers works"</span><span class="p">);</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">Monad</span><span class="o">::</span><span class="n">IsMonad</span><span class="o">&lt;</span><span class="n">NullFreeWrapper</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="s">"Monad speciailization for Free wrappers works"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="usage">Usage</h2>

<blockquote>
  <p>FreeTest.cpp</p>
</blockquote>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Free.h"
#include "Functor.h"
#include "List.h"
#include "Monad.h"
</span>
<span class="cp">#include "catch.hpp"
</span>
<span class="cp">#include &lt;boost/variant.hpp&gt;
</span>
<span class="cp">#include &lt;functional&gt;
#include &lt;string&gt;
</span></code></pre></div></div>

<h3 id="using-free">Using Free</h3>

<p>We will define a data structure and its corresponding free monad and show how
to use the free monad to build and then interpret expressions in a simple
domain-specific language.</p>

<p>First, we will need a couple of basic definitions.</p>

<h4 id="unit">Unit</h4>

<p>One of the basic types in Haskell is <code class="highlighter-rouge">()</code>, aka “unit”. It has exactly one
value, <code class="highlighter-rouge">()</code>. It is an empty product type. In C++ we have two options for
product types: structs or tuples. An empty one of either will do the job but
<code class="highlighter-rouge">std::tuple&lt;&gt;</code> has the advantage of giving us equality and ordering for free.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"unit{}"</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="identity">Identity</h4>

<p>A very useful generic function is the identity function. In Haskell it is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">id</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<p>In C++ we can define a function template to do the same thing.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="n">A</span> <span class="nf">id</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="function-composition">Function Composition</h4>

<p>Function composition is ubiquitous in Haskell and we will use it below. It
doesn’t come predefined in C++ but it’s surprisingly easy these days.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compose</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">compose</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">G</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">compose</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="language-definition">Language Definition</h4>

<p>We define a data type to represent the operations in our language. In our
example there are only two operations: <code class="highlighter-rouge">Read</code>, which takes the value or values
so far written and does something, and <code class="highlighter-rouge">Write</code>, which “writes” a value and
then does something.</p>

<p>This is all very vague because the details are decoupled from this definition
and are supplied separately.</p>

<p>In Haskell our data type is just:</p>

<pre><code class="language-haksell">data Prog a =
    Read (Int -&gt; a)
  | Write Int (() -&gt; a)
</code></pre>

<p>As usual, things get verbose in C++. We define a struct to correspond to each
of the cases and wrap them in a variant.</p>

<p>Note that I’ve cheated somewhat by using <code class="highlighter-rouge">std::function</code> instead of making the
continuation type a template parameter in order to make this code simpler.
Doing this probably stops the compiler from optimising this as much as it
otherwise could.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Next</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Read</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Next</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Next</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Write</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Next</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Next</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Prog</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Read</span><span class="o">&lt;</span><span class="n">Next</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Write</span><span class="o">&lt;</span><span class="n">Next</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As is typical when using class templates, we define corresponding “make_”
function templates so that the template arguments can be deduced. These
function templates have the additional benefit of wrapping the value up in our
<code class="highlighter-rouge">Prog</code> struct.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="n">Prog</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">make_read</span><span class="p">(</span><span class="n">F</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">Read</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">};</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="n">Prog</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">make_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">F</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">Write</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">next</span><span class="p">}};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In order to use <code class="highlighter-rouge">Prog</code>’s Free Monad, <code class="highlighter-rouge">Prog</code> must be a Functor. In Haskell with
the appropriate extension we could just add <code class="highlighter-rouge">deriving Functor</code> to the data
type definition but we’re stuck down here in C++ so we’ll have to specialize
the <code class="highlighter-rouge">Functor</code> class template manually.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// instance Functor Prog where</span>
<span class="k">namespace</span> <span class="n">Functor</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span><span class="o">&lt;</span><span class="n">Prog</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Fun</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Next</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">Prog</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Next</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="k">const</span> <span class="n">Prog</span><span class="o">&lt;</span><span class="n">Next</span><span class="o">&gt;&amp;</span> <span class="n">prog</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">using</span> <span class="n">Res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Next</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">Visitor</span> <span class="p">{</span>
        <span class="n">Fun</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">;</span>
        <span class="c1">// fmap f (Read n) = Read (f . n)</span>
        <span class="n">Prog</span><span class="o">&lt;</span><span class="n">Res</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Read</span><span class="o">&lt;</span><span class="n">Next</span><span class="o">&gt;&amp;</span> <span class="n">read</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">make_read</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">read</span><span class="p">.</span><span class="n">next</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="c1">// fmap f (Write x n) = Write x (f . n)</span>
        <span class="n">Prog</span><span class="o">&lt;</span><span class="n">Res</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Write</span><span class="o">&lt;</span><span class="n">Next</span><span class="o">&gt;&amp;</span> <span class="n">write</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">make_write</span><span class="p">(</span><span class="n">write</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">compose</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">write</span><span class="p">.</span><span class="n">next</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">Visitor</span><span class="p">{</span><span class="n">fun</span><span class="p">},</span> <span class="n">prog</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="the-free-monad">The Free Monad</h4>

<p>Now, to use <code class="highlighter-rouge">Prog</code> as a Monad, all we need to do is define a wrapper around
<code class="highlighter-rouge">Free&lt;Prog, A&gt;</code> so that we get a template with a single type parameter. The
specialization of <code class="highlighter-rouge">Monad</code> defined in <code class="highlighter-rouge">Free.h</code> takes care of the rest.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Program</span> <span class="o">:</span> <span class="n">Free</span><span class="o">::</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">Prog</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">WrappedFree</span> <span class="o">=</span> <span class="n">Free</span><span class="o">::</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">Prog</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">Program</span><span class="p">(</span><span class="k">const</span> <span class="n">WrappedFree</span><span class="o">&amp;</span> <span class="n">free</span><span class="p">)</span> <span class="o">:</span> <span class="n">Free</span><span class="o">::</span><span class="n">Free</span><span class="o">&lt;</span><span class="n">Prog</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>There is some boilerplate required to lift the constructors of <code class="highlighter-rouge">Prog</code> into the
<code class="highlighter-rouge">Program</code> Monad. This boilerplate is even required in Haskell!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">readF</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Prog</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">readF</span> <span class="o">=</span> <span class="n">liftFree</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">id</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Program</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">readF</span> <span class="o">=</span> <span class="n">Free</span><span class="o">::</span><span class="n">liftFree</span><span class="p">(</span><span class="n">make_read</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">));</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">writeF</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Prog</span> <span class="nb">()</span><span class="p">)</span>
<span class="n">writeF</span> <span class="n">x</span> <span class="o">=</span> <span class="n">liftFree</span> <span class="p">(</span><span class="kt">Write</span> <span class="n">x</span> <span class="n">id</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Program</span><span class="o">&lt;</span><span class="n">unit</span><span class="o">&gt;</span> <span class="n">writeF</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Free</span><span class="o">::</span><span class="n">liftFree</span><span class="p">(</span><span class="n">make_write</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">id</span><span class="o">&lt;</span><span class="n">unit</span><span class="o">&gt;</span><span class="p">));</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="an-interpreter">An Interpreter</h4>

<p>In order to give some meaning to values of <code class="highlighter-rouge">Prog&lt;A&gt;</code> we need an interpreter,
i.e. a function that takes an action, somehow performs the action associated
with it and then invokes its continuation (zero or more times).</p>

<p>For our example we will define an interpreter that keeps track of the values
written and invokes <code class="highlighter-rouge">Read</code> continuations once for each such value. Because
this is C++ and not Haskell, we can keep some mutable state; in Haskell we’d
need to be in the State Monad or similar.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// interpret :: Prog a -&gt; List a</span>
<span class="c1">// interpret (Read n) = fmap n STATE</span>
<span class="c1">// interpret (Write x n) = STATE+=x; n ()</span>
<span class="k">struct</span> <span class="n">Interpreter</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>  <span class="c1">// the values written so far</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Prog</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">prog</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Visitor</span> <span class="p">{</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">;</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Read</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// invoke the continuation with each of the values that have been written so far</span>
        <span class="k">return</span> <span class="n">Functor</span><span class="o">::</span><span class="n">fmap</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Write</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// remember the value and invoke the continuation</span>
        <span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">w</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="n">unit</span><span class="p">{})};</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">Visitor</span> <span class="n">v</span><span class="p">{</span><span class="n">l</span><span class="p">};</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">apply_visitor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prog</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Our interpreter works on values of <code class="highlighter-rouge">Prog&lt;A&gt;</code>, but when we use the Free Monad
we will be constructing values of type <code class="highlighter-rouge">Program&lt;A&gt;</code>, aka <code class="highlighter-rouge">Free&lt;Prog, A&gt;</code>. So,
we define a helper that runs our interpreter on such a value, using the
<code class="highlighter-rouge">foldFree</code> function we defined in <code class="highlighter-rouge">Free.h</code>.</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// run :: Program a -&gt; List a</span>
<span class="c1">// run p = foldFree interpret p</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">run</span><span class="p">(</span><span class="n">Program</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">program</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Interpreter</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Free</span><span class="o">::</span><span class="n">foldFree</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">program</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="tests">Tests</h4>

<p>OK, that’s the tedious setup out of the way—now we can actually use our Free
Monad!</p>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_CASE</span><span class="p">(</span><span class="s">"Free monad for Prog"</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">pure</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Monad</span><span class="o">::</span><span class="n">pure</span><span class="o">&lt;</span><span class="n">Program</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">};</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">readF</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
    <span class="c1">// clang-format off</span>
    <span class="k">auto</span> <span class="n">free</span> <span class="o">=</span>
      <span class="n">readF</span><span class="p">;</span>
    <span class="c1">// clang-format on</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">run</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">readF</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
    <span class="c1">// clang-format off</span>
    <span class="n">Program</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">free</span> <span class="o">=</span>
      <span class="n">readF</span> <span class="o">&gt;&gt;=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span>
      <span class="n">pure</span><span class="p">(</span><span class="n">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="c1">// clang-format on</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">run</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">writeF</span> <span class="mi">10</span>
  <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">readF</span>
  <span class="n">writeF</span> <span class="mi">20</span>
  <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">readF</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c++ cpp2blog-source highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
    <span class="c1">// clang-format off</span>
    <span class="k">auto</span> <span class="n">free</span> <span class="o">=</span>
      <span class="n">writeF</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
      <span class="n">readF</span> <span class="o">&gt;&gt;=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span>
      <span class="n">writeF</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
      <span class="n">readF</span> <span class="o">&gt;&gt;=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span>
      <span class="n">pure</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">};};</span>
    <span class="c1">// clang-format on</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">run</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}));</span>
  <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>I have shown a method for implementing something analogous to Haskell’s Monad
type class in C++ using a class template with a template template parameter. In
addition, I have show that a generic Free Monad for any Functor can be defined
and used in a similar manner to how it is done in Haskell.</p>

<p>The use of this implementation is not very ergonomic due to the very limited
type inference provided by C++ and the lack of any syntactic sugar for composing
monadic values.</p>

<h2 id="related-work">Related Work</h2>

<ul>
  <li><a href="https://bartoszmilewski.com/2011/07/11/monads-in-c/">https://bartoszmilewski.com/2011/07/11/monads-in-c/</a></li>
  <li><a href="http://stackoverflow.com/a/2565191">http://stackoverflow.com/a/2565191</a></li>
</ul>

	</article>
	<br/>
<!--
  <a href="http://twitter.com/home?status=Free Monads in C++ by @CanftIn http://localhost:4000/2020/04-07-free-monads-in-cpp.html"
	   target="_blank" class="tweet">Tweet this</a> 
	<a href="http://twitter.com/home?status=Free Monads in C++ by @CanftIn http://localhost:4000/2020/04-07-free-monads-in-cpp.html"
    target="_blank" title="Tweet this" class="tweet_this"><i class="fa fa-twitter"></i></a>
-->
	<a href="#top" class="top">Top</a>
	<div class="cc-license">
		<br/>
<h2>License</h2>
<!--
	This work (<a xmlns:cc="http://creativecommons.org/ns#" href="/2020/04-07-free-monads-in-cpp.html" property="cc:attributionName"
				  rel="cc:attributionURL">Free Monads in C++</a>) is licensed under a
	<a rel="license"
	   href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
    Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

	<a rel="license"
	   href="http://creativecommons.org/licenses/by-nc-nd/4.0/"></a><br/>
<br/>
-->
<div style="text-align: center;">
    <img alt="License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"/>
</div>
<br/>

	</div>
</section>
<div class="comment">
	<br/><br/>


<div class="wrapper container">
	<div id=comments>
		<a href="https://github.com/CanftIn/CanftIn.github.io/issues/new">
			Create an issue
		</a>
		to apply for commentary
	</div>
</div>



</div>

<footer>
	<div class="copyright left mobile-block">
		© 2016-2020
		<span title="CanftIn">CanftIn</span>
	</div>
	<a href="/feed.xml">RSS Feed</a>

	
</footer>

</body>
</html>
