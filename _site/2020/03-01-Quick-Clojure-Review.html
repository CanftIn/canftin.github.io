<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>Quick Clojure Review</title>
	<meta name="description" content="A blog by CanftIn">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/assets/css/code.css">
	
	<link rel="alternate" type="application/rss+xml" title="RSS" href="/feeds.xml">
	<!-- PUBLIC RESOURCE BEGIN -->
	<!-- <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> -->
	<link href="https://fonts.googleapis.com/css?family=Merriweather|Montserrat" rel="stylesheet"> 
	<!-- PUBLIC RESOURCE END -->
	<link rel="shortcut icon" href="../favicon.png">
	<link rel="author" href="https://github.com/CanftIn">
	<meta name="twitter:site" content="CanftIn">
	<!-- <\!--/*404 THINGS*/[if lt IE 9]> -->
	<!-- <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script> -->
	<!-- <!/**/[endif]-\-> -->
	<!-- <\!--[if lt IE 9]-\-> -->
	<!-- <script src="https://cdn.bootcss.com/html5shiv/r29/html5.js"></script> -->
	<!-- <\!--[endif]-\-> -->
	<meta property="og:title" content="CanftIn.com">
	<meta property="og:type" content="website">
	<meta property="og:url" content="">
	<meta property="og:site_name" content="CanftIn.com">
	<meta property="og:description" content="A blog by CanftIn">
	<script>
	(adsbygoogle = window.adsbygoogle || []).push({
		google_ad_client: "ca-pub-4120677882232967",
		enable_page_level_ads: true
	});
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110017464-1"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());gtag('config', 'UA-110017464-1');
</script>


	<link rel="canonical" href="http://localhost:4000/2020/03-01-Quick-Clojure-Review.html">
</head>

<body>
<header id="top">
	<nav>
		<ul>
			<!-- <li><a href="https://github.com/CanftIn"> -->
			<!-- 	<img src="/assets/svg/mark-github.svg" /><span>GitHub</span></a></li> -->
			<li><a href="/pages/about.html">
				<img src="/assets/svg/mention.svg"/><span>About</span></a></li>
			<!-- <li><a href="/lagda/"> -->
			<!-- 	<img src="/assets/svg/law.svg"/><span>LAgda</span></a></li> -->
			<!-- <li><a href="/gists/"> -->
			<!-- 	<img src="/assets/svg/file-code.svg"/><span>Gists</span></a></li> -->
			<!-- <li><a href="/languages/"> -->
			<!-- 	<img src="/assets/svg/terminal.svg"/><span>Langs</span></a></li> -->
			<!-- <li><a href="/projects/"> -->
			<!-- 	<img src="/assets/svg/repo.svg"/><span>Projects</span></a></li> -->
			<!-- <li><a href="/pages/cn.html"> -->
        <!-- <img src="/assets/svg/tag.svg"/><span>Chinese</span></a></li> -->
			<li><a href="/CharacterMap/index.html">
				<img src="/assets/svg/font.svg"/><span>CharacterMap</span></a></li>
			<li><a href="/">
				<img src="/assets/svg/home.svg"/><span>Home</span></a></li>
		</ul>
	</nav>
</header>

<div style="border-bottom: 1px solid #000"></div>

<section class="container" itemscope itemtype="http://schema.org/Blog">
	<h1 class="big" itemprop="name">Quick Clojure Review</h1>
	<p class="date">
		<span itemprop="datePublished" content="2020-03-01 00:00:00 +0800">2020, Mar 1</span>
		by <span itemprop="author">CanftIn</span>
	</p>
	<article itemprop="articleBody">
		<h1 id="what-is-clojure">What Is Clojure?</h1>
<p><a href="https://clojure.org/">Clojure</a> is a functional, symbiotic, and homoiconic programming language.</p>
<ul>
  <li>Functional: where functions are first-class citizens and mutating
state is frowned upon</li>
  <li>Symbiotic: the language is intended to be run atop a host.
environment</li>
  <li>Homoiconic: “code is data” — this helps facilitate a macro system for rewriting the language.</li>
</ul>

<h1 id="data-structures">Data Structures</h1>
<p>Clojure provides a language API based upon a select set of data structures.</p>
<ul>
  <li>List: (1 2 3)</li>
  <li>Vector: [1 2 3]</li>
  <li>Map: {:foo “bar”}</li>
  <li>Set: #{1 2 3}</li>
</ul>

<h2 id="list">List</h2>
<p>A list uses parentheses as its surrounding delimiters, and so an empty list would look like (), whereas a list with three elements could look like (“a” “b” “c”).</p>

<p>Clojure will happily hide those details away from you and provide abstractions that make dealing with data structures in the most appropriate and performant manner very easy.</p>

<p>By using the <code class="highlighter-rouge">cons</code> function, which will insert your value at the beginning of the list.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">cons</span> <span class="mi">4</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; (4 1 2 3)</span>
</code></pre></div></div>
<p>Or, <code class="highlighter-rouge">conj</code> function instead, which will pick the correct method for inserting the new value at the start of the list.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">conj</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; (4 1 2 3)</span>
</code></pre></div></div>
<p>But, if your data structure were a vector collection instead, then the conj function would know to insert the value at the end of the collection.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">conj</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="nv">3]</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; [1 2 3 4]</span>
</code></pre></div></div>
<p>There are other abstraction functions:</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">peek</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="nv">3]</span><span class="p">)</span> <span class="c1">;; 3</span>
<span class="p">(</span><span class="nv">peek</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;; 1</span>
<span class="p">(</span><span class="nb">pop</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="nv">3]</span><span class="p">)</span> <span class="c1">;; [1 2]</span>
<span class="p">(</span><span class="nb">pop</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;; (2 3)</span>
</code></pre></div></div>
<h2 id="vector">Vector</h2>
<p>Vectors allow you to have index access to any element within the data structure.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">get</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="nv">5]</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; 4</span>
</code></pre></div></div>
<p>You can modify the vector by using the assoc function (which is an abbreviation of “associate”). The way it works is that you provide the index of the vector you want to modify and then provide the value.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">assoc</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="nv">5]</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1">;; [1 2 3 4 5 6]</span>
<span class="p">(</span><span class="nb">assoc</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="nv">5]</span> <span class="mi">0</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">;; [8 2 3 4 5]</span>
</code></pre></div></div>
<p>but what if you want to remove a value? One way to do this would be to use the pop function, which returns a copy of the vector but with the last element removed.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">pop</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="nv">5]</span><span class="p">)</span>
<span class="c1">;; [1 2 3 4]</span>
</code></pre></div></div>
<h2 id="map">Map</h2>
<p>The map data structure goes by many different names—hash, hash map, dictionary—and what distinguishes it from other data structures is the underlying implementation, which is a key part of ensuring the algorithmic performance of this particular data structure.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">{:my-key</span> <span class="s">"this is my value"</span><span class="nv">}</span>
<span class="p">(</span><span class="nb">get</span> <span class="nv">{:my-key</span> <span class="s">"this is my value"</span><span class="nv">}</span> <span class="ss">:my-key</span><span class="p">)</span>
<span class="c1">;; "this is my value"</span>

<span class="c1">;; If you want the entire entry</span>
<span class="p">(</span><span class="nb">find</span> <span class="nv">{:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="nv">2}</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;; [:a 1]</span>

<span class="p">(</span><span class="nb">assoc</span> <span class="nv">{:foo</span> <span class="s">"bar"</span><span class="nv">}</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="p">)</span>
<span class="c1">;; {:foo "bar", :baz "qux"}</span>

<span class="p">(</span><span class="nv">dissoc</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span> <span class="ss">:baz</span><span class="p">)</span>
<span class="c1">;; {:foo "bar"}</span>

<span class="p">(</span><span class="nv">select-keys</span> <span class="nv">{:name</span> <span class="s">"Mark"</span> <span class="ss">:age</span> <span class="mi">33</span> <span class="ss">:location</span> <span class="s">"London"</span><span class="nv">}</span> <span class="nv">[:name</span> <span class="ss">:location]</span><span class="p">)</span>
<span class="c1">;; {:name "Mark", :location "London"}</span>
</code></pre></div></div>
<h3 id="keywords">Keywords</h3>
<p>Some readers may be wondering what the colon prefixing the key is supposed to mean. The colon indicates that the key is actually a keyword.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Keyword as a Function</span>
<span class="p">(</span><span class="nb">get</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span> <span class="ss">:baz</span><span class="p">)</span>
<span class="c1">;; "qux"</span>
<span class="p">(</span><span class="ss">:baz</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span><span class="p">)</span>
<span class="c1">;; "qux"</span>

<span class="c1">;; Demonstrate the contains? Function</span>
<span class="p">(</span><span class="nv">contains?</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="c1">;; true</span>
</code></pre></div></div>
<h3 id="keys-values-and-replacement">Keys, Values, and Replacement</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Demonstrate the keys and vals Functions</span>

<span class="p">(</span><span class="nv">keys</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span><span class="p">)</span>
<span class="c1">;; (:baz :foo)</span>
<span class="p">(</span><span class="nv">vals</span> <span class="nv">{:foo</span> <span class="s">"bar"</span> <span class="ss">:baz</span> <span class="s">"qux"</span><span class="nv">}</span><span class="p">)</span>
<span class="c1">;; ("qux" "bar")</span>
</code></pre></div></div>
<p>The replace function allows you to create a new vector consisting of values extracted from a map data structure.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Demonstrate the replace Function</span>

<span class="p">(</span><span class="nb">replace</span> <span class="nv">{:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="nv">3}</span> <span class="nv">[:c</span> <span class="ss">:b</span> <span class="ss">:a]</span><span class="p">)</span>
<span class="c1">;; [3 2 1]</span>
<span class="p">(</span><span class="nb">replace</span> <span class="nv">[:a</span> <span class="ss">:b</span> <span class="ss">:c]</span> <span class="nv">[2</span> <span class="mi">1</span> <span class="nv">0]</span><span class="p">)</span>
<span class="c1">;; [:c :b :a].</span>
</code></pre></div></div>
<h2 id="set">Set</h2>
<p>A set is a data structure made up of unique values. Much like Clojure’s map and vector data structures, it provides Clojure with a very lightweight data model.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Simple Set Data Structure Example</span>

<span class="err">#</span><span class="nv">{1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c}</span>
<span class="c1">;; #{1 :c 3 2 :b :a}</span>

<span class="c1">;; Filter Out Duplicates</span>
<span class="p">(</span><span class="nb">set</span> <span class="nv">[1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="nv">6]</span><span class="p">)</span>
<span class="c1">;; #{1 4 6 3 2 5}</span>
<span class="p">(</span><span class="nb">apply</span> <span class="nv">sorted-set</span> <span class="nv">[1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="nv">6]</span><span class="p">)</span>
<span class="c1">;; #{1 2 3 4 5 6}</span>

<span class="c1">;; Using conj to Add New Value to a Set</span>
<span class="p">(</span><span class="nv">conj</span> <span class="err">#</span><span class="nv">{1</span> <span class="mi">2</span> <span class="nv">3}</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;; #{1 4 3 2}</span>
<span class="p">(</span><span class="nv">conj</span> <span class="err">#</span><span class="nv">{1</span> <span class="mi">2</span> <span class="nv">3}</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; #{1 3 2}</span>

<span class="c1">;; Remove Items from a Set with disj</span>
<span class="p">(</span><span class="nv">disj</span> <span class="err">#</span><span class="nv">{1</span> <span class="mi">2</span> <span class="nv">3}</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; #{1 2}</span>
</code></pre></div></div>
<h1 id="functional-programming">Functional Programming</h1>
<ul>
  <li>Immutability</li>
  <li>Referential transparency</li>
  <li>First-class functions</li>
  <li>Partial application</li>
  <li>Recursive iteration</li>
  <li>Composability</li>
</ul>

<h2 id="immutability">Immutability</h2>
<p>If you have state and it can change, then once your application becomes distributed and concurrent, you’ll end up in a world of hurt, as many different threads can start manipulating your data at non-deterministic times. This can cause your application to fail at any given moment and become very hard to debug and to reason about. By offering immutability, Clojure can help to side-step this problem. In Clojure, every time you manipulate a data structure you are returned not a mutated version of the original, but rather a whole new copy with your change(s) applied.</p>
<h2 id="referential-transparency">Referential transparency</h2>
<p>Referential transparency is when an expression can be replaced by its value without changing the behavior of a program.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of a Referentially Transparent Function</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">sum</span> <span class="nv">[x</span> <span class="nv">y]</span>
 <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">sum</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;; 2</span>
</code></pre></div></div>
<p>The function sum (shown in Listing 3-1) is referentially transparent. No matter what happens, if I provide the same set of arguments (in this case 1 and 1), I’ll always get back the same result.</p>
<h2 id="first-class-functions">First-class Functions</h2>
<p>For a language to offer “first-class functions,” it needs to be able to both store functions and pass functions around as if they were values. We’ve already seen the former being achieved using variables, and the latter (passing functions around as values) is also possible within Clojure.</p>
<ul>
  <li>complement</li>
  <li>apply</li>
  <li>map</li>
  <li>reduce</li>
  <li>filter</li>
  <li>comp</li>
</ul>

<h3 id="complement">complement</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of the complement function returning the opposite truth value</span>
<span class="p">((</span><span class="nb">complement</span> <span class="nv">empty?</span><span class="p">)</span> <span class="s">""</span><span class="p">)</span>
<span class="c1">;; false</span>
</code></pre></div></div>
<h3 id="apply">apply</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">apply</span> <span class="nv">str</span> <span class="nv">[</span><span class="s">"a"</span> <span class="s">"b"</span> <span class="s">"c"</span><span class="nv">]</span><span class="p">)</span>
<span class="c1">;; "abc"</span>
</code></pre></div></div>
<h3 id="map-1">map</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of map</span>
<span class="p">(</span><span class="nb">map</span> <span class="nv">inc</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="nv">3]</span><span class="p">)</span>
<span class="c1">;; (2 3 4)</span>

<span class="c1">;; The map Return Value Type Is a List</span>
<span class="p">(</span><span class="nb">map</span>
  <span class="p">(</span><span class="nv">fn</span> <span class="nv">[[k</span> <span class="nv">v]]</span> <span class="p">(</span><span class="nv">inc</span> <span class="nv">v</span><span class="p">))</span>
  <span class="nv">{:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="nv">3}</span><span class="p">)</span> <span class="c1">;; =&gt; (4 3 2)</span>
<span class="c1">;; (2 3 4)</span>

<span class="c1">;; Ensure map Returns Key/Value-like Data Structure</span>
<span class="p">(</span><span class="nb">map</span>
  <span class="p">(</span><span class="nv">fn</span> <span class="nv">[[k</span> <span class="nv">v]]</span> <span class="nv">[k</span> <span class="p">(</span><span class="nv">inc</span> <span class="nv">v</span><span class="p">)</span><span class="nv">]</span><span class="p">)</span>
  <span class="nv">{:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="nv">3}</span><span class="p">)</span>
<span class="c1">;; ([:c 4] [:b 3] [:a 2])</span>
</code></pre></div></div>
<h3 id="reduce">reduce</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of the reduce Function</span>
<span class="p">(</span><span class="nb">reduce</span> <span class="nb">+</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="nv">4]</span><span class="p">)</span>
<span class="c1">;; 10</span>
</code></pre></div></div>
<h3 id="filter">filter</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of the filter Function</span>
<span class="p">(</span><span class="nv">filter</span> <span class="nv">even?</span> <span class="p">(</span><span class="nv">range</span> <span class="mi">10</span><span class="p">))</span>
<span class="c1">;; (0 2 4 6 8)</span>
</code></pre></div></div>
<h3 id="comp">comp</h3>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of the comp Function</span>
<span class="p">((</span><span class="nv">comp</span> <span class="nv">clojure.string/upper-case</span> <span class="p">(</span><span class="nv">partial</span> <span class="nb">apply</span> <span class="nv">str</span><span class="p">)</span> <span class="nb">reverse</span><span class="p">)</span> <span class="s">"hello"</span><span class="p">)</span>
<span class="c1">;; "OLLEH"</span>
</code></pre></div></div>
<h2 id="partial-application">Partial application</h2>
<p>Partial application helps to promote the creation of functions that can expand their use cases beyond their initial intent. 
The concept of partial application is regularly confused with another functional concept known as currying (which Clojure doesn’t support). When you “curry” a function, the function’s arguments are expanded internally into separate functions.
A curried function won’t execute its body until all arguments have been provided (similar to partial application). So, again, if your function accepted three arguments you could effectively call your curried function in one of the following ways.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Internal Representation of a Curry-Compiled Output</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">(</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">)(</span><span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">)(</span><span class="dl">'</span><span class="s1">z</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'xyz'</span>
</code></pre></div></div>
<p>So, just to recap, the main differences between currying and partial application are as follows.</p>
<ol>
  <li>You only partially apply your values once. So, if your function takes three arguments and you partially apply two of them, then when your resulting function is called you only provide one argument. If you had instead partially applied only one argument, you would still only call the resulting function once (but this time you would have to provide the remaining two arguments).</li>
  <li>If we consider the “API” scenario from earlier, you are providing the initial values for the partially applied function, whereas with a curried function it is the user who provides the arguments.</li>
</ol>

<h2 id="recursive-iteration">Recursive Iteration</h2>
<p>The classic for loop you’re likely familiar with <code class="highlighter-rouge">for (i = 0; i &lt; 10; i++) {}</code> by design allows mutating local variables to increment the loop. In Clojure, local variables are immutable, and so for us to loop we need to use recursive function calls instead.
Instead of looping, you’ll typically need to use the <code class="highlighter-rouge">loop/recur</code> special form, although a lot of the time other iterator-style functions such as map, reduce, and filter will be better fitted to solving the problem at hand. 
The main benefit of the <code class="highlighter-rouge">loop/recur</code> special form is that it allows you to safely apply recursive function calls without exhausting your memory stack. For example, if you’ve ever written any JavaScript code in your life you’ll likely have hit a problem at least once where you’ve exhausted the stack and caused a “stack overflow” error.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of Stack Exhaustion</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">count-down</span> <span class="nv">[x]</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">prn</span> <span class="s">"finished"</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">count-down</span> <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="nv">prn</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">dec</span> <span class="nv">x</span><span class="p">)))))</span>
<span class="p">(</span><span class="nv">count-down</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">;; works exactly as previous example BUT it's not safe!</span>
<span class="p">(</span><span class="nv">count-down</span> <span class="mi">100000</span><span class="p">)</span> <span class="c1">;; will cause a "StackOverflowError"</span>
</code></pre></div></div>
<p>Resolving the problem with the code will require a  process that the else statement need to be modified so that instead of returning a function call to count-down you return a function.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of trampoline Function</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">count-down</span> <span class="nv">[x]</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">prn</span> <span class="s">"finished"</span><span class="p">)</span>
    <span class="o">#(</span><span class="nv">count-down</span> <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="nv">prn</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">dec</span> <span class="nv">x</span><span class="p">)))))</span>
<span class="p">(</span><span class="nv">trampoline</span> <span class="nv">count-down</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; works fine still</span>
<span class="p">(</span><span class="nv">trampoline</span> <span class="nv">count-down</span> <span class="mi">100000</span><span class="p">)</span> <span class="c1">; no longer triggers an error</span>
</code></pre></div></div>
<p>Remember: #(…) is a shorthand syntax for an anonymous function.</p>
<h2 id="composability">Composability</h2>
<p>The main reason this is such a key aspect of functional programming is that your units of functionality should be generic enough to be reused within many different contexts, rather than being overly specific to one environment and ultimately not being reusable.</p>
<h1 id="sequences">Sequences</h1>
<p>In Clojure we have many types of collections: lists, vectors, maps, and sets. Each of these collections is also a sequence.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Example of Triggering Side-effect Only (No Modifications)</span>
<span class="p">(</span><span class="nv">doseq</span> <span class="nv">[element</span> <span class="o">'</span><span class="p">(</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span><span class="nv">]</span>
  <span class="p">(</span><span class="nv">prn</span> <span class="p">(</span><span class="nv">str</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">element</span><span class="p">)</span> <span class="s">"!"</span><span class="p">)))</span>
<span class="c1">;; "a!"</span>
<span class="c1">;; "b!"</span>
<span class="c1">;; "c!"</span>
<span class="c1">;; nil</span>

<span class="c1">;; Example of for Loop</span>
<span class="p">(</span><span class="nv">for</span> <span class="nv">[element</span> <span class="o">'</span><span class="p">(</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span><span class="nv">]</span>
  <span class="p">(</span><span class="nv">prn</span> <span class="p">(</span><span class="nv">str</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">element</span><span class="p">)</span> <span class="s">"!"</span><span class="p">)))</span>
<span class="c1">;; (nil nil nil)</span>
</code></pre></div></div>
<p>In the preceding example, the code loops over the given collection with the intention of creating a new list based upon the result of each iteration. But because we’ve not returned anything from the body for each iteration, we end up with (nil nil nil) being returned.</p>
<h2 id="list-comprehension">List Comprehension</h2>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Use of map to Mimic for Example</span>
<span class="p">(</span><span class="nb">map</span>
  <span class="p">(</span><span class="nv">fn</span> <span class="nv">[element]</span>
    <span class="p">(</span><span class="nv">prn</span> <span class="p">(</span><span class="nv">str</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">element</span><span class="p">)</span> <span class="s">"!"</span><span class="p">)))</span>
   <span class="o">'</span><span class="p">(</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
</code></pre></div></div>

<h1 id="functions">Functions</h1>
<p>The Clojure programming language is built on the foundation of functional programming, which itself suggests a language rich in functions.</p>
<h2 id="anonymous-function-shorthand">Anonymous Function Shorthand</h2>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Accessing Function Arguments Within Shorthand Syntax</span>
<span class="p">(</span><span class="nb">map</span> <span class="o">#(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">%1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">[1</span> <span class="mi">2</span> <span class="nv">3]</span><span class="p">)</span>
<span class="c1">;; (5 6 7)</span>
</code></pre></div></div>
<h2 id="pre-and-post-conditions">Pre and Post Conditions</h2>
<p>One really powerful feature available in Clojure is the ability to execute code just <em>before</em> and just <em>after</em> the function body itself. This allows us, for example, to validate the function arguments as they come in as well as validate the result of the function is as expected.</p>
<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Syntax Structure for Pre/Post Conditions</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">&lt;fn-name&gt;</span> <span class="nv">[&lt;args&gt;]</span>
    <span class="nv">{:pre</span> <span class="nv">[&lt;fn1&gt;,</span> <span class="nv">&lt;fn2&gt;,</span> <span class="o">...</span><span class="nv">]</span>
     <span class="ss">:post</span> <span class="nv">[&lt;fn1&gt;,</span> <span class="nv">&lt;fn2&gt;,</span> <span class="o">...</span><span class="nv">]}</span>
    <span class="p">(</span><span class="nv">&lt;fn-body&gt;</span><span class="p">))</span>

<span class="c1">;; Example of Pre/Post Conditions</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">my-sum</span> <span class="nv">[f,</span> <span class="nv">g]</span>
    <span class="nv">{:pre</span> <span class="nv">[</span><span class="p">(</span><span class="nv">integer?</span> <span class="nv">f</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">integer?</span> <span class="nv">g</span><span class="p">)</span><span class="nv">]</span>
     <span class="ss">:post</span> <span class="nv">[</span><span class="p">(</span><span class="nv">integer?</span> <span class="nv">%</span><span class="p">)</span><span class="nv">]}</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">))</span>

<span class="c1">;; (my-sum "2" 2))  --&gt;   Exception:</span>
<span class="nv">AssertionError</span> <span class="nv">Assert</span> <span class="nv">failed:</span> <span class="p">(</span><span class="nv">integer?</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">user/my-sum</span>
<span class="p">(</span><span class="nv">form-init611908878853766826.clj:1</span><span class="p">)</span>

<span class="c1">;; Modified Pre/Post Condition Logic</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">my-sum</span> <span class="nv">[f,</span> <span class="nv">g]</span>
    <span class="nv">{:pre</span> <span class="nv">[</span><span class="p">(</span><span class="nv">integer?</span> <span class="nv">f</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">integer?</span> <span class="nv">g</span><span class="p">)</span><span class="nv">]</span>
     <span class="ss">:post</span> <span class="nv">[</span><span class="p">(</span><span class="nv">integer?</span> <span class="nv">%</span><span class="p">)</span><span class="nv">]}</span>
    <span class="p">(</span><span class="nv">str</span> <span class="s">"Result: "</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">)))</span>

<span class="c1">;; (my-sum "2" 2))  --&gt;   Exception:</span>
<span class="nv">AssertionError</span> <span class="nv">Assert</span> <span class="nv">failed:</span> <span class="p">(</span><span class="nv">integer?</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">user/my-sum</span>
<span class="p">(</span><span class="nv">form-init611908878853766826.clj:1</span><span class="p">)</span>

<span class="c1">;; Modified Pre/Post Condition Logic to Fix Post Error</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">my-sum</span> <span class="nv">[f,</span> <span class="nv">g]</span>
    <span class="nv">{:pre</span> <span class="nv">[</span><span class="p">(</span><span class="nv">integer?</span> <span class="nv">f</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="nv">integer?</span> <span class="nv">g</span><span class="p">)</span><span class="nv">]</span>
     <span class="ss">:post</span> <span class="nv">[</span><span class="p">(</span><span class="nv">string?</span> <span class="nv">%</span><span class="p">)</span><span class="nv">]}</span>
    <span class="p">(</span><span class="nv">str</span> <span class="s">"Result: "</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">)))</span>
<span class="c1">;; (my-sum "2" 2))  --&gt;  "Result: 4"</span>
</code></pre></div></div>
<h2 id="clojurecore">clojure.core</h2>
<p>The <em>clojure.core</em> namespace contains functions and macros for dealing with all sorts of requirements.</p>


	</article>
	<br/>
<!--
  <a href="http://twitter.com/home?status=Quick Clojure Review by @CanftIn http://localhost:4000/2020/03-01-Quick-Clojure-Review.html"
	   target="_blank" class="tweet">Tweet this</a> 
	<a href="http://twitter.com/home?status=Quick Clojure Review by @CanftIn http://localhost:4000/2020/03-01-Quick-Clojure-Review.html"
    target="_blank" title="Tweet this" class="tweet_this"><i class="fa fa-twitter"></i></a>
-->
	<a href="#top" class="top">Top</a>
	<div class="cc-license">
		<br/>
<h2>License</h2>
<!--
	This work (<a xmlns:cc="http://creativecommons.org/ns#" href="/2020/03-01-Quick-Clojure-Review.html" property="cc:attributionName"
				  rel="cc:attributionURL">Quick Clojure Review</a>) is licensed under a
	<a rel="license"
	   href="http://creativecommons.org/licenses/by-nc-nd/4.0/">
    Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.

	<a rel="license"
	   href="http://creativecommons.org/licenses/by-nc-nd/4.0/"></a><br/>
<br/>
-->
<div style="text-align: center;">
    <img alt="License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"/>
</div>
<br/>

	</div>
</section>
<div class="comment">
	<br/><br/>


<div class="wrapper container">
	<div id=comments>
		<a href="https://github.com/CanftIn/CanftIn.github.io/issues/new">
			Create an issue
		</a>
		to apply for commentary
	</div>
</div>



</div>

<footer>
	<div class="copyright left mobile-block">
		© 2016-2020
		<span title="CanftIn">CanftIn</span>
	</div>
	<a href="/feed.xml">RSS Feed</a>

	
</footer>

</body>
</html>
