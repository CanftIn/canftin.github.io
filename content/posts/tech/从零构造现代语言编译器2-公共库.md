---
title: "从零构造现代语言编译器(2): 公共库"
date: 2023-09-21T18:05:39+08:00
lastmod: 2023-09-21T18:05:39+08:00
author: ["CanftIn"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- 
description: ""
weight:
slug: ""
draft: true # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

本章主要介绍公共库里的基础组件。

## 1. 流

引入工具基类Printable如下：

```cpp
/// CRTP基类，用于打印类型，子类必须实现Print接口：
/// - auto Print(llvm::raw_ostream& out) -> void;
template <typename DerivedT>
class Printable {
  /// 提供给debugger的简单接口，
  /// `LLVM_DUMP_METHOD` 宏确保只有在调试构建中才会包含这个方法。
  LLVM_DUMP_METHOD void Dump() const {
    static_cast<const DerivedT*>(this)->Print(llvm::errs());
  }

  /// llvm::raw_ostream输出。
  friend auto operator<<(llvm::raw_ostream& out, const DerivedT& obj)
      -> llvm::raw_ostream& {
    obj.Print(out);
    return out;
  }

  /// std::ostream输出。
  friend auto operator<<(std::ostream& out, const DerivedT& obj)
      -> std::ostream& {
    llvm::raw_os_ostream raw_os(out);
    obj.Print(raw_os);
    return out;
  }

  friend auto PrintTo(DerivedT* p, std::ostream* out) -> void {
    *out << static_cast<const void*>(p);
    if (p) {
      *out << " pointing to " << *p;
    }
  }
};
```

这个类是一个使用CRTP的基类，用于实现可打印的对象。

### CRTP（Curiously Recurring Template Pattern）

CRTP是C++中一种常用的编程模式，全名为“Curiously Recurring Template Pattern”，中文可以翻译为“奇异递归模板模式”。这个模式主要用于实现编译时多态性，也就是在编译时解析多态行为，而不是运行时。

#### 基本结构

在CRTP中，一个模板基类会以其派生类作为模板参数。这样，基类就可以在编译时知道其派生类的类型。

```cpp
template <typename Derived>
class Base {
  // ...
};

class Derived : public Base<Derived> {
  // ...
};
```

#### 工作原理

基类通过模板参数获得了派生类的类型信息。这样，基类就可以调用派生类的方法或访问其成员，即使这些方法或成员在基类中并没有被声明。

```cpp
template <typename Derived>
class Base {
public:
  void interface() {
    static_cast<Derived*>(this)->implementation();
  }
};

class Derived : public Base<Derived> {
public:
  void implementation() {
    // 实际的实现
  }
};
```

在这个例子中，`Base`类有一个`interface`方法，它内部调用了`implementation`方法。这个`implementation`方法是在`Derived`类中定义的，但`Base`类可以通过`static_cast`安全地调用它。

#### 优点

1. **编译时多态**: 由于多态行为在编译时就被解析，因此运行时性能开销小。
2. **代码复用**: 可以在基类中实现通用逻辑，减少代码重复。
3. **类型安全**: 使用`static_cast`进行类型转换是安全的，因为基类知道派生类的确切类型。

#### 缺点

1. **不适用于运行时多态**: CRTP无法实现运行时多态，因为它依赖于编译时类型信息。
2. **代码可读性**: 对于不熟悉CRTP的开发者来说，代码可能会显得有些复杂。

#### 使用场景

CRTP常用于以下几种场景：

1. **静态多态**: 如上面的例子所示，可以用于实现编译时多态。
2. **Mixin 类**: 可以用CRTP实现mixin（混入）功能，即在一个类中混入另一个类的功能。
3. **工具类**: 如在问题中的`Printable`类，用于提供一组通用的接口或实现。

总体来说，CRTP是一种非常强大而灵活的编程模式，尤其适用于需要高性能和代码复用的场景。

CRTP是一种在C++中常用的技术，用于实现编译时多态性。

### Mixin 功能

在 C++ 中，Mixin 是一种编程模式，用于通过组合而非继承来向一个类添加额外的功能或行为。Mixin 类通常是一些小型、可复用的组件，它们定义了特定的行为或功能，但不应该单独使用。通过将多个 Mixin 类组合在一起，你可以创建出具有多种功能的复杂对象。

Mixin 通常与模板编程和多重继承一起使用，以实现更高的灵活性和代码复用。

#### 示例 1：日志 Mixin

假设你有一个 `LoggerMixin` 类，它提供了日志功能。

```cpp
class LoggerMixin {
public:
  void log(const std::string& message) {
    std::cout << "[LOG]: " << message << std::endl;
  }
};
```

#### 示例 2：计时 Mixin

再假设你有一个 `TimerMixin` 类，用于计算代码执行时间。

```cpp
#include <chrono>

class TimerMixin {
public:
  void startTimer() {
    start = std::chrono::high_resolution_clock::now();
  }

  void stopTimer() {
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    std::cout << "Time taken: " << duration.count() << " microseconds" << std::endl;
  }

private:
  std::chrono::time_point<std::chrono::high_resolution_clock> start;
};
```

#### 示例 3：组合 Mixin

现在，你可以创建一个新类，通过多重继承来组合这两个 Mixin。

```cpp
class MyClass : public LoggerMixin, public TimerMixin {
public:
  void doSomething() {
    log("Starting operation...");
    startTimer();

    // 执行一些操作
    // ...

    stopTimer();
    log("Operation completed.");
  }
};
```

#### 使用

```cpp
int main() {
  MyClass obj;
  obj.doSomething();
  return 0;
}
```

这样，`MyClass` 就继承了 `LoggerMixin` 和 `TimerMixin` 的所有功能，而你不需要在 `MyClass` 中重新实现这些功能。

### 优点

1. **代码复用**: 你可以在多个类中重用同一个 Mixin。
2. **解耦**: Mixin 使得功能模块与业务逻辑解耦，更易于维护和扩展。
3. **灵活性**: 你可以灵活地组合多个 Mixin，以创建具有所需功能的新类。

### 缺点

1. **复杂性**: 使用多重继承和模板可能会增加代码复杂性。
2. **名称冲突**: 如果两个 Mixin 有相同的成员，可能会导致名称冲突。

总体来说，Mixin 是一种非常强大的编程模式，尤其适用于需要高度模块化和代码复用的场景。

这里的`Printable`类被设计为一个基类，它期望子类实现一个`Print`接口。

### `Printable`类的用途和功能

1. **类型打印**: 通过`Print`接口，子类可以自定义如何将其内容打印到输出流。
2. **多种输出流支持**: 支持`llvm::raw_ostream`和`std::ostream`两种输出流。
3. **调试支持**: 提供了一个`Dump`方法，用于在调试时快速查看对象的状态。

#### 示例

假设有一个`Person`类，我们希望能够打印其信息：

```cpp
class Person : public Printable<Person> {
public:
  Person(std::string name, int age) : name(name), age(age) {}
  void Print(llvm::raw_ostream& out) const {
    out << "Person { name: " << name << ", age: " << age << " }";
  }
private:
  std::string name;
  int age;
}
```

现在，`Person`类就可以使用`Printable`提供的所有功能。

```cpp
Person p("Alice", 30);
llvm::raw_ostream& os = llvm::outs();
os << p;  // 输出：Person { name: Alice, age: 30 }
```

### LLVM和它的用途

LLVM是一个编译器基础设施项目，提供了一系列模块化的编译器组件和工具链。它用于开发编译器前端和后端，以及其他代码转换和代码生成工具。

#### 示例

1. **优化代码**: LLVM可以接收中间代码，进行各种优化，并生成高效的目标代码。
2. **跨平台编译**: 使用LLVM，你可以轻易地将代码编译为不同平台和架构的目标代码。

### 好处和问题解决

1. **代码重用**: 使用`Printable`类，你可以避免在每个需要打印的类中重复相同的代码。
2. **统一接口**: 通过继承`Printable`，所有类都有一个统一的打印接口。
3. **调试方便**: `Dump`方法和`llvm::raw_ostream`的支持使得在复杂的LLVM环境中进行调试更加方便。

### 如果没有这些工具

1. **代码重复**: 每个需要打印的类都需要实现自己的打印逻辑。
2. **缺乏统一性**: 不同的类可能会有不同的打印方法和格式。
3. **调试困难**: 在没有这样的基础设施的情况下，调试可能会更加复杂和耗时。

综上所述，`Printable`类和LLVM都是非常强大的工具，它们解决了代码重用、统一接口和调试等多个问题，极大地提高了开发效率和代码质量。


## EnumBase枚举模版类型
