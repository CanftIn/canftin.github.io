---
title: "从零构造现代语言编译器(2): 公共库"
date: 2023-09-21T18:05:39+08:00
lastmod: 2023-09-21T18:05:39+08:00
author: ["CanftIn"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- 
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

本章主要介绍公共库里的基础组件，这些组件抽象出来用于统一编程方式，达到可复用性，其中有一些重复造轮子的组件，这里也对这些组件和现有开源组件做对比分析。

## 1. 流

引入工具基类Printable如下：

```cpp
/// CRTP基类，用于打印类型，子类必须实现Print接口：
/// - auto Print(llvm::raw_ostream& out) -> void;
template <typename DerivedT>
class Printable {
  /// 提供给debugger的简单接口，
  /// `LLVM_DUMP_METHOD` 宏确保只有在调试构建中才会包含这个方法。
  LLVM_DUMP_METHOD void Dump() const {
    static_cast<const DerivedT*>(this)->Print(llvm::errs());
  }

  /// llvm::raw_ostream输出。
  friend auto operator<<(llvm::raw_ostream& out, const DerivedT& obj)
      -> llvm::raw_ostream& {
    obj.Print(out);
    return out;
  }

  /// std::ostream输出。
  friend auto operator<<(std::ostream& out, const DerivedT& obj)
      -> std::ostream& {
    llvm::raw_os_ostream raw_os(out);
    obj.Print(raw_os);
    return out;
  }

  friend auto PrintTo(DerivedT* p, std::ostream* out) -> void {
    *out << static_cast<const void*>(p);
    if (p) {
      *out << " pointing to " << *p;
    }
  }
};
```

这里的`Printable`类被设计为一个基类，用于实现可打印的对象，它期望子类实现一个`Print`接口。

### 1.1 `Printable`类的用途和功能

1. **类型打印**: 通过`Print`接口，子类可以自定义如何将其内容打印到输出流。
2. **多种输出流支持**: 支持`llvm::raw_ostream`和`std::ostream`两种输出流。
3. **调试支持**: 提供了一个`Dump`方法，用于在调试时快速查看对象的状态。

假设有一个`Person`类，我们希望能够打印其信息：

```cpp
class Person : public Printable<Person> {
public:
  Person(std::string name, int age) : name(name), age(age) {}
  void Print(llvm::raw_ostream& out) const {
    out << "Person { name: " << name << ", age: " << age << " }";
  }
private:
  std::string name;
  int age;
}
```

现在，`Person`类就可以使用`Printable`提供的所有功能。

```cpp
Person p("Alice", 30);
llvm::raw_ostream& os = llvm::outs();
os << p;  // 输出：Person { name: Alice, age: 30 }
```

### 1.2 介绍CRTP和Mixin

CRTP是C++中一种常用的编程模式，全名为“Curiously Recurring Template Pattern”，中文可以翻译为“奇异递归模板模式”。这个模式主要用于实现编译时多态性，也就是在编译时解析多态行为，而不是运行时。

1. **编译时多态**: 由于多态行为在编译时就被解析，因此运行时性能开销小。
2. **代码复用**: 可以在基类中实现通用逻辑，减少代码重复。
3. **类型安全**: 使用`static_cast`进行类型转换是安全的，因为基类知道派生类的确切类型。
4. **不适用于运行时多态**: CRTP无法实现运行时多态，因为它依赖于编译时类型信息。
5. **代码可读性**: 对于不熟悉CRTP的开发者来说，代码可能会显得有些复杂。

在CRTP中，一个模板基类会以其派生类作为模板参数。这样，基类就可以在编译时知道其派生类的类型，基类就可以调用派生类的方法或访问其成员，即使这些方法或成员在基类中并没有被声明。

```cpp
template <typename Derived>
class Base {
public:
  void interface() {
    static_cast<Derived*>(this)->implementation();
  }
};

class Derived : public Base<Derived> {
public:
  void implementation() {
    // 实际的实现
  }
};
```

在这个例子中，`Base`类有一个`interface`方法，它内部调用了`implementation`方法。这个`implementation`方法是在`Derived`类中定义的，但`Base`类可以通过`static_cast`安全地调用它。

CRTP常用于以下几种场景：

1. **静态多态**: 如上面的例子所示，可以用于实现编译时多态。
2. **Mixin 类**: 可以用CRTP实现mixin（混入）功能，即在一个类中混入另一个类的功能。
3. **工具类**: 如在问题中的`Printable`类，用于提供一组通用的接口或实现。

总体来说，CRTP是一种非常强大而灵活的编程模式，尤其适用于需要高性能和代码复用的场景。

#### Mixin 功能

在 C++ 中，Mixin 是一种编程模式，用于通过组合而非继承来向一个类添加额外的功能或行为。Mixin 类通常是一些小型、可复用的组件，它们定义了特定的行为或功能，但不应该单独使用。通过将多个 Mixin 类组合在一起，你可以创建出具有多种功能的复杂对象。

Mixin 通常与模板编程和多重继承一起使用，以实现更高的灵活性和代码复用。

假设你有一个 `LoggerMixin` 类，它提供了日志功能。

```cpp
class LoggerMixin {
public:
  void log(const std::string& message) {
    std::cout << "[LOG]: " << message << std::endl;
  }
};
```

再假设你有一个 `TimerMixin` 类，用于计算代码执行时间。

```cpp
#include <chrono>

class TimerMixin {
public:
  void startTimer() {
    start = std::chrono::high_resolution_clock::now();
  }

  void stopTimer() {
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    std::cout << "Time taken: " << duration.count() << " microseconds" << std::endl;
  }

private:
  std::chrono::time_point<std::chrono::high_resolution_clock> start;
};
```

现在，你可以创建一个新类，通过多重继承来组合这两个 Mixin。

```cpp
class MyClass : public LoggerMixin, public TimerMixin {
public:
  void doSomething() {
    log("Starting operation...");
    startTimer();

    // 执行一些操作
    // ...

    stopTimer();
    log("Operation completed.");
  }
};
```

使用：

```cpp
int main() {
  MyClass obj;
  obj.doSomething();
  return 0;
}
```

这样，`MyClass` 就继承了 `LoggerMixin` 和 `TimerMixin` 的所有功能，而你不需要在 `MyClass` 中重新实现这些功能。

1. **代码复用**: 你可以在多个类中重用同一个 Mixin。
2. **解耦**: Mixin 使得功能模块与业务逻辑解耦，更易于维护和扩展。
3. **灵活性**: 你可以灵活地组合多个 Mixin，以创建具有所需功能的新类。
4. **复杂性**: 使用多重继承和模板可能会增加代码复杂性。
5. **名称冲突**: 如果两个 Mixin 有相同的成员，可能会导致名称冲突。


### 1.3 LLVM输出流重载

LLVM是一个编译器基础设施项目，提供了一系列模块化的编译器组件和工具链。它用于开发编译器前端和后端，以及其他代码转换和代码生成工具。其中`llvm::raw_ostream`是llvm上的原始输出流。
```cpp
namespace llvm {

/// 注入一个 `operator<<` 重载到 llvm 命名空间，
/// 将 LLVM 类型的 `raw_ostream` 重载映射到 `std::ostream` 重载。
template <typename StreamT, typename ClassT,
          typename = std::enable_if_t<
              std::is_base_of_v<std::ostream, std::decay_t<StreamT>>>,
          typename = std::enable_if_t<
              !std::is_same_v<std::decay_t<ClassT>, raw_ostream>>>
auto operator<<(StreamT& standard_out, const ClassT& value) -> StreamT& {
  raw_os_ostream(standard_out) << value;
  return standard_out;
}

}  // namespace llvm
```

这段代码定义了一个模板函数 `operator<<`，该函数重载了流插入运算符 `<<`。这个重载函数位于 `llvm` 命名空间中，并且是为了将 LLVM 的 `raw_ostream` 类型的重载映射到 C++ 标准库的 `std::ostream` 类型。其中 `StreamT` 代表流类型，通常是 `std::ostream` 或其派生类，`ClassT` 代表要输出的类的类型。

`std::enable_if_t<std::is_base_of_v<std::ostream, std::decay_t<StreamT>>>`: 这个条件使用SFINAE（替换失败不是错误）确保 `StreamT` 是 `std::ostream` 的基类或者就是 `std::ostream` 本身。

`std::enable_if_t<!std::is_same_v<std::decay_t<ClassT>, raw_ostream>>` 这个条件确保 `ClassT` 不是 `raw_ostream` 类型。

`raw_os_ostream(standard_out) << value;` 这里创建了一个 `raw_os_ostream` 对象，该对象是 LLVM 提供的一个流类，用于将 `std::ostream` 包装成 `raw_ostream`。然后，使用 `raw_ostream` 的 `<<` 运算符将 `value` 输出到这个流中。

这样做的目的是利用 LLVM 已经为 `raw_ostream` 定义的 `<<` 运算符重载。这样，任何能够通过 `raw_ostream` 输出的 `ClassT` 类型都可以通过这个新的 `<<` 运算符重载输出到 `std::ostream`。

`return standard_out;` 最后，函数返回传入的 `std::ostream` 引用，以支持链式调用。

假设 LLVM 已经为一个名为 `MyLLVMClass` 的类定义了如下的 `<<` 运算符重载：

```cpp
llvm::raw_ostream& operator<<(llvm::raw_ostream& out, const MyLLVMClass& obj) {
  // ... 输出逻辑
  return out;
}
```

现在，你可以这样使用新的 `<<` 运算符重载：

```cpp
std::cout << MyLLVMClassInstance;  // 这里会调用上面定义的 operator<<
```

这样，`MyLLVMClassInstance` 就会被正确地输出到 `std::cout`，而这一切都是通过 LLVM 的 `raw_ostream` 完成的。

总结一下，这段代码的主要目的是为了提供一种机制，使得任何可以通过 LLVM 的 `raw_ostream` 输出的对象都可以直接通过 C++ 的 `std::ostream` 输出，从而实现两者之间的重载映射。这样做提高了代码的可复用性和一致性。

## 2. EnumBase枚举模版类型

```cpp
/// 用CRTP以及X-Macro来生成枚举类的模板类。
template <typename DerivedT, typename EnumT, const llvm::StringLiteral Names[]>
class EnumBase : public Printable<DerivedT> {
 public:
  using RawEnumType = EnumT;  // 用于定义原始的模版类型。
  using EnumType = DerivedT;  // 派生的枚举类型。
  using UnderlyingType =
      std::underlying_type_t<RawEnumType>;  // 原始枚举类型的底层类型。

  /// 允许将枚举类转换为原始的枚举类型，
  constexpr operator RawEnumType() const { return value_; }

  explicit operator bool() const = delete;

  /// 返回枚举的名称。
  [[nodiscard]] auto name() const -> llvm::StringRef { return Names[AsInt()]; }

  /// 打印名称，使用于Printable，必须实现。
  auto Print(llvm::raw_ostream& out) const -> void { out << name(); }

 protected:
  constexpr EnumBase() = default;

  /// 从原始枚举器创建类型。
  static constexpr auto Create(RawEnumType value) -> EnumType {
    EnumType result;
    result.value_ = value;
    return result;
  }

  /// 转换为整数类型。
  constexpr auto AsInt() const -> UnderlyingType {
    return static_cast<UnderlyingType>(value_);
  }

  /// 从底层整数类型转换为枚举类型。
  static constexpr auto FromInt(UnderlyingType value) -> EnumType {
    return Create(static_cast<RawEnumType>(value));
  }

 private:
  RawEnumType value_;
};
```

这段代码定义了一个用于生成枚举类的模板类 `EnumBase`，以及一系列用于辅助生成枚举类的宏。这个模板类和宏的组合提供了一种灵活、可复用的方式来创建和操作枚举类。它的设计目的：

1. **类型安全**: 通过使用强类型的枚举（`enum class`），提供更好的类型安全。
2. **可打印**: 通过继承以上的 `Printable`，使得枚举值可以被打印。
3. **名称获取**: 提供了一个 `name()` 方法，用于获取枚举值的名称。

#### 主要宏

```cpp
// 创造原始枚举类（不涉及名称）。
#define COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType) \
  namespace Internal {                                                         \
  enum class EnumClassName##RawEnum : UnderlyingType;                          \
  }                                                                            \
  enum class Internal::EnumClassName##RawEnum : UnderlyingType

// 创造原始枚举类。
#define COCKTAIL_DEFINE_RAW_ENUM_CLASS(EnumClassName, UnderlyingType) \
  namespace Internal {                                                \
  extern const llvm::StringLiteral EnumClassName##Names[];            \
  }                                                                   \
  COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES(EnumClassName, UnderlyingType)

// 在原始枚举类的定义中生成每个枚举值。
#define COCKTAIL_RAW_ENUM_ENUMERATOR(Name) Name,

#define COCKTAIL_ENUM_BASE(EnumClassName) \
  COCKTAIL_ENUM_BASE_CRTP(EnumClassName, EnumClassName, EnumClassName)

#define COCKTAIL_ENUM_BASE_CRTP(EnumClassName, LocalTypeNameForEnumClass, \
                                EnumClassNameForNames)                    \
  ::Cocktail::Internal::EnumBase<LocalTypeNameForEnumClass,               \
                                 Internal::EnumClassName##RawEnum,        \
                                 Internal::EnumClassNameForNames##Names>

// 枚举类体内生成每个值的命名常量声明。
#define COCKTAIL_ENUM_CONSTANT_DECLARATION(Name) static const EnumType Name;

// 枚举类体外定义每个命名常量。
#define COCKTAIL_ENUM_CONSTANT_DEFINITION(EnumClassName, Name) \
  constexpr EnumClassName EnumClassName::Name =                \
      EnumClassName::Create(RawEnumType::Name);

#define COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION(Name)   \
  static constexpr const typename Base::EnumType& Name = \
      Base::Create(Base::RawEnumType::Name);

// 在 `.cc` 文件中为枚举类开始定义每个枚举器的常量名数组。
#define COCKTAIL_DEFINE_ENUM_CLASS_NAMES(EnumClassName) \
  constexpr llvm::StringLiteral Internal::EnumClassName##Names[]

#define COCKTAIL_ENUM_CLASS_NAME_STRING(Name) #Name,
```

1. **COCKTAIL_DEFINE_RAW_ENUM_CLASS_NO_NAMES**: 定义一个没有名称数组的原始枚举类。
2. **COCKTAIL_DEFINE_RAW_ENUM_CLASS**: 定义一个有名称数组的原始枚举类。
3. **COCKTAIL_RAW_ENUM_ENUMERATOR**: 在原始枚举类定义中生成每个枚举值。
4. **COCKTAIL_ENUM_BASE**: 生成用于派生的 `EnumBase` 类型。
5. **COCKTAIL_ENUM_CONSTANT_DECLARATION**: 在枚举类体内生成每个值的命名常量声明。
6. **COCKTAIL_ENUM_CONSTANT_DEFINITION**: 在枚举类体外定义每个命名常量。
7. **COCKTAIL_INLINE_ENUM_CONSTANT_DEFINITION**: 用于内联定义每个命名常量。
8. **COCKTAIL_DEFINE_ENUM_CLASS_NAMES**: 在 `.cc` 文件中为枚举类开始定义每个枚举器的常量名数组。
9. **COCKTAIL_ENUM_CLASS_NAME_STRING**: 用于生成枚举值名称的字符串。

这个 `EnumBase` 类和相关的宏提供了一种高度可定制和可复用的方式来创建和操作枚举类。它们解决了类型安全、可打印性和名称获取等常见问题，同时也提供了一种简洁、一致的方式来定义和使用枚举类。这样的设计非常适用于大型项目中，特别是那些需要多次定义和使用不同枚举类的项目。

#### 什么是X-Macro

X-Macro 是一种 C 和 C++ 预处理器技术，用于生成重复或模式化的代码。这种技术通过定义宏来实现，这些宏在不同的上下文中被多次展开，以生成不同的代码片段。X-Macro 主要用于减少代码重复，提高代码的可维护性。

一个典型的 X-Macro 的使用方式是定义一个宏，该宏接受一个或多个参数，并在不同的上下文中多次展开。

```cpp
#define COLOR_XMACRO \
  X(Red)             \
  X(Green)           \
  X(Blue)

// 定义枚举
enum Color {
#define X(name) name,
  COLOR_XMACRO
#undef X
};

// 定义字符串数组
const char* ColorNames[] = {
#define X(name) #name,
  COLOR_XMACRO
#undef X
};
```

在这个例子中，`COLOR_XMACRO` 宏定义了一个颜色列表。然后，通过在不同的上下文中展开 `X` 宏，我们生成了一个 `Color` 枚举和一个 `ColorNames` 字符串数组。

X-Macro 也可以用于更复杂的代码生成任务。

```cpp
#define PERSON_XMACRO  \
  X(std::string, Name) \
  X(int, Age)          \
  X(double, Height)

// 定义结构体
struct Person {
#define X(type, name) type name;
  PERSON_XMACRO
#undef X
};

// 序列化函数
std::string Serialize(const Person& p) {
  std::string result;
#define X(type, name) result += std::to_string(p.name) + " ";
  PERSON_XMACRO
#undef X
  return result;
}

// 反序列化函数（简化版）
void Deserialize(Person& p, const std::string& s) {
  std::istringstream iss(s);
#define X(type, name) iss >> p.name;
  PERSON_XMACRO
#undef X
}
```

在这个例子中，`PERSON_XMACRO` 定义了一个 `Person` 结构体的字段。然后，我们生成了该结构体的定义以及其序列化和反序列化函数。

1. **减少代码重复**: 通过在多个地方展开相同的宏，减少了代码重复。
2. **提高可维护性**: 如果需要添加、删除或修改某个元素，只需在一个地方进行更改。
3. **灵活性**: 可以在不同的上下文中以不同的方式展开相同的宏。
4. **可读性**: 对于不熟悉 X-Macro 的人来说，代码可能难以理解。
5. **调试困难**: 预处理器生成的代码可能难以调试。

总体来说，X-Macro 是一种非常强大的代码生成技术，尤其适用于需要生成重复或模式化代码的场景。然而，它也有一些缺点，如可能降低代码的可读性和可调试性。因此，在使用 X-Macro 时，应权衡其优缺点。
